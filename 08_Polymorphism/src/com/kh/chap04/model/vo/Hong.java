package com.kh.chap04.model.vo;

	// 여러개의 찜닭집을 만들건데 동일하게 찜닭을 주문하는 인터페이스를 사용해볼것 --> 인터페이스를 구현한다! 고 표현
	// Abstraction(추상화) / Implementation(구체화, 실체화)
	// 추상메소드는 메소드바디가 없고 메소드시그니처만 있었음, 메소드를 실체화해두지않았다. --> 추상화해둔것
	// 추상클래스를 상속받은 친구들이 메소드를 오버라이딩했음 --> 메소드의 동작방식을 실체화, 구체화함 --> 이게 implementation
	// 인터페이스는 추상화의 끝판왕, 메뉴판에 찜닭주문이라고만 씀
	// 보는쪽에선 찜닭주문만 보고 주문, 만드는쪽에서는? 찜닭을 구현해줘야함
	// 인터페이스를 사용할 때, 인터페이스를 사용할 클래스는 이 인터페이스를 구현해줘야함!
	// 상속은 확장함, 인터페이스는 구현함 --> 키워드 implements, 그 뒤에 구현하고자하는 인터페이스의 식별자

public class Hong implements Jjimdak {
	// The type Hong must implement the inherited abstract method Jjimdak.order()
	// 타입은 자료형으로 해석, Hong이라는 클래스는 반드시 구현해야해! 어떤거? 상속받은 추상메소드! 뭔데? 인터페이스의 order라는 메소드!
	// void order();가 추상메소드 --> 구체화, 실체화 --> 코드상으로는 오버라이딩 해줘야함
	// 인터페이스는 호출했을 때 어떻게 돌아가야하는지 안적혀있음
	
	// 오버라이딩하려면? 애노테이션!
	@Override
	public void order() {
		// 주문들어왔을때 Hong이 동작할 메소드를 구현해줌
		System.out.println("비법양념에 숙성한 후 400도 가까운 온도로 조리해서 찜닭 만들기");
	}
	
}
