package com.kh.chap05.model.vo;

	/*
	 * Interface
	 * 
	 * [ 표현법 ]
	 * 접근제한자 interface 인터페이스식별자 {
	 * 
	 * 		// 매번 만들던 클래스가 가졌던 것들
	 * 		// 필드
	 * 		// 생성자
	 * 		// 메소드
	 * 
	 * 		// 인터페이스가 기본적으로 가지는 것들, 실제로 가질 수 있는건 더 있음, static 필드(static P{}), default 메소드(default void hi() {}) 등
	 * 		// 상수 필드
	 * 		// 추상메소드
	 * 
	 * 인터페이스는 객체 생성을 할 수 없으므로 생성자를 가질 수 없음
	 * 
	 * public MusicI() {} <-- 이런거 안됨
	 * 
	 * }
	 * 
	 * 일반적인 클래스와는 전혀다름(아주큰차이가있음), 추상클래스와는 어느정도 비슷한점이 있음 --> 그래도 세가지로 명확하게 구분!
	 * 
	 * 구체 클래스(추상클래스 하기전까지 썼던거)
	 * 추상 클래스(오늘 오전에 배운거 abstract 붙은거, 구체화되지않은클래스, 미완성클래스)
	 * 인터페이스(완전히 또 다른 새로운 친구! 추상화를 코드상으로 옮겨놓은 개념)
	 * 
	 * - 추상클래스보다 더욱 강한 규칙성, 강제성을 가짐
	 * 		강제성이 있는것이 장점이 될 수도 있고, 단점이 될 수도 있음
	 * 		기능을 추가하려면? 추상메소드를 만들어서 전부 오버라이딩 해줘야함 --> 디폴트 문법 설명하심
	 * 
	 * - 인터페이스의 필드는 상수 필드
	 * 
	 * - 인터페이스의 메소드는 키워드를 붙이지 않는 이상 추상메소드
	 * 
	 * - 인터페이스는 다중 구현을 허용한다.(인터페이스만 가지는 특징!)
	 * 상속은 단일상속만 가능했다(언어적 차원에서 막아뒀음, 하나의 클래스만 상속받을 수 있었음) --> 인터페이스 추가하러감(MultipleInterface 추가했음)
	 * 여러개의 인터페이스를 구현할 수 있음, 하고싶은대로 여러개 --> 인터페이스는 다중으로 해도 괜찮다. 왜?
	 * 하나의 구체클래스가 두개이상의 인터페이스를 구현하더라도 어차피 인터페이스가 각자 가지고 있던 메소드는 구현하고 있는 입장에서 보면 어떻게 동작하는지 안써져있기때문에(구현하는건 구현하는쪽에서 해줘야함) 구체클래스에서 구현하면 되고, 동일한 이름 메소드였어도 상관없음
	 * 필드도 마찬가지, 서로 다른 클래스에서 필드 이름이 똑같을 수 있지만 구현하는 입장에서는 각각 따로 보임 --> 지금은 인터페이스가 가진것은 상수필드이므로 MusicI.NUM 해야함, 어쨌든 구현하는 쪽에 있는게 아니라 인터페이스에 있는 필드임, 스태틱에 올라감, 영역이 다름
	 * 그러므로 다중구현해도 문제가 없다!
	 * 
	 * - "무조건 구현해야하는 기능이 있을 경우 인터페이스를 사용해서
	 * 	  사용법만 만들어주고 구현하는 쪽에서 실체화하게 만듬" ==> 오버라이딩
	 * 
	 * 1. 추상클래스와 인터페이스의 공통점
	 * 
	 * - 객체 생성은 불가능하지만, 부모자료형의 참조타입으로는 사용이 가능함(다형성을 적용할 수 있음)
	 * - 추상메소드를 가지고 있을 경우, 상속(구현)받는 클래스에서 추상메소드를 오버라이딩 하도록 강제함
	 * 
	 * 2. 차이점
	 * 
	 * - 추상클래스 : 멤버로 일반필드, 일반메소드를 가질 수 있음
	 * 				추상메소드는 있어도 그만 없어도 그만
	 * 
	 * - 인터페이스 : 상수 필드, 특정한 경우를 제외한다면 모든 메소드를 추상메소드로 정의 해야함
	 * 
	 * 둘 다 다형성을 적용하여 외부에서 보여지는 타입의 용도로 사용하지만, 목적이 다름
	 * -> 추상클래스는 자식클래스가 상속을 받아서 필드 / 메소드를 재사용하고 클래스를 확장하는 용도
	 * -> 인터페이스는 기능의 구현을 강제하기 위한 용도
	 * 
	 */

	// 순수 자바개발자의 경우 인터페이스 구분을 위해 인터페이스 식별자 마지막에 대문자 I를 써줌
	// 웹개발자는 또 다른 방식이 있다고 합니다
public interface MusicI {
	// Abstract Data Type(ADT)을 알고있다면 조금 헷갈릴수도 있음
	
	// 인터페이스로는 객체 생성이 불가능하기 때문에 생성자를 기술할 수 없음
	// public MusicI() {}
	
	// 인터페이스에 필드 작성하기
	/*public static final*/int NUM = 1; // The blank final field num may not have been initialized
	// 여태까지 썼던 클래스들에는 그냥 선언만 해도 됐음
	// 이탤릭 --> static 특
	// 인터페이스에서 필드를 선언하면 암묵적으로 앞에 public static final이 붙어있음 --> 상수필드! 상수필드를 쓰는 목적, 존재의의는?
	// 값이 변경되면 큰일나는 고정적인 값들을 메모리(static)영역에 올려놓고 공유해서 쓸 목적
	// 객체생성이 불가능하다는 뜻은? 필드를 가지고 있어도 객체로 생성되어 heap에 올라갈 수 없다는 뜻, 올라갈 수 있는 곳은 static뿐
	// 네이밍컨벤션, 초기화 다 해줘야함
	// 인터페이스에는 어차피 접근제한자, static, final을 안써도 알아서 붙음(인터페이스에 선언한다는건 그렇게 쓰려고 선언하는거니까) --> 이름도 상수처럼, 초기화도 동시에 해줘야함
	// 인터페이스의 모든 필드들은 암묵적으로 static final
	
	/*
	public void hi() {
	}
	// 인터페이스는 이런 메소드를 가질 수 없음
	*/
	
	/*public abstract*/ void play(); // 인터페이스의 메소드를 이렇게만 작성, 자동으로 public abstract로 선언됨
	// 인터페이스의 메소드들은 기본적으로 추상메소드
	// 키워드를 생략하고 반환형과 메소드식별자만 작성, 바디없이
	
	default void stop() {
		System.out.println("음악을 멈춥니다.");
	}
	// 인터페이스를 구현한 모든 클래스가 동일하게 수행해야하는 메소드에는 default 키워드를 붙임
	// 너무 남발하면 좋지않음, 어떻게 보면 인터페이스의 목적과도 맞지 않는 문법
	// 접근제한자의 default와는 전혀 다른 친구임! 얘는 그냥 키워드
	
} // 챕터8 마무리~ 아침에 다형성으로 시작해서 추상클래스, 인터페이스까지 함
	// 결국 객체지향에서 추상화하는 방법들
	// 다형성은 부모타입으로 자식객체 다루는 기술
	// 추상클래스와 인터페이스는 다형성을 사용할 때 조금 더 특화된 친구들.. 추상클래스랑 인터페이스랑 좀 비슷해보이는데? --> 공통점과 차이점 구분하는걸로 마무리
