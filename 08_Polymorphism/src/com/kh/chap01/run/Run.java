package com.kh.chap01.run;

import com.kh.chap01.model.vo.Child1;
import com.kh.chap01.model.vo.Child2;
import com.kh.chap01.model.vo.Parent;

	// 다형성 하기 전에 객체지향 이야기
	/*
	 * 개발자에게 가장 중요한 능력은 문제해결능력 --> 이것은 경험을 통해 축적된다!
	 * 문법은 암기의 영역, 개념은 이해의 영역
	 * 왜 써야하는지 이해하기 위해 필요한 지식이 많아서 당장은 어려울수도있음
	 * 기본적으로 암기가 되어있지 않은 상태에서는 이해할 수 없다.
	 * 
	 */

public class Run {
	
	/*
	 * 구닥다리 객체지향의 꽃은 상속이었음
	 * 상속이란 무엇인가? 필드 / 메소드를 가져와서 쓰니까 중복이 없고 편하다? --> 상속구조에서 중요한건 이게 아님(얘넨 부가적)
	 * 자식클래스가 부모클래스로부터 상속받는것 중에서 제일 중요한게 뭘까? --> 타입(자료형)
	 * 
	 * 상속구조
	 * 
	 * 필드 / 메소드 => 별로 안중요함
	 * 
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * 타입(자료형) --> 8번 프로젝트에서는 이걸 머릿속에넣어두자!
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * 
	 * 
	 */

	public static void main(String[] args) {
		
		// 1. 부모 타입 자료형으로 부모 타입 객체를 다룸
		// 객체 생성
		Parent p1 = new Parent();
		
		// 부모가 가진 멤버 호출 --> 잘 되는지 확인함!
		p1.printParent();
		
		// 부모객체를 이용해서 자식클래스를 호출할수있을까? 안됨
		// p1.printChild1(); // The method printChild1() is undefined for the type Parent
		// 부모 입장에서는 누가 내 자식인지, 자식이 뭘 갖고있는지 모름, 자바에서는 자식이 부모를 고름
		// 자식이 가지고 있는 멤버는 부모가 사용할 수 없음
		// p1변수로는 Parent에만 접근이 가능
		
		// 2. 자식 타입 자료형으로 자식 타입 객체를 다룸
		Child1 c1 = new Child1();
		
		c1.printChild1(); // 자식 객체로 자식의 멤버(메소드) 호출 가능 내껀 내꺼~~~
		c1.printParent(); // 자식 객체로 부모의 멤버(메소드) 호출 가능 --> 상속구조이므로 가능함, 부모껏도 내꺼~~
		// c1변수로는 Child1, Parent랑 둘 다 접근 가능
		
		// = <-- 얘를 기준으로 양변의 자료형이 같아야한다. 이게 아니면 값이 대입될 수 없다!
		// 3. 부모 타입 자료형으로 자식 타입 객체를 다룸 ==> 다형성 적용
		Parent p2 = /*(Parent)*/new Child1(); // 부모타입 객체를 선언하고 자식타입 생성자를 대입
		p2.printParent(); // 부모 타입이 가진 메소드 호출
		// 우리가 배운대로라면 자료형이 다르므로 말이되지않음!
		// 왼쪽은 Parent 타입, 오른쪽은 Child1 타입
		// 오른쪽의 자료형이 Parent 타입이어야 대입될 수 있음, 근데 Parent 타입이 아님! --> 그래도 빨간줄없이 대입이 된 이유! 형변환이 되었다는 뜻!
		// 형변환 하는 법? --> (Parent)new Child1();
		// 2번(우항)이 끝나야 3번(대입)이 될 수 있음! 아무문제없이 일어난 이유는 우리눈에 보이지 않지만 자동으로 (Parent)가 붙었음!
		// 이게 가능한 이유는? 상속구조이기때문! 상속구조가 아닌 클래스(Test)를 대입하려고 하면 빨간줄! Type mismatch : cannot convert from Test to Parent.
		// Parent p3 = new Test();
		
		// 상속구조라면 자식클래스는 부모클래스로부터 타입(자료형)을 물려받아서 사용할수있기때문!! 아까 가장 중요하다고 했던 것!
		// 필드랑 메소드는 자료형이라는 개념 안에 포함되어 있는것! 자료형을 상속받았으니 따라오는 친구들
		
		// 부모 타입의 참조변수로 자식이 가진 멤버를 호출해보자 --> 이게 업캐스팅에 해당함
		// p2.printChild1(); // 아까랑 똑같이 선언되지 않았으므로 호출이 안됨, Parent 타입으로는 자식이 가진 멤버를 호출 못함!
		/*
		 * 메모리구조 그려서 어제 내용 복습
		 * 
		 * [	Parent p1 = new Parent();	]
		 * stack 영역에 Parent 타입의 p1 변수 선언
		 * heap 영역에 올라감, Parent가 올라가야함, 이게 올라가기 위한 선행(전제)조건? Parent는 Object 클래스의 자식이므로 Object 클래스가 먼저 생성되어 올라가야함
		 * 객체 생성후 주소 대입함
		 * 
		 * p1이 printParent() 호출에는 문제가 없음
		 * 
		 * [	Child1 c1 = new Child1();	]
		 * Child1 타입의 c1이라는 이름의 변수 선언, stack의 p1 변수 영역 위에 쌓임
		 * heap 영역에 Child1 영역이 올라가야함, Parent가 올라가있어야함, 그전에 Object가 올라가야함(서로 다른 Object, Parent가 생성됨)
		 * Parent를 extends하는 Child1이므로 Child1을 부모 바깥에 커진 동그라미 모양으로 생각해보자. 생성된 주소를 c1에 대입
		 * Parent안의 printParent도 쓸 수 있고, 내가 가진 printChild1도 쓸 수 있음
		 * 
		 * [	Parent p2 = new Child1();	]
		 * Parent 타입의 변수 p2를 선언하고 new Child1을 했음, 이게 생기려면? Object --> Parent --> Child1 순으로 생성되어야함
		 * Child1이 생성될건데 Parent모양을 쓰겠다고 했음! Parent 범위의 메소드만 사용 가능해짐, Child1만 갖고있던 메소드는 사용할 수 없음
		 * 
		 */
		// p2로는 Parent타입만 접근할 수 있음(내가 자료형을 Parent 타입으로만 쓸거라고 선언했기때문)
		
		// 양쪽의 자료형이 다름에도 불구하고 에러가 발생하지 않는 이유는
		// 부모클래스인 Parent가 자식클래스인 Child1에게 타입을 물려주어서
		// 클래스 형변환이 일어났기 때문
		
		/*
		 * 클래스 형 변환(의 전제조건)
		 * 
		 * "상속 구조"일 경우에만 가능
		 * 
		 * 1. Up Casting
		 * 
		 * 자식타입 => 부모타입
		 * 생략이 가능함
		 * 
		 * 2. Down Casting
		 * 
		 * 부모타입 => 자식타입
		 * 생략이 불가능하다.
		 * 
		 */
		
		// p2.printChild1(); 아까 안됐던것을 클래스 형 변환시킴
		((Child1)p2).printChild1(); // p2(생성하기 위해 불렀던것은 Child1의 생성자)의 실제 형태는 Child1이었으므로 강제 형변환하면 Child1만이 가진 메소드 호출 가능
		
		// Child1타입의 객체 두 개
		// Child2타입의 객체 두 개
		// 총 네개의 객체를 다뤄볼 것
		
		/*
		// 객체 두개 생성
		Child1 child1 = new Child1();
		Child1 child2 = new Child1();
		Child2 child3 = new Child2();
		Child2 child4 = new Child2();
		
		child1.printChild1();
		child2.printChild1();
		child3.printChild2();
		child4.printChild2();
		*/
		// 만약에 객체가 더 많아진다면? 변수가 더 늘어남 --> 조금 더 효율적으로 다루고싶다! --> 객체배열!
		
		// 배열을 사용해보자
		// 배열 == 한 종류의 자료형인 값들을 묶어서 관리할 수 있음
		// 이렇게 생각해도 배열이 몇개 있어야함? 두개 있어야함(Child1, Child2) --> 일단 해!
		/*
		Child1[] arr1 = new Child1[2];
		Child2[] arr2 = new Child2[2];
		arr1[0] = new Child1();
		arr1[1] = new Child1();
		arr2[0] = new Child2();
		arr2[1] = new Child2();
		
		arr1[0].printChild1();
		arr1[1].printChild1();
		arr2[0].printChild2();
		arr2[1].printChild2();
		*/
		// 아까보다는 효율적으로 다룰 수 있게 됨(객체의 개수만큼 변수가 있으면 됐지만 지금은 타입의 개수만큼만 있으면 됨)
		// 여기에 다형성을 적용시켜보자
		
		System.out.println("\n\n\n다형성을 적용해보자");
		// Child1, Child2 둘 다 Parent타입을 상속받고 있으므로 둘 다 Parent타입으로 다룰 수 있음!
		// 배열도 Parent 타입 배열을 선언해서 이 Parent 타입 배열에 한번에 넣을 수 있다!
		Parent[] arr = new Parent[4];
		arr[0] = (Parent)new Child1(); // 원래라면 arr[0] = new Child1(); 이건 될 수 없음, Child1 타입이 Parent 타입 공간에 들어갈 수 없음
		// Child1은 Parent를, 자료형을 상속받고있기 때문에 들어갈 수 있음, 앞에 (Parent) 추가
		arr[1] = (Parent)new Child2();
		arr[2] = new Child2(); // Parent 타입을 상속받고 있기 때문에 굳이 형변환할필요없이도 가능(업캐스팅이 자연스럽게 이루어짐) --> Parent 타입에 들어갈 수 있음
		arr[3] = new Child1();
		// 배열의 요소로 4총사 주소를 담음, Parent 타입의 배열에 객체들의 주소를 담음, 지금 Parent 타입으로 쓰고있음! 이러면 자식의 멤버를 쓸 수 없음
		// arr[0].printChild1(); // 이건 실행불가!
		
		// 어쨌든 얘네는 Child 객체지만 Parent 타입으로 다룰 수는 있음
		for(int i = 0; i < arr.length; i++) {
			arr[i].printParent();
		} // 부모타입으로 다루고 있으니까 부모의 멤버쓰는건 문제없음
		
		// 실제 객체는 Child타입, 내거쓰고싶다 --> 다운캐스팅!(부모타입을 자식타입으로)
		// ((Child1)arr[0]).printChild1(); 이렇게 Child형으로 바꿔서 사용하면 가능하긴 한데 하나하나 하긴 불편함
		
		System.out.println("\n\n\n\n");
		
		for(int i = 0; i < arr.length; i++) {
			
			// 지금같은 경우에는 if문으로도 해결이 가능하지만, 인덱스가 계속 늘어나면? 하나씩 체크해서 전부 쓰기는 힘들어짐
			/*
			if(i == 0 || i == 3) { // 0번 3번 인덱스는 Child1, 1번 2번 인덱스는 Child2 이므로
				((Child1)arr[i]).printChild1();
			} else {
				((Child2)arr[i]).printChild2();
			}
			*/
			
			// 또다른 방법 --> instanceof 연산자
			/*
			if(arr[i] instanceof Child1) { // 반복 돌면서 0번 인덱스부터 차례로 접근할것임
				// instanceof 연산자 => true / false 반환값
				// instanceof 뒤에 붙은 타입이 실질적으로 어떤 클래스 타입인지 연산
				// if문에 OR 연산자 사용, 조건을 잔뜩 걸지 않아도 instanceof로 깔끔하게 해결할 수 있다.
			
				// arr[0]이 Child1이 맞다면 true값 반환, 그게 아니라면 false값 반환
				// 현재 참조변수가 실질적으로 어떤 클래스타입을 참조하고 있는지 확인할 때 사용
				((Child1)arr[i]).printChild1();
				
			} else { // Child1이 아니라면 지금은 Child2밖에 없음
				((Child2)arr[i]).printChild2();
			}
			*/ // 근데 지금은 이게 중요한게 아님, 알려주시려고 이렇게 해봄
			
			// 어제 배운 내용? 1. 객체배열, 2. 상속, 3. 오버라이딩
			
			// 오버라이딩으로 해결해보자 --> 부모자식 클래스 가서 출력용 메소드들 만들고오자, 세 클래스 모두 똑같은 모양의 메소드를 가지고 있는 상태가 됨
			arr[i].print(); // 위에 있던것들 전부 주석처리하고 이렇게 해봄! 얘는 지금 정적바인딩, 컴파일하고나서 묶어준것
			// 지금 시점에서 다형성을 받아들이는 방법 --> 객체를 조금 더 효율적으로 다루기 위한 방법 --> 다형성!
			// 1. 변수만 사용했을 때, 2. 객체 배열을 사용했을 때, 3. 다형성을 적용했을 때, 이것들과 비교
			// 각각의 객체를 다루는 방법이 어떻게 차이가 일어나는지
			// print() 메소드에 커서 올려보면 부모의 메소드를 호출하고있음 --> void com.kh.chap01.model.vo.Parent.print ()
			// 원래대로라면 부모클래스 머시기 X 4 로 출력이 되어야함
			// 실질적으로 우리가 print를 호출(참조)하고 있는 객체는 누구? 자식타입객체! arr[i]를 통해서 주소 찾아서 가보니 (부모가 있는게 아니고)자식 타입 객체들이 들어있음
			// 어제 우리가 배운 상속이랑 오버라이딩을 생각해보자
			// 메소드를 호출할때 자식객체에 이 메소드가 존재한다면(부모한테도 있고 자식한테도 있다면) 자식의 것이 우선순위가 높다!
			
			/*
			 * 동적바인딩(Dynamic Binding) : 프로그램 "실행 전" 컴파일 시점에 정적바인딩 수행(자료형의 메소드를 가리킴)
			 * 							 실질적으로 참조하고 있는 객체가 해당 메소드를 오버라이딩 했다면
			 * 							 프로그램 "실행 시점"에 동적으로 자식클래스의 오버라이딩된 메소드를 실행
			 * 									(Runtime)
			 * 
			 * 오버로딩 할때 정적바인딩했던이야기 --> 오버로딩과 오버라이딩의 차이는? 을 많이 물어봄 --> 가장 처음 나와야할것은 정적바인딩과 동적바인딩의 차이는? 임
			 * 
			 * 컴파일 시점에 아 부모의 메소드 호출하는구나 --> void com.kh.chap01.model.vo.Parent.print () --> 정적바인딩(오버로딩)
			 * 
			 * 다형성 : 부모클래스 자료형으로 여러 자식클래스를 다루는 기술
			 * 
			 * 동적바인딩을 다형성이라는 개념을 적용해서(부모클래스 자료형으로 여러 자식클래스를 다루는 기술을 사용해서) 여러개(자식12뿐만아니라3도그렇고4도그렇고)
			 * 부모클래스를 상속한다면 부모클래스가 가지고있는 자료형을 사용할 수 있기때문에 전부다 다형성을 적용해서 이렇게 다룰 수 있다.
			 * 
			 */
			
		}
		
	}

}
