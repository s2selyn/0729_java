package com.kh.array;

import java.util.Arrays;
import java.util.Scanner;

public class Array {
	
	// 중요! 별이 40개!
	// Array를 이야기하기전에 해야 할 것이 있음
	// 변수(Variable)
	// 변수란?
	// 메모리(RAM) 공간에 DATA(VALUE)를 저장하는 공간
	
	// 변수의 특징
	// 
	// 1. 고유한 식별자를 가진다.
	// 2. 공간에 새로운 값을 대입해서 사용할 수 있다.
	// 3. 자료형이 정해져있다.
	// 4. 지역변수의 경우 메모리의 Stack영역에 올라간다.
	// 5. **하나의 변수공간에는 하나의 값만 대입될 수 있다.** <-- 배열을 하고싶어서 기다린 답!
	// 6. 초기화를 해야만 사용이 가능하다.
	// 7. 초기화는 한 번만 가능하다.
	// 8. 자료형은 크기가 정해져있다.
	// 9. 자료형끼리의 변환이 가능하다.
	// 10. 선언된 Scope안에서만 사용이 가능하다.
	// 11. 변수끼리 연산도 가능하다.
	// 뭐 많다...!
	
	/*
	 * 배열(Array) : 하나의 배열에 여러 개의 값을 담을 수 있음
	 * 				단, "같은 자료형의 값들"만 담을 수 있음 <-- 제약조건
	 * 				동종 모음(homogeneous collection)이라고도 함
	 * 				하나의 배열은 한가지의 자료형만 담을 수 있음
	 * 
	 * 				자바라는 언어 자체에 내장된 "유일"한 자료구조 <-- 언어 자체에 내장된 것이라는 게 중요함(자바라는 언어에서 중요도가 높은 이유, 컬렉션은 API같은 친구들)
	 * 
	 * 				=> 배열의 각 인덱스에 실제 값이 담김
	 * 				   index는 '0'부터 시작한다.(charAt()메서드에서 잠깐 했었음)
	 * 
	 * 그동안은 하나의 변수에 하나의 값만 대입해서 사용함
	 * 배열의 목적은 변수와 같음, 변수를 담기 위한 공간
	 * 
	 * 자료구조는 값(데이터)을 어떻게 저장할 것인가? 에 대한 이야기
	 * 서점에 가면 구역이 나눠져있고, 특정 내용들에 맞는 책들이 들어있고, 그안에서 순서대로 정렬되어 있음
	 * 책을 찾아내거나, 구하거나, 찾거나, 사거나 할 때 정보를 얻기 쉬움
	 * 컴퓨터도 데이터를 저장해서 관리하고 사용할건데, 이런 값들을 어떤 모양새로 저장할것인가 --> 여러가지 구조를 만들어냄 --> 자료구조라고 함
	 * 
	 * 이것을 이해해야 컬렉션을 이해하고, 객체지향을 이해할 수 있음
	 * 그림을 보고 컴퓨터상에서 일어나는 일들을 이해해야 한다.
	 * 
	 */

	public void method1() {
		
		// System.out.println("법을 잘 지킵시다."); // 모범시민
		
		// 임의의 정수 5개를 선언하고 초기화를 진행해야지! <-- 이런 생각이 들었다
		// 정수값 5개가 필요하겠다 --> 변수 5개 선언하기, 아무거나 넣어보자
		/*

		int num1 = 12;
		int num2 = 13;
		int num3 = 77;
		int num4 = 7;
		int num5 = 4;
		
		// 정수들을 가지고 뭘 하고 싶냐면, 이 친구들의 합계를 보고싶음!
		// 합계 --> sum이 있어야겠네!
		// int sum = 0;
		
		// 그 다음에는? for문 써가지고 sum에다가 더해야지~ 이런 한붓그리기 말고!
		// int sum = num1 + num2 + num3 + num4 + num5;
		// System.out.println(sum);
		// 같은 작업을 5번 반복하고, 변하는 부분이 정수 파트밖에 없네 --> 변하는 부분은 for문의 제어변수로 바꿀 수 있지 않을까?
		// 반복문 배웠으니까
		for(int i = 1; i <= 5; i++) {
			// sum += numi; // <-- num에다가 i를 붙여야지!, 이러면 numi라는 변수를 쓴 것, 문법적으로 말이 안됨
		}
		System.out.println(sum);
		
		*/
		//배열의 장점은 이 상황을 해결할 수 있음
		
		// 배열(궁극적인 목적은 변수와 동일, 값을 저장하기 위한 공간, 자료구조니까 좀 더 효율적으로 값을 저장하자는 것 뿐)
		
		// 변수를 처음 배울 때 뭐부터 했나요? --> 변수 선언, 배열도 마찬가지
		// 1. 배열 선언
		
		/*
		 * 목적 자체가 변수랑 같으니까 변수랑 비교하면서 가보자
		 * 
		 * 변수 선언 방법
		 * 
		 * 자료형 변수식별자; // 변수식별자 = 변수명
		 * 
		 * 배열 선언 방법(두가지)
		 * 
		 * 1) 자료형 배열식별자[]; // [] 없으면 변수랑 같은 형태이므로 구분할 수 없음
		 * 2) 자료형[] 배열식별자; --> 요 방법을 사용할 것!!!!!!!!(다들 2번을 쓰니까~ 주류 방법이니까~)
		 * 기능은 똑같고 문법만 2가지로 지원됨
		 * 
		 */
		
		// 변수 선언!
		// int num; // 정수형의 값을 넣을 공간을 할당받겠다는 뜻
		
		// 배열 선언! 변수 선언과 달라진 점은 대괄호가 붙는다. 문법적으로는 끝!
		// int[] nums; // 똑같이 함, 정수형 배열 공간을 nums로 만들겠다. 복수형으로 지어줌(일반적인 관례)
		
		// 변수는 초기화해서 바로 쓸 수 있음
		// int num = 0;
		// 배열은 아래처럼은 쓸 수 없음
		// int[] nums = 0;
		// type mismatch는 자료형이 다르다는 뜻, int형 배열(nums)에는 int형 리터럴 값(0)을 넣을 수 없음
		
		// 2. 배열 할당(배열을 사용하기 위해서는 크기를 할당해야 함, 할당을 해줘야 사용할 수 있음)
		
		/*
		 * 배열에 몇 개의 값이 들어갈지 배열의 크기를 정해주는 과정 --> "할당한다"라고 표현
		 * 지정한 개수만큼 값이 들어갈 공간이 할당됨
		 * 
		 * [ 표현법 ]
		 * 
		 * int[] numbers; // 배열 선언
		 * numbers = new int[5]// 할당, 선언하고 나서 배열식별자에 대입을 할건데, new가 필요함, 내가 선언한 자료형을 똑같이 한번더 써줌, 대괄호 안에 몇 칸 필요한지 적음 
		 * 
		 * 선언따로 할당따로 할수도 있고, 선언과 동시에 할당할수도 있음
		 * int[] arr = new int[5]; // 선언과 동시에 할당
		 * 
		 * 배열은 참조 자료형이다.(String도 참조 자료형이다. String은 기본 자료형이 아니어서 그냥 값(value)이 들어가는게 아니고 다른 값(주소값)이 들어감)
		 * 오늘은 하루종일 주소값에 대해 알아보는 시간~
		 * 
		 */
		
		// int[] nums = new int[2]; // nums라는 int형 배열을 선언하고, 2칸짜리 배열을 할당받음
		
		// nums라는 정수형 배열을 선언하고 5칸 할당받아보기
		int nums[] = new int[5]; // int형 배열 nums를 선언하고 new 해서 5칸짜리 받아야겠다 <-- 참조 자료형이라고 한다!
		
		// 참조 자료형과 기본 자료형의 가장 큰 차이점
		// 기본 자료형은 크기가 다 정해져있음
		// 지금 배열을 사용하려고 하는데, 배열은 개발자가 사용할 공간이 얼마나 필요한 지 생각해서 사용
		// 개발자가 얼마나 사용할 때 얼마나 사용할지 미리는 모르므로 사용할 때 필요한 만큼의 공간을 받아서 사용함
		// 자바 말고 다른 언어에서는 필요한 만큼 받아서 쓰는 과정을 동적할당이라고 함(자바에서는 그런 표현 안 씀) 
		
		// 값을 담기 위해서 5칸을 만들어놨음. 5칸에 값을 한번 담아보자!
		// 배열은 값을 담을 때 인덱스라는 공간에다가 인덱스라는 개념을 사용해서 값을 대입할 수 있음
		// 3. 배열의 각 인덱스에 값 대입
		/*
		 * [ 표현법 ]
		 * 
		 * 배열식별자[인덱스] = 값;
		 * 배열식별자를 적고 대괄호를 써서 대괄호 안에 인덱스를 적고, 대입 연산자를 이용해서 값을 대입해줌
		 * 
		 */
		
		nums[0] = 15; // 0은 인덱스(순서), 대입연산자를 이용해서 값을 넣어줌
		
		// 5칸을 할당받아서 인덱스가 0번부터 있으니, 인덱스는 4까지 있음(칸수 - 1 하면 마지막 인덱스)
		nums[1] = 33;
		nums[2] = 6;
		nums[3] = 2;
		nums[4] = 66;
		
		// 모범시민은 확인~ --> 출력문
		// 배열의 경우에는 배열식별자를 쓰면 이상한 거 나옴
		// System.out.println(nums);
		
		// 값을 담을때 인덱스를 이용했으니, 출력할때도 인덱스를 이용
		System.out.println(nums[0]);
		System.out.println(nums[1]);
		System.out.println(nums[2]);
		System.out.println(nums[3]);
		System.out.println(nums[4]);
		// 이렇게 하면 값이 들어있는 것을 확인할 수 있음
		
		// 우리가 얻을 수 있는 장점이 뭘까?
		int sum = 0;
		for(int i = 0; i < 5; i++) {
			sum += nums[i];
		}
		System.out.println(sum);
		// 현시점에서 우리가 배열을 사용해서 얻을 수 있는 장점 : 반복문 사용 가능
		// 이제 이게 됨! 아까 변수에서는 돌릴 수 없었던 반복문을 하나의 배열의 인덱스에 각각의 값을 넣어두었기 때문에 반복문을 통해서 합계를 구하거나 출력을 하는 일들이 가능해짐
		
	} // 다 해봤으면 메인 메소드에서 주석처리
	
	// 배열을 사용하면 메모리에서 무슨 일이 일어나는지 확인해보자
	public void methodA() {
		
		// 배열을 공부해보자(이해를 해 보자~ 깨달음을 얻어보자~)
		
		// 1. 배열선언 및 할당
		int i;
		int[] integers = new int[3]; // 3칸짜리, 인덱스는 3개(0, 1, 2), 정수형 배열이다, 정수들을 담을 공간을 하나 받음
		// double[] doubles = new double[2]; // 2칸짜리, 인덱스는 2개(0, 1), 실수형 배열이다, 변수와 달라진 점은 대괄호만 붙이면 끝!
		// char boolean byte long 등등 기본 자료형 8개 다 할 수 있음
		
		// 배열식별자.(참조연산자)를 쓰면 length를 쓸 수 있음
		// 배열식별자.length : 배열의 크기(길이) => 정수(정수 타입으로 반환받을 수 있음)
		System.out.println(integers.length); // 3칸짜리니까 3으로 나옴
		// System.out.println(doubles.length); // 2칸짜리니까 2로 나옴
		
		// 변수와의 비교
		// int i; // int i를 선언했다고 가정 --> 흐름 설명을 위해서 위로 옮겼음
		// int형 변수 i와 같은 경우에는 출력을 해보려면 초기화 해야한다.
		// System.out.println(i); // localvariable == 초기화를 진행하지 않으면 사용할 수 없음
		
		i = 1;
		System.out.println(i);
		
		// 배열은 0번 인덱스가 있을 것이다
		System.out.println(integers); // 배열 출력 --> 이상한 게 나옴
		System.out.println(integers[0]); // 배열의 0번 인덱스 출력 --> 0이라는 정수형 리터럴이 나옴, 분명히 얘도 값을 저장하는 공간인데, 우리는 초기화를 안했는데 값이 들어있음
		
		/*
		 * 기본자료형 : boolean, char, byte, short, int, long, float, double
		 * 				=> 변수 공간에 실제 값을 바로 담을 수 있음 : (지역)변수
		 * 
		 * 지역의 의미 = scope, 중괄호 {}, 지역변수는 내가 선언된 스코프 안에서만 살아남을 수 있음
		 * 
		 * 참조자료형 : boolean[], char[], byte[], int[] ... String
		 * 				=> 주소값을 담고 있는 변수 : 참조 변수(레퍼런스)
		 * 
		 */

		// 기본자료형과 참조자료형의 차이점
		// 그림그리기~ 메인 메소드 갔다오는 건 많이 해봤으니까 methodA 호출부터 이야기하자
		// methodA를 호출하면 컴퓨터상에서 Memory(RAM)에 methodA가 stack 영역에 올라감
		// int i를 만나면 변수 선언하니까 stack 영역의 methodA 영역 안에 4byte 크기의 공간을 할당받고 이름을 i라고 부르기로 함
		// 그 다음 줄(int[] integers = new int[3];)은 대입연산자 왼쪽부터, 왼쪽이니까 공간일거임, 똑같이 변수 공간을 받음, 이름을 integers라고 함(얘도 stack 안의 methodA 영역 안에 생김)
		// 대입연산자 오른쪽은 배열이다! 배열은 사용자가 달라고 하는 만큼 줘야 함, 메모리를 고정해놓고 쓰는 게 아님, 개발자들이 필요한 순간에 비어있는 메모리 공간을 만들어서 개발자들이 프로그램에 넣어줘야 함
		// new int[3]은 stack 영역에 올라가는 것이 아니라 메모리상의 heap이라는 영역에 올라감, 여기는 운영체제(시스템)가 관리하는 영역
		// 운영체제야, 나 지금 프로그램에 12바이트 공간이 필요해, 메모리상에 남는 공간 12바이트만 할당해줘 --> 해서 heap 영역에서 12바이트(int형이니까 4바이트, 3개) 만큼의 크기가 생김
		// heap은 여기저기서 사용하는 운영체제가 관리하는 영역, 다 쓰면 방 뺄거임, 어느 공간이 비어있는지 알 수 없음, 달라고 하면 메모리상에서 빈 부분을 제공해줌
		// 실제 메모리에 데이터가 들어가는 형태는 테이블, 각각의 공간 하나하나에 주소가 적혀있음
		// 여러개의 프로그램이 돌아가고 있으니(메모리를 사용하고 있으니) 메모리 공간이 찼다가 빠졌다가 하고 있음
		// 12바이트를 달라고 한 순간에 남아있는 공간에 올려줌, 배열은 공간을 진짜로 일렬로 12바이트를 메모리 주소상에 할당을 해줌 <-- 배열의 특징 중 하나
		// 어디가 비어있을 지 모르기때문에 어디에 생길 지 알 수 없음
		// 달라고 할 때마다 주소값이 달라짐, 12바이트 할당했을 때 주소가 정해짐, 이 주소를 stack에 선언되어 있는 integers 공간에 대입함
		// i는 int형 기본자료형 4바이트, 값을 입력하면 값 자체가 들어감
		// integers도 결국 변수인데, 변수에는 값이 하나밖에 안들어감, 나는 한번에 여러가지 값을 다루고 싶음, 여러개를 가지고 있는 친구(heap에 생성되어 있는 배열)의 주소값을 대입한 것
		// 여기까지가 기본자료형(값을 담음)과 참조자료형(주소값을 담음)의 차이점
		
		// i = 1; 를 만나면 i의 영역에 1이 대입됨
		// i를 출력해봐라 --> i에 대입된 1이 출력됨
		// integers를 출력해봐라 --> 이상한 게 찍힘 --> integers에는 지금 실제 배열이 생겨난 주소가 들어있음(실제 주소값은 아니고 자바에서 주소를 이런 식으로 표현해서 보여줌)
		// 자바는 주소를 알아도 뭘 할 수 있는 언어가 아님
		// integers[0]을 출력해봐라 --> integers의 0번 인덱스를 찍었음 --> 생겨나면서 공간이 3개로 쪼개져서 생겼음, 공간 앞에 자신의 순서(인덱스)가 붙어있음
		// integers에는 주소가 적혀있음, 그 주소로 이동함, [0]을 찍었으므로 0번 인덱스 안에 있는 값이 출력될것임
		// 우리는 초기화 안했음, 값을 넣은 적이 없음
		// stack 영역에 생긴 공간은 초기화를 하기 전에는 비어있을 수 있음
		// heap 영역에 생긴 공간은 할당받는 순간에 값이 없을 수 없음, 무조건 들어았어야 함 --> int형인 경우에는 기본값이 0으로 대입되어 있음
		
		// 배열의 첫번째 공간에 값을 대입해야겠다면 어떻게 해야할까? --> integers에 대입하는 것은 의미가 없음, 주소가 들어가는 공간이기 때문, 정수형 리터럴을 넣으려고 하면 안됨
		// 값을 integers의 공간이 아니라 배열의 공간, 주소를 먼저 찾아가야 함, integers를 봐야 주소를 알 수 있음
		// integers에 의해 주소에 도달하고, 3칸이 있는데, 몇번째 공간에 넣을건지를 정해줘야 함
		// 주소로 이동해서 첫번째 칸에 대입하고 싶음 --> [0]으로 지정
		// 공간에 값을 대입하는 것은? 대입연산자를 이용 --> 왼쪽의 공간에 오른쪽의 값을 대입
		integers[0] = 1; // integers가 가리키는 주소로 가서 첫번째 칸에 1을 대입할거야
		
		/* 한글 쓰지 마세요!!! 설명을 위해서 작성한 부분
		// 현실세계랑 똑같음
		// 아침에 학원에 출근해야함, 최종 목적지는 A강의장, 여기에 와야 수업을 하든지~
		// A강의장에 가려면 그레이츠 청계의 KH정보교육원 종로지원에 도달해야 함
		// A강의장만 있는게 아니라 인포도 있고 사무실도 있고 A도 있고 B도 있고 C도 있고..
		// 2층에 오면 다양한 공간이 있음
		// 실제로 KH정보교육원 종로지원이 존재하는 물리적인 위치가?
		// 실제로 존재하는 곳은 서울시 중구 남대문로 120, 여기가 실제로 가야 하는 곳
		// 최종 목적지인 A강의장에 가야 하는데, 갈 때는 이름(KH정보교육원 종로지원)을 가지고 감, 이 이름은 주소를 가지고 있음
		// 몇번째에 있는 A강의장을 찾아가느냐 --> 언어에서는 인덱스라는 개념
		// 코드로 바꿔보자
		// 인포, A강의장, B강의장, C강의장, 사무실 --> 다루어야 하는 데이터가 다섯개의 문자열
		// 다섯개의 값을 저장할 수 있는 공간이 필요함, 변수라면 5개를 썼을 것임
		// 동일한 타입의 여러개의 값은 배열을 쓰자, 무슨 타입? String 타입, 선언을 먼저 해야 함
		String[] KH정보교육원종로지원; // 여기까지 동작하면 메모리상에는? methodA는 호출되어 stack 영역에 이미 올라가있음
		// 배열을 선언했으므로 methodA 영역 안에(methodA 스코프 안에서 선언된 변수니까) 공간을 받고 KH정보교육원종로지원으로 이름을 정한 상태
		
		// 우리가 다뤄야 할 데이터가 다섯개, 데이터 담을 공간이 5개 필요함
		KH정보교육원종로지원 = new String[5]; // 5개를 KH정보교육원종로지원에 대입
		// 여기서 일어나는 일 1. 값을 담는 공간 KH정보교육원종로지원
		// 2. heap영역에 new String[5]가 생성됨(String 다섯개를 담을 수 있는 5칸짜리 공간이 생겨남) --> 생기면 주소가 붙음(남대문로120, 원래는 주소가 다 있고 공간이 생겨난 그 주소), 대입연산자 기준 왼쪽임, 오른쪽은 항상 값임
		// 3. 왼쪽의 공간에 오른쪽의 값을 담는데, 5칸이 들어갈 수는 없음, 도대체 무슨 값이 대입되느냐? --> stack에 있는 변수 공간에 남대문로 120이 대입됨
		// 어디에 생겼든지 관심이 없지만 써야하니까 주소를 담아둠
		System.out.println("종로점 주소 : " + KH정보교육원종로지원);
		// 변수를 출력하면 대입된 value 값이 나옴
		// 자바에서는 실제 주소값을 알 수 없음(일반 문자열임)
		
		// 우리는 여기에 5개의 문자열 값을 담고싶음
		// 문자열 값을 담고싶은 공간은 heap에 있음, 학생들마다 선생님과 heap에 생긴 주소가 다 다름
		// 내가 주소를 찾아가는 방법은 변수명 --> KH정보교육원종로지원
		// 첫번째 칸에 인포를 넣어야겠다면? --> 일단 집에서 인포에 가려면 남대문로120까지는 가야 함
		// 집에서 남대문로120까지 가능 방법은? --> 주소값은 변수에 들어있음, KH정보교육원종로지원 이라고 쓰면 남대문로120을 찾아서 heap까지 간 것, 갔더니 각각의 방에 순서를 붙여뒀음(0, 1, 2, 3, 4)
		// 첫번째 공간에 가야겠다 --> [0], 여기까지 하면 첫번째 공간까지 도달했음
		// 여기에 인포를 저장하고 싶다면? 대입연산자를 쓰고, 오른쪽에는 대입하고 싶은 값을 담음
		KH정보교육원종로지원[0] = "인포";
		// 두번째 공간에는 A강의장을 넣고싶다 --> 일단 종로지원 가야함, 변수명을 부르면 남대문로120에 도달함 --> 두번째 방은 1번 인덱스 [1] --> 값을 대입해야겠다 --> 대입연산자
		KH정보교육원종로지원[1] = "A강의장";
		// 세번째 방 가야겠다, 남대문로120 가야지 --> 변수 보고 갈 수 있음, 변수에 주소를 담아놨으니까
		KH정보교육원종로지원[2] = "B강의장";
		// 나머지들도 마찬가지
		KH정보교육원종로지원[3] = "C강의장";
		KH정보교육원종로지원[4] = "사무실";
		
		// 클래스 캡슐화 하고 String 설명 예정
		
		// 값을 담았으니 출력도 해보고 이것저것 해보고싶음
		
		// C강의장 출력
		// 어떻게 저기까지 찾아가야 할까?
		// 일단 출력문은 확정
		// System.out.println(KH정보교육원종로지원[3]);
		// 먼저 배열 남대문로120을 가야함, 얘는 변수에 담아뒀음 --> KH정보교육원종로지원
		// 우리는 C강의장을 보고싶음 --> 네번째칸까지 가야 원하는 것이 있음
		// 4번째 방을 출력하려면? 4번째 - 1 해서 3번 인덱스를 출력
		
		// 공간에 들어있는 5개 다 출력해보고싶다면
		System.out.println(KH정보교육원종로지원[0]);
		System.out.println(KH정보교육원종로지원[1]);
		System.out.println(KH정보교육원종로지원[2]);
		System.out.println(KH정보교육원종로지원[3]);
		System.out.println(KH정보교육원종로지원[4]);
		// 이러면 다섯개의 value 값이 다 나오겠지
		// 이렇게 보니 01234 빼고 다 중복임 --> 인덱스 부분 빼고 중복 --> 얘를 뭘로 바꿀 수 있나요? --> 반복문
		
		System.out.println("----- 반복문 -----");
		
		// 인덱스에 접근해야 하니까 제어변수를 0으로 초기화 한 것(보통)
		for(int index = 0; index < 5; index++) {
			System.out.println(KH정보교육원종로지원[index]);
		}
		*/
		
		// 메모리는 크게 네개로 쪼갤 수 있음(stack, heap, 나머지 2개)
		// heap도 20개로 쪼갤 수 있음, 자바는 메모리 공부하기 좋은 언어가 아님
		// 그래도 무슨 일이 일어나는지 정도는 알아야 함
		// 우리의 일은 메모리에 값을 저장하고 출력하는 것, 코드는 이걸 위한 방법일 뿐
		
		// 실제 메모리는 일렬이라고 생각, stack은 밑에서부터, heap은 위에서부터 차곡차곡 쌓임
		// heap 메모리는 엄~청 중요한 영역, 요새는 잘 안보이는 것 같은데... 블루스크린
		// 블루스크린 뜨는 대부분의 이슈가 heap이 터진 것, 메모리가 꽉 차서 heap에 올라갈 공간이 없어서 펑!
		// heap이 터진 상황 --> heap은 RAM에 있음, 휘발성이므로 껐다켜면 싹 없어짐 --> 블루스크린 해결!
		// 요새는 RAM이 빵빵하니 보기 힘든데 개발하다보면 볼..수..도......
		// 대부분의 경우 컴퓨터에 문제가 생기면 80%는 껐다 켜면(재부팅하면) 해결된대 ㅋㅋ 원인은 메모리 부족
		// 껐다 켜면 메모리가 싹 비워지니까
		
		// 배열을 이해해야 자바의 벡터, 리스트, 셋 이런 것들을 이해할 수 있음
		
		int number1 = 3;
		int number2 = 3;
		System.out.println(number1 == number2);
		// 앞에서 이렇게 많이 했음~ 변수와 자료형 배우고 비교연산도 해보고~
		// int와 int의 비교 연산이었다
		// 이건 true가 나옴
		
		int[] numbers1 = new int[3];
		int[] numbers2 = new int[3];
		System.out.println(numbers1 == numbers2);
		// int형 배열과 int형 배열의 비교를 해 보자!
		// 이건 false가 나옴

		// 참조 자료형이라는 친구가 있구나~ 를 배웠다!
		// methodA를 부르면 stack 메모리에 올리겠다는 뜻 --> stack 영역에 methodA의 영역이 생김
		// int형은 기본자료형, 변수 공간 안에 있는 3과 3을 비교하게 됨
		// int형 배열은 일단 앞만 보면 공간 2개를 만들었음(변수 선언), 이름도 붙여뒀음
		// 오른쪽의 값은? new int[3];을 하면 무슨 일이 일어나나요 --> heap에서 12바이트(4바이트 * 3) 할당해버림!
		// 12바이트짜리는 int형 배열의 변수에 담을 수 없음, 주소값을 담음
		// 주소가 같니? 라고 비교를 함, 다른 공간에 생겼으므로 주소는 다름 --> false
		
		// 참조자료형에서는 ==(동등비교 연산자) 사용 시
		// 주소값을 비교하기 때문에 원하는 결과를 얻을 수 없음
		// 우리가 가장 많이 사용하는 참조자료형? String
		// 문자열 == 문자열 // 여기의 몬자열에는 사실 주소가 들어있음
		// value 값을 비교하는 기능을 호출해야 함 --> equals()
		// 문자열.equals("비교할 문자열");
		
		// System.out.println(numbers1); // 이 결과는 사실 다른 메서드 호출의 반환값임
		// 주소 찍을 때 호출할 메소드를 하나 지정 --> hashCode()
		// 해시코드 : 주소값을 10진수(int형태)형태로 나타낸 것
		System.out.println(numbers1.hashCode());
		System.out.println(numbers2.hashCode());
		// Hash(해시)는 암호화의 한 종류, 해싱 알고리즘을 통해서 10진수값을 받아옴
		// 자바의 경우에는 해싱 알고리즘을 자바로 만들어서 돌리는 게 아니라 Native 메소드라고 해서 시스템 상(운영체제에 내장)에 있는 외부 함수를 호출해서 사용
		// C언어로 만든 것을 돌리는 것 --> String 클래스 공부할 때 hashCode() 자세히 설명
		
	} // 해봤으면 메인 메소드에서 주석처리
	
	// 배열을 배웠으니 로또 버전 2로 올리자~
	public void lotto() {
		
		// 로또번호생성기 ver_0.2
		// 이전에는 int형 변수 여섯개를 선언해서 값을 담았음
		// 이제 뭐 쓰면 돼요? 배열
		// 무슨 형 배열? int형 배열
		// 몇 칸 짜리? 6칸짜리
		// 이번에는 int형 배열을 선언하고 6칸을 할당해보세요
		int[] lottoNumbers = new int[6]; // 0, 1, 2, 3, 4, 5(6칸이니까 인덱스가 0부터 5까지)
		
		// 1부터 45까지의 랜덤한 값을 넣어야겠따
		// 0번 인덱스에 랜덤한 값을 담아야겠다면 --> 찾아가야 함(lottoNumbers) --> 몇번째칸?(인덱스 찾아가기, [0]) --> 값을 대입해줘야함(대입연산자) --> 랜덤한 값은 오전에 했던 거 그대로
		/*
		lottoNumbers[0] = (int)(Math.random() * 45) + 1;
		lottoNumbers[1] = (int)(Math.random() * 45) + 1;
		lottoNumbers[2] = (int)(Math.random() * 45) + 1;
		lottoNumbers[3] = (int)(Math.random() * 45) + 1;
		lottoNumbers[4] = (int)(Math.random() * 45) + 1;
		lottoNumbers[5] = (int)(Math.random() * 45) + 1;
		*/
		// 쓰고나니까 어떤가요...? 반복되는 부분이 있음, 인덱스만 바뀌고 있음
		// 중복을 제거하는 방법 1. 중복되는 부분을 하나로 뺀다.
		// 2. 중복되지 않는 부분은 변수로 처리한다. --> 값이 들어가는 공간이니까
		for(int i = 0; i < 6; i++) {
			lottoNumbers[i] = (int)(Math.random() * 45) + 1;
		} // 이렇게 하면 중복되는 부분은 하나로 빼고, 중복되지 않는 부분은 변수로 처리할 수 있음
		
		// 보편적으로 공부를 할 때, 나중에 감이 생기면 바로 for문을 쓸 수 있음
		// 감이라는 것은 뭐야? 감이 생기려면 어떻게 해야 해? --> 어? 이거 이렇게 하면 되겠네? 라는게 감
		// 감 == 내 머릿속의 빅데이터, 경험들이 쌓이면 경험에 의해서 일어나는 현상
		// 경험이 많이 생겨서 감이 잡히기 전까지는 풀어서 해보아야 함, 반복이니까 for 써야지 하고 문법에 집착하면 문법괴물~
		// 내가 하고 싶은 로직을 최대한 코드로 풀어서 작성하면 반복되는 부분과 반복되지 않는 부분을 한 눈에 볼 수 있음
		// 그 이후에 반복문을 쓰면 됨
		
		// 배열에 들어간 값들을 배열의 요소(Elements)라고 함, 보통 E라고 써져있으면 요소를 의미한다고 받아들이면 됨
		
		// 로또 번호 생성기니까 출력을 해줘야함
		// System.out.println(lottoNumbers); // 이걸 그냥 출력하면 주소가 나옴
		// 이 친구를 또다른 메소드의 인자값으로 전달할것임
		// Arrays.toString(배열식별자)
		System.out.println(Arrays.toString(lottoNumbers)); // Arrays는 외부 클래스, toString은 외부 클래스에 있는 메소드라서 import하면 됨

	} // 중복 제거는 나중에 버전업하자! 해봤으면 메인 메소드에서 주석처리
	// 오전보다 진화됐다! 변수 6개 쓰는 것에서 발전해서 배열 써서 한번에 했음~
	
	public void methodB() {
		
		// 5개의 요소를 담을 수 있는 String형 배열을 선언 및 할당하시오.
		// 동물 5총사
		
		// 1. 배열 선언 및 할당
		String[] animals = new String[5];
		
		// 2. 배열 인덱스에 동물 대입!
		animals[0] = "고양이";
		animals[1] = "사자";
		animals[2] = "강아지";
		animals[3] = "소";
		animals[4] = "돼지"; // 5칸짜리 만들고 각각의 인덱스에 예쁘게 넣었음
		// animals[5] = "토끼"; <-- 문법적으로는 문제가 없음
		// 사람이 하는 일이라서 일어날 수 있는 일, 5칸이니까 인덱스는 0, 1, 2, 3, 4로 되어있을것임, 사람이 하는 일이니까 5번 인덱스에 토끼? 충분히 할 수 있는 실수
		// 여기까지 하고 실행하면 에러남
		/*
		Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5
		at com.kh.array.Array.methodB(Array.java:444)
		at com.kh.array.Run.main(Run.java:14)
		*/ // 얘가 이번 파트 주인공임! Console 창에 뜬 이걸 Stack Trace라고 부름, stack을 추적해서 화면상에 보여줌
		// Exception을 배우려면 2주 정도 남음, 아직 안배웠음, 그래도 이걸 모르면 앞으로 나아갈 수 없음
		
		// methodB를 호출했더니
		// ArrayIndexOutOfBounds 라고 뜸, ArrayIndex가 OutOfBounds, 너 Bounds를, 범위를 out of 했다, 넘어갔다는것(OOB)
		// Exception을 안배웠으니 얘만 보자. --> 배열의 인덱스가 범위를 벗어남
		// 우리가 쓰면서도 얘기했음, 인덱스 4번까지밖에 없는데 5번에다가 넣네? 이러고 있었음
		// 친절하게 뭐까지 알려주느냐...
		// at com.kh.array.Array.methodB(Array.java:444) <-- 여기 문제인 것 같은데? 여기에서 ArrayIndex가 OutOfBounds 된 것 같은데? 라고 알려줌
		
		// stack은 메모리의 영역중의 한 공간, stack에 올라갈때는(프링글스통같은친구) 밑에서부터 쌓이므로 실제로도 메소드가 호출되면 메모리가 아래부터 쌓여올라감
		// 프로그램을 시작(실행)하면 메인 메소드로 감
		// at com.kh.array.Run.main(Run.java:14) <-- 메인 메소드의 14행을 의미함, methodB를 부른 곳
		// 메인 메소드가 메모리의 stack 영역에 먼저 올라가있는 상태, 밑에 깔려있음
		// 메인 메소드가 차지하고 있는 메모리 위에 호출된 methodB가 올라감
		// at com.kh.array.Array.methodB(Array.java:444) <-- methodB의 444행을 의미함, animals[5] = "토끼";을 입력한 곳
		// Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5 <-- Array index가 범위를 벗어났어
		// 니가 index를 5라고 적었어 --> 근데 이건 out of bound야 length가 5거든~ 이라고 적혀있음
		
		// stack 영역에 메인 메소드 영역이 아래쪽에 생기고 그 위에 methodB의 공간이 생김
		// methodB의 공간 안에 animals를 선언해서 공간을 만들었음
		// heap 에다가 다섯칸을 만들었음 --> 주소가 생김(동물의집) --> 동물의집은 animals에 대입될겄임
		// 동물의집에서 다섯칸이니까 인덱스가 생겼을것임 --> 0, 1, 2, 3, 4
		// 동물의집에 index에 접근해서 각각 값을 넣었음(각각 동물을 넣었음)
		// animals[5] = "토끼"; 이 부분을 만남, animals에 가래, animals는 heap에 있는 동물의집까지 감, [5](5번 인덱스)에 가라고 함, 인덱스가 ㅏ4번까지밖에 없음, 없는 곳에 대입하려고 함
		// 니가 적은 인덱스는 이 배열에 없어, 범위를 벗어난거야~ 하고 알려줌 --> 예외 발생
		
		// 여태까지 수업시간에 한 것으로만 따지면 선생님이 의도적으로 보여주지 않은 부분도 있고
		// 동작시켰을 때 문제가 발생한 것은 Arithmetic exception 이후로 처음
		// 의도적으로 일부러 문제 생기는 것은 안보여주셨음, 아직 문제 해결하는 것을 안배워서
		// 해결할 수 있는 방법을 안배워서 문제를 안 일으키는 코드만 가지고 했음
		// Arithmetic exception과 지금 이 exception의 공통점이 있음
		// 대부분 지금 단계에서 보는 문제점들은 오타, 문법처럼 프로그램을 돌리기 전부터 빨간줄 생기는 것들 --> 조금만 신경쓰면 생각할 수 있는 부분(혼자해도), 수업시간에는 놓칠 수도 있지
		// animals[5] = "토끼"; <-- 이건 실행하기 전에 빨간색이 안나옴
		// 문법이 잘못되어서 못돌리는 것은 얘가 알려줌, 근데 이부분은 문법적으로는 아무런 문제가 없음. 배열이 5칸 생기는 것은 실제로 heap 영역에 와야 생김, 실행하기 전까지는 5칸인지 10칸인지 컴퓨터는 알 방법이 없음, 돌려봐야 알 수 있음
		// 이런 문제가 생겼을 때 스스로 해결하기 위해서는 항상 생각을 해야 함
		
		// 코드 칠 때 항상 생각하고 쳐야 함, 코드는 아무 생각없이 치면 안됨, 아무 생각 없이 칠 수 있는 것은 세미콜론뿐, 어 조건이다 --> if
		// 바이브코딩? 느낌대로 작성하기(생각 안하고 짜기) --> 이것의 부작용은 사람이 건들 수 없는 코드가 됨(기술부채) --> 코드가 빚이 됨
		// 어디서 가져온 코드는 일단 작동을 함 --> 이게 그대로 갈 수는 없음, 확장하고 수정하고, 비슷한 것을 뽑아내고 해야하는데 모르니까 건들수가 없음
		// 항상 메모리 그림을 생각하고 코드짜기, 머릿속에 그림 그리기
		
		// 생각 안해도 괜찮은것(무지성으로 해도 되는 거 세 개 뇌 빼도 됨)
		// 1. ;(세미콜론)
		// 2. 어? 조건이다 if문 작성
		// 3. 어? 합계다 sum 변수 선언
		
	} // 해봤으면 메인 메소드에서 주석처리
	
	public void methodC() {
		
		// 사용자에게 세 개의 정수를 입력받아서 입력받은 정수 중 최소값 구하기
		// 자바에는 최소값 구하는 메소드가 있지만 그거 안 쓰고 배열 배운 김에 직접 해보자!
		// 이런 경우가 완벽하게 배열을 사용해야겠다고 생각하는 경우
		
		// 현 시점에서 배열을 선택할 때의 기준
		// 1. 두 개 이상의 같은 자료형의 값을 다룰 것
		// 2. 다룰 값의 개수가 명확하게 정해져 있을 것(배열을 사용하려면 선언하고 할당해야 함, 할당할때 뭘 쓰나요? 사용할 공간을 씀)
		// 배열은 이론적으로, 개념이 중요하고 활용도가 중요하지는 않음, 갯수가 명확하게 정해져 있어야 하기 때문에 효용성은 높지 않음
		
		// 1) 사용자로부터 값을 입력받아서 배열의 각 인덱스에 대입(정수값)
		// 일단 입력받아야 하니까 입력 도구가 있어야겠지? 스캐너 확정
		Scanner sc = new Scanner(System.in); // 입력도구
		int[] nums = new int[3]; // 저장소, 값을 저장해둘 저장소 선언, 배열은 사실 변수의 나열
		
		// 배열의 특징이 무엇인가?
		// 배열은 물리적인 구조와 논리적인 구조가 동일합니다.
		// 물리적인 구조 : 실제 메모리에 올라가는 것, 물리적으로 메모리에 나열돼서 저장함
		// 논리적인 구조 : 논리적으로 갈 때도 0, 1, 2, ... 순서대로 접근함
		
		/*
		// 입력도구도 만들고 저장소도 만들었으니 출력해야 함
		System.out.print("첫 번째 정수를 입력해주세요 > "); // 세 개 받을거니까 세 번 반복해야 함
		// 입력받기
		nums[0] = sc.nextInt(); // 대입 연산자 오른쪽은 값, 왼쪽의 공간(nums의 0번째 인덱스)에 대입
		// 모범시민
		System.out.println("nums라는 배열의 0번째 인덱스에 대입된 값 : " + nums[0]);
		
		// 두번째, 세번째 인덱스에도 담아보자
		System.out.print("두 번째 정수를 입력해주세요 > ");
		nums[1] = sc.nextInt();
		System.out.println("nums라는 배열의 1번째 인덱스에 대입된 값 : " + nums[1]);
		
		System.out.print("세 번째 정수를 입력해주세요 > ");
		nums[2] = sc.nextInt();
		System.out.println("nums라는 배열의 2번째 인덱스에 대입된 값 : " + nums[2]);
		*/
		// 넣고보니 참을수없는 코드가 만들어지고 말았다!
		// 이런거 참으면 큰일남!
		// 잘 돌아가는지 확인하고 못참겠다 --> 변신!
		
		// 중복된 부분은 하나로 빼고, 중복 안 된 부분은 변수로 처리하고
		// index 부분이 중복 안 된 부분이고 나머지는 중복된 부분
		// 아~ 반복해야겠다, 횟수가 명확함 --> for문
		for(int i = 0; i < nums.length; i++) {
			
			System.out.print("정수를 입력하세요 > ");
			nums[i] = sc.nextInt(); // 중복되는 부분은 변수로 처리
			System.out.println("nums라는 배열의 " + i + "번째 인덱스 값 : " + nums[i]);
			
		}
		// 배열에 할당되는 크기가 바뀔 수도 있음, 선언한 배열의 크기가 바뀌면 당연히 for문의 조건문 숫자도 바뀌어야 함 --> 확장성이 안좋은것같다
		// 조건문의 숫자를 확장성이 좋게 바꾸고싶음 --> 저 위에서 배열식별자.length 썼음 --> 배열의 길이를 정수로 반환해줌
		// 반복할때도 정수형 리터럴로 적는 것 보다 length를 사용하면 배열에 할당되는 크기가 바뀌더라도 for문의 조건문은 수정하지 않아도 됨
		// 3보다 작으면, 5보다 작으면 이런 것 보다 의미론적으로 배열(nums)의 길이보다 작다면 반복하는 반복문 이라는 의미가 됨
		// 확장성도 좋아지고 코드 보기도 편해짐
		
		// for문 끝나면 아까 배운거 출력해보기
		System.out.println(Arrays.toString(nums));
		
		// 최종 목적이 뭐였냐면
		// 2. 해당 배열의 요소 중 가장 작은값 == 최소값을 출력하는것이 목적
		// 우리는 경험으로, 머릿속으로 알고 있는 숫자의 비교를 통해 가장 작은 숫자를 결론으로 도출함, 우리는 한번에 보면 알 수 있음
		// 컴퓨터한테도 니가 한번에 보면 알수있지? 요럴 순 없지(메소드 호출하면 끝이긴 하지만 직접 하기로 했으니까)
		int min = nums[0]; // 나중에 최소값을 출력해야 하니까 최소값을 저장할 변수를 하나 선언
		// 0으로 초기화해두면 문제가 생길 수 있음
		// 배열의 첫번째 요소를 기준점으로 대입해두기
		// 이제 두번째 요소랑 비교해봐야지
		// 만약에 두번째 요소가 더 작다면 최소값 담아두는 변수에 두번째 요소를 대입해줘야함
		/*
		if(min > nums[1]) { // 만약에 첫번째 요소가 두번째 요소보다 크잖아?
			min = nums[1]; // 그럼 두번째 요소를 min에 대입할게
		} // 이 다음에는? 세번째 요소랑도 비교를 해줘야함
		
		if(min > nums[2]) { // 만약에 min에 첫번째 요소랑 두번째 요소중에 작은 게 들어있는데, 그게 세번째 요소보다 크잖아?
			min = nums[2]; // 그럼 세번째 요소를 대입할게
		}
		// 이렇게 해놓고 보니까 참을 수 없음
		// 중복 제거하는 방법 1. 중복되는 부분은 한번만, 2. 중복 안되는 부분은 변수로
		*/
		
		for(int i = 1; i < nums.length; i++ ) {
			
			if(min > nums[i]) {
				min = nums[i];
			}
			
		} // 여기까지 해두면 배열 갯수를 바꿔도 잘 돌아감
		// 지금은 첫번째 바퀴에 0번째 요소를 대입해두었기 때문에 곧바로 두번째 요소와 비교를 하면 됨
		// 초기값이 0이라면, 이미 대입되어 있는 첫번째 요소와 if문에서 만나게 되는 첫번째 요소를 비교함 --> 이 과정은 필요없음
		// 그러므로 i의 초기값을 0이 아니라 1로 줘야함
		
		System.out.println("배열의 요소 중 가장 작은 값 : " + min);
		
	} // 해봤으면 메인 메소드에서 주석처리
	
	public void methodD() {
		
		/*
		 * 한 번 할당받은 배열의 크기를 변경할 수 없음!
		 * 배열은 메모리상에 변수를 일렬로 붙여놓은 것이므로 값을 대입하는 것은 자유롭게 할 수 있음
		 * 
		 */
		
		String[] name = new String[3];
		
		name[0] = "채";
		name[1] = "정";
		name[2] = "민";
		System.out.println(Arrays.toString(name));
		
		name[2] = "옥"; // 요소값을 바꾸고 싶으면 값을 바꿔서 다시 대입해서 쓸 수 있음
		System.out.println(Arrays.toString(name));
		System.out.println(name.hashCode()); // 주소 뭔데?
		
		// 바뀌지 않는 것 두가지 1. 타입 2. 크기
		// 3칸짜리를 2칸짜리나 4칸짜리로 바꾸려면?
		// promotion도 작은 것에서 큰 것으로 가는 건 문제가 없었으니까 큰 걸로 해보자
		// 요소를 바꾸는 건 문제가 없었는데? 크기를 바꿔보자
		name = new String[4];
		name[3] = "굿";
		System.out.println(Arrays.toString(name));
		System.out.println(name.hashCode()); // 주소 뭔데?
		// 두 개의 hashCode 수행 결과가 다름
		// 기본적으로 해싱알고리즘은 전제가 있음 --> hash 값이 중복될 수 있다는 것인 듯...
		// 원래 value값이 5인데 무슨 일이 일어났더니 어쩌고저쩌고한 값이 나옴 --> 기존값도 알고 결과값도 알지만 중간과정을 유추하기가 힘듦 --> 암호화의 한 종류
		// 해싱 알고리즘의 특징은 똑같은 값을 가지고 해싱을 돌리면 항상 결과도 똑같이 나옴
		// 같은 주소를 갖고 있었다면 해시코드도 같은 값이 나왔어야 함
		// 함정 있음! --> 수학익힘책 생각 --> 비둘기집의 원리???(이산수학인데요...)
		// 비둘기 10마리, 비둘기집 10개라면 한집에 한마리씩 들어가면 됨
		// 비둘기 11마리, 비둘기집 10개라면 한집에는 반드시 두마리가 들어가게 됨
		// 이게 해시에 반영이 됨
		// 해시코드 메소드의 값은 int형, 정수값이고, int가 표현할 수 있는 값의 범위가 43억개 정도 됨
		// 이 범위(약 43억개)에 포함되는 친구였다면 중복없이 나올것임
		// 만약에 표현할 수 있는 해시를 다 썼는데 새로운 친구를 나타내려면 중복될 수 밖에 없음 --> 해시 충돌이 일어남
		// 지금 상황에서는 일어날 수 없는 일이지만, 실제 개발하는 상황에서는 일어날 수 있는 일
		
		// 어쨌든 해시값이 다르면 두개는 다른 것 --> 참
		// 해시값이 같다고 해서 두개가 같은 것이라는 보장은 없다 --> 참
		// 해시값이 같으면 두개는 같은 것 --> 해시충돌이 일어나지 않는다는 가정하에는 참, 해시충돌을 생각한다면 참은 아님
	
		// stack과 heap 그림 그리기~
		// stack에서 methodD영역이 생김
		// String[] name = new String[3]; 여기에서 name 변수 선언하고 처음에 3칸짜리를 할당받음 <-- heap에 생김, 주소를 임의로 aaa라고 하자
		// name 변수에는 aaa가 대입되어 있고, aaa는 처음 만든 aaa를 가리키고 있음
		
		// name = new String[4]; 여기에서 네칸짜리를 새로 만들었음, 주소를 bbb라고 하자
		// name에 bbb를 대입함, name과 bbb는 heap 영역의 네칸짜리 bbb를 가리키고 있음
		// aaa는 누가 가리키고 있음? 가리키고 있는 애가 없음 --> 어떻게됨? 그대로 heap에 계속 남아있으면? --> 블루스크린행~ heap이 금방 찰 것임 --> 얘는 heap 영역에서 사라져야 함
		// stack은 메소드 영역이라 메소드가 호출되면 올라갔다가 메소드가 끝나면 방을 뺌
		// heap에 있는 것은 우리가 직접 관리하는 영역이 아님 --> 누가 없애줌?
	
		// 자바는 프로그래밍 언어의 한가지 종류임
		// 프로그래밍 언어를 세대로 구분할 수 있음
		// 1세대(가장 초창기의 프로그래밍 언어) 기계어, 머신 랭귀지--> 컴퓨터가 직접 해석할 수 있는 2진수를 적음
		// 천공카드라는 것을 썼음, 구멍을 뚫어서 프로그래밍, 이걸로 하면 잘못했을 때 다시 구멍 뚫어야 함
		// 2세대 언어는 어셈블리어, 기계어를 그나마 사람이 볼 수 있는 형태로 추상화, 아직도 대학교에서 가르치기도 함
		// MOV 옮겨라, AL 대입해라 등 단순한 축약어를 통해서 컴퓨터를 조작할 수 있도록 함
		// 아직도 low level 개발에서는 사용하기도 함
		// 3세대 언어 : 현시대 주류언어(고급언어라고 표현, high level language)
		// 인간이 이해하기 쉬운 문법들이 만들어짐, 인간의 언어로 씀, C, C+, C++, 파이썬, 자바, 자바스크립트 등
		// 자바도 3세대 언어
		// 기본적으로 거의 대부분의 많은 개발자들이 3세대 언어를 주류 언어로 사용하고 있음
		// 4세대 언어 MATLAB, R, 분야특화 언어들, 5세대 언어 인공지능언어, 6세대 언어 라고도 함
		// 프로그래밍 언어는 컴퓨터라는 기계를 조작하기 위해서 사용하는 것(형태가 어떻든)
		// 솔직히 1세대, 2세대는 3세대보다 쉬움, 전부다 암기로 해결이 됨, 내가 어떻게 하면 기계가 어떻게 동작하는지만 알면 끝남
		// 3세대가 되면서 프로그램 패러다임이 생겨나고 바뀌고, 추상화된 개념들이 떠오르고, 이해해야하고, 의도를 파악해야 하는 것들이 생겨남 --> 머리아파~
		
		// 자바(1995) 이전에는 주류 언어가 C언어였음(지금도 C는 주류긴함)
		// C언어는 컴퓨터를 조작할 때
		// (컴퓨터는 개념이고 실제로는 안에 들어가는 부품들이 많음, CPU도 있고 RAM도 있고) 부품들을 돌리는 데 필요한 시스템이 있어야 함
		// 집에서 사용하는 가전제품도 컴퓨터 부품들이 내장되어 있어서 연산하고 띄워주는 작업들이 이루어지고 있음 --> 타이머, 멈추기, 작동하기 가능
		// 특히 가전제품과 같은 것들을 돌릴 때 원래는 컴파일이라는 작업을 하드웨어나 운영체제에 따라서 다 따로 해줘야함
		// 냉장고용 프로그램을 만들었는데 LG용이나 삼성용이나, 거기서 또 LG안의 여러 냉장고 종류에 따라 다 따로 컴파일을 해야함
		// 너무 귀찮으니 한 번 해서 다 돌릴 수 있는 언어를 만들어보자 --> 이래서 자버지가 처음 만든 것이 OAK라는 언어 --> 망함, 속도가 너무 느려서
		// 인터넷의 발전으로 자바라는 언어가 각광받기 시작, 인터넷도 운영체제에 상관이 없이 잘 돌기만 하면 됨, 애초부터 웹에 특화됨
		// 자바의 가장 큰 특징 : 하드웨어나 운영체제에 종속되지 않는다
		// 어떻게 만들었길래 컴파일을 한번만 해도 돌아갈까? 왜 운영체제에 종속되지 않을까?
		// 원래는 컴퓨터를 돌릴 때 하드웨어, 시스템, 애플리케이션 레이어(계층)가 3개, 이 계층에 따라 바꿔줬어야 함
		// 자바는 애플리케이션 영역에 레이어를 하나 더 만들어줌 --> 가상의 컴퓨터(자바로 만든 프로그램은 실제 동작을 시킬 때 여기서 동작하게 함)
		// 가상의 컴퓨터는 영어로 Virtual Computer --> JVM이라고 부름
		// 자바 프로그램들은 전부 JVM 위에서 동작을 함
		// 이상함.. 왜 이상함? 프로그램 시작 하면 메인 메소드에 진입함
		// 메인도 메소드잖아? 메소드가 동작하라면 어떻게 돼야 함? 메소드의 코드가 실행되려면? 누군가 메소드를 호출해야 실행됨
		// 도대체 메인 메소드는 누가 부름? 누가 메인 메소드를 호출해야 함? --> JVM이 메인 메소드를 호출해서 동작시킴
		// 운영체제마다 맞게 JVM을 만들어둠, JVM 자체는 운영체제에 종속됨
		// 자바는 어차피 JVM 위에서 돌리기 때문에 컴파일 한번으로 모든 환경에서 동일하게 실행 가능함 --> 자바의 장점
	
		// stack에 methodD가 있는 곳에 공간을 차지하고 있는 name이 aaa를 가리키고 있다가 bbb를 가리키는 것으로 바꿨음(aaa주소를 가지고 있었는데 bbb주소를 가지게 했음)
		// 원래 가리키고 있던 것(참조하고 있던 것)은 aaa --> 참조는 영어로 reference
		// 원래는 Reference Count(RC)가 몇개?(나를 가리키고 있는 것이 몇개인가) --> 1 (name 하나가 aaa를 가리키고 있었음) 계속 유지되는 상태 
		// bbb를 담게 되면? bbb의 RC가 1이 되고, aaa의 RC는 0이 됨 --> aaa는 가리키고 있는 애가 없으므로 heap 영역에 둥둥 떠다니면서 남아있음 --> 남아있으면 분명히 메모리 부족의 문제가 생길것임
		// 자바 안에는 JVM 안에 garbage collector(GC)가 포함되어 있음 --> RC가 0인(아무도 가리키고 있지 않은), 메모리 관점에서는 쓰레기 --> GC가 가져가서 메모리에서 삭제시킴
		// 자바라는 언어의 특성 중 하나인 자동 메모리 관리 <-- 이렇게 표현함, 자바의 특징 중 하나
		// 원래라면 개발자가 필요한 만큼 가져다가(동적 할당) 쓰고 나서 개발자가 반납하는 것이 개발자의 일임
		// 필요한 때 필요한 만큼 가져다 쓰고 원래 내가 돌려줘야 함
		// 자바라는 언어는 필요한 만큼 가져다 쓰고, 돌려주는 것은 GC가 알아서 해줌
		// 개발자가 메모리 관리에 대해서 조금 덜 생각할 수 있음 <-- 자바가 주류 언어로 성장하게 된 이유이기도 함
		// 아 메모리 관리 해야하는데 --> 자바는 알아서 해준대 --> 자바 써야지~
		// 이게 하염없이 좋은 건 아님 --> 메모리상의 떠다니는 많은 쓰레기들은 GC가 와야 없어지는데, 언제 GC가 올 지 아무도 모름 --> GC가 알아서 하므로 건드릴 수 없는 상황
		// 필요없을때마다 바로바로 없애면 좋은데 조작을 할 수 없기 때문에 어려운 개발, 규모가 큰 개발, 트래픽이 많은 개발을 할수록 GC가 단점이 될 수도 있음
		// GC도 결국 프로그램임, 잘못 동작하면 메모리가 쌓여서 펑!
		// 처음 시작하는 초기단계의 개발자들에게는 너무나 큰 장점
		// 기술이라는 것은 항상 양단이 있다~ 뭐든지 좋기만 한 것은 세상에 존재하지 않아
	
		/*
		 * 연결이 끊긴 기존의 배열은
		 * 일정 시간이 지나면 G.C가 알아서 삭제 해준다. : 자동 메모리 관리
		 * 매니지드한다고 얘기함, 메모리 매니지드
		 * 
		 * 기존배열식별자에 할당만 새롭게 한다면
		 * => 기존 참조하고 있던 연결이 끊기고 새로운 배열을 참조함
		 * 
		 */
	
		// GC가 가져가게 하고싶은데? 연결을 끊어버리고싶다 하는 경우가 있으면 --> null을 이용
		// 자바하면서 오늘 처음 본 null --> 널값이라고 함
		// 중요한 건 값
		// null : 아무것도 존재하지 않음을 의미하는 값(없다는 게 아니고 값!!!이 들어있음)
	
		// int형 배열에 0번에 값을 대입안했는데도 찍어봤는데 0이 나옴
		// heap 영역에 생긴(할당받은) 공간은 비어있을 수 없다고 했음 --> 무슨 값이라도 들어가있어야함
		/*
		 * 기본값
		 * 
		 * 정수 = 0
		 * 실수 = 0.0
		 * 문자 = ''(빈 문자)
		 * boolean = false 등
		 * 
		 * 참조자료형 = null
		 * 여기에는 뭐가 들어있나? 아직 대입을 안했으면?
		 * 
		 * 참조자료형에는 null이라는 값이 들어가는데
		 * 주소값이 존재하는가 그렇지 않은가
		 * 
		 */
	
		name = null; // 현재 연결고리를 끊고싶다.
		System.out.println(name); // 주소값이 없음 이라는 의미의 null이 출력됨
		// 얘를 가지고 원래 배열이었지? 하면서
		name[0] = "홍길동"; // 이걸 실행하면? Cannot store to object array because "name" is null
		// NullPointer 이것만 보면 됨
		// Pointer는? 가리키는 것, Null을 가리키고 있음, 그래서 문제가 생기고 있음
		// 니가 지금 가리키고 있는 애는 Null인데 왜 뭘 하려고 하는거임?
		// 가리키고 있는 대상이 null인데 주소가 없는데 어디 접근함????
		// 지금부터 자바 개발자로 살아가는 이상 나를 항상 괴롭히는 것임, 우리들의 적 NullPointerException
	
	} // 해봤으면 메인 메소드에서 주석처리
	
	public void methodE() {
		
		// 그래서 배열 어따씀? --> 앞에서 했음(갯수정해져있고 2개이상이고 자료형이같다면)
		// 그래서 배열 보통 어케씀?(앞에서는 공부하려고 썼음)
		int[] arr = new int[3]; // 0, 1, 2
		arr[0] = 10;
		arr[1] = 20;
		arr[2] = 30;
		System.out.println(Arrays.toString(arr));
		// 이렇게 하는거 맞긴 한데 선생님이 대입 연산자 오른쪽을 설명하고 싶어서 이렇게 쓴 것
		
		// 배열 보통 선언과 동시에 요소를 대입해서 사용하곤함(배열을 쓴다는 것은 정확히 갯수가 정해져있고, 들어갈 값도 정해져 있음)
		int[] arr1 = new int[] {1, 2, 3}; // 크기 할당받는 라인에 크기를 비워놓고, 중괄호 안에 요소를 작성해서 사용
		System.out.println(Arrays.toString(arr1));
		
		// 위에것도 아님, 사실 이렇게 씀, 가장 일반적인 사용방식 --> 덜 힘들다
		int[] arr2 = {100, 200, 300}; // 이렇게 순서대로 인덱스에 추가됨
		System.out.println(Arrays.toString(arr2));
				
	} // 해봤으면 메인 메소드에서 주석처리

	/*
	 * 배열 복사(두가지)
	 * 
	 * 1. 얕은 복사 ☆★☆★
	 * 
	 * 2. 깊은 복사
	 * 
	 */
	
	public void methodF() {
		
		// 얘가 중요함
		// 정수형 배열을 하나 선언해서 요소 대입
		int[] origin = {1, 2, 3, 4, 5}; // 이렇게 쓰는게 대다수
		// new int[5];
		// origin[0] = 1; origin[1] = 2; ....
		System.out.println(Arrays.toString(origin));
		
		// 얕은 복사로 배열을 복사
		int[] copy = origin;
		System.out.println(Arrays.toString(copy));
		
		// 이 상태에서 원본 배열에 접근해서 2번 인덱스의 요소를 33으로 대입
		origin[2] = 33;
		System.out.println(Arrays.toString(origin)); // 원본 배열의 2번 인덱스 요소가 33으로 바뀌어있음
		System.out.println(Arrays.toString(copy));// 복사본도 확인해보니 바뀌어있음, 원본 배열의 요소를 바꾸었는데 복사본 배열도 영향을 받음
		
		// 그림그리기
		// stack 영역과 heap 영역이 있음
		// methodF를 호출하면 stack 영역에 methodF의 영역이 생김(올라감)
		// int[] origin = {1, 2, 3, 4, 5};를 만나면 대입연산자의 왼쪽을 본다 --> 선언, 공간을 받겠다 --> 정수형 배열을 저장하는 공간을 origin이라고 부르겠음 --> 대입연산자의 오른쪽을 본다 --> (origin[0] = 1; origin[1] = 2; ....)이부분을 함축해서 쓴 것 --> heap 메모리에 5칸, 한칸당 4바이트 해서 20바이트가 어디엔가 생김(아무도모름) --> 1, 2, 3, 4, 5가 각각의 인덱스에 대입됨
		// 오른쪽 끝(2번 끝) --> origin에 heap 메모리에 생긴 친구의 주소값(aaaax2232라고 하자)을 대입함 --> origin에 들어있는 것은 aaaax2232를 가리키고 있음
		// 출력문을 실행하면 안에 들어있는 요소들이 출력됨
		// int[] copy = origin;를 만남 --> 정수형 배열을 저장할 수 있는 공간을 선언하고 이름을 copy라고 함 --> copy에는 주소값이 들어갈 수 있음 --> 오른쪽의 origin은 주소값이 들어있음 --> 대입하면 copy에는 origin에 들어있는 주소값이 들어감 --> origin과 똑같이 heap에 있는 aaaax2232를 가리키고 있음
		// 기존에 있던 주소값을 복사본에 대입해서 같은 주소를 가리키도록 하는 것이 얕은 복사
		// origin[2] = 33;를 만나면 heap에 생긴 배열에 가서 세번째칸으로 감 --> 배열의 2번 인덱스의 요소를 33으로 바꿈
		// origin과 copy 모두 같은 것을 가리키고 있으므로 바뀐 33의 요소가 출력됨(실질적으로 가리키고 있는 대상이 동일함, 이름은 다른데 실질적으로 같은 부분을 가리키고 있는 것)
		
		// 얕은 복사 => 주소값을 대입하는 것 이기 때문에 가리키고 있는 대상이 같다.
		System.out.println(origin.hashCode());
		System.out.println(copy.hashCode());
		// 해시충돌을 가정하고 생각해보면 둘이 완전히 같다고 보장은 안되지만 지금은 사실 똑같은 게 맞다
		
	} // 해봤으면 메인 메소드에서 주석처리
	
	// 2. 깊은복사
	public void methodG() {
		
		// 같은 내용을 가리키고 싶지 않음, 내용이 똑같은 새로운 친구를 만들고싶음
		// 배열은 크기가 정해져있는데, 하다보니 요소가 계속 들어가야해서 크기(공간)가 더 필요하게 됨
		// 더 큰 배열을 만들고 기존 배열에 담겨있는 요소를 새로운 배열에 복사해서 옮겨담고싶을때 사용
		// 여러가지 방법이 있음
		// 5칸짜리였는데 6칸짜리가 필요함, 하나 더 넣고싶음
		int[] origin = {1, 2, 3, 4, 5};
		
		// 배열을 선언하고 하나 만들어서
		int[] copy = new int[6]; // 이친구 인덱스에 origin 요소 넣으면 끝
		/*
		copy[0] = origin[0];
		copy[1] = origin[1];
		copy[2] = origin[2];
		copy[3] = origin[3];
		copy[4] = origin[4];
		*/
		// System.out.println(Arrays.toString(origin));
		// System.out.println(Arrays.toString(copy)); // 새 배열의 인덱스가 하나 남으니까 채울 수 있음
		// 여기까지 하니 화가난다! --> 어디가 화가 나요? --> 참을수가 없다 --> 중복제거(주석처리)
		
		// 원본만큼 for문 돌리기, 복사본만큼 돌리면 뭐가 발생할까요?
		/*
		for(int i = 0; i < origin.length; i++) {
			copy[i] = origin[i];
		}
		*/
		
		// 배열의 깊은 복사의 경우 기존 배열의 크기보다 큰 배열로 복사하는 경우가 많음
		
		// alt + ↑, ↓ (행 이동) (죄송합니다...)
		// ctrl + alt + ↑, ↓ (행 복사) (얘는 당분간 쓰지말기, 당분간 직접 작성하기)
		// ctrl + d (행 삭제)
		// ctrl + / (행 주석처리)
		// ctrl + shift + f (코드정리)
		// System.out.println(Arrays.toString(origin));
		System.out.println(Arrays.toString(copy));
		
		int[] copy2 = new int[10]; // 10칸짜리 배열을 만들고 origin의 요소를 여기로 복사해보자 --> 메소드 호출을 이용해보자
		// 메소드를 호출하려면(익숙한 친구로 해보기) System --> arraycopy라는 메소드가 있음(이름만 봐도 배열을 복사하는 용도의 메소드)
		// 첫번째 인자는 복사를 하려고 하는 원본 배열
		// 두번째 인자는 원본 배열에서 복사를 시작할 인덱스
		// 세번째 인자는 이 요소를 복사해서 집어넣을 복사본배열
		// 네번째 인자는 인덱스 중에서 몇번째부터 집어넣을건지
		// 다섯번째 인자는 원본 배열 요소의 몇개를 가져올건지
		System.arraycopy(origin, 0, copy2, 0, 5);
		System.out.println(Arrays.toString(copy2));
		
		/*
		 * 네이밍컨벤션 == 첫 글자가 대문자 == 클래스 / 인터페이스
		 * arraycopy() 메소드를 호출하려고 할 때 참조해서 호출했음 --> 누구를 참조했나요? System --> 첫글자가 대문자네? 우리가 배운 것에 따르면 --> 정체가 클래스다!
		 * arraycopy() ==> System클래스
		 * 
		 * System.arraycopy(원본 배열 식별자, 원본배열에서 복사를 시작할 인덱스,
		 * 					복사본 배열 식별자, 복사본 배열에서 복사가 시작될 인덱스,
		 * 					복사할 개수);
		 * arraycopy는 다섯개의 인자값을 전달해줘야만 사용이 가능하다
		 * 
		 */
		System.out.println(Arrays.toString(origin));
		
		// Arrays를 써서 toString 메소드를 호출했음 --> Arrays도 첫글자가 대문자니까 클래스겠네?
		// Arrays클래스에서 제공하는 copyOf() 메소드를 불러보자
		int[] copy3 = Arrays.copyOf(origin, 15); // 원본배열 복사해서 15칸짜리로 대입, 크기를 늘린 배열을 만들어내는데 특화되어 있음
		System.out.println(Arrays.toString(copy3));
		// arraycopy는 인자들을 전달해서 입맛에 맞게 여러가지 방법으로 복사할 수 있음
		
		int[] copy4 = origin.clone(); // 얕은복사와는 다르고 새로운 친구를 복제해서 만드는 것
		System.out.println(Arrays.toString(copy4));
		
	} // 얕은 복사만 기억해두자, 깊은 복사는 필요하면 찾아쓰세요
	
}
