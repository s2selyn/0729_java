package com.kh.chap01.condition;

import java.util.Scanner;

public class C_Switch {
	
	// 얘도 조건문인데, if는 만약에로 시작했다면 switch(전환하다 바꾸다)는?
	// 많이 쓰는 스위치 뭐가 있을까? 불켜기, ...? 엘리베이터? 누르면 되잖아여
	// 전기 스위치같은거임
	
	public void method0() {
		
		// 설명하기 전 스위치 맛보기
		// 차빼러 지하주차장 가는걸 가정해보자
		Scanner sc = new Scanner(System.in);
		System.out.print("몇 층 가세요?(B1 / B2 / B3) > ");
		String floor = sc.nextLine();
		// System.out.println(floor); // 모범시민이니까 메인 메서드 다녀오기
		// 중간점검의 중요성! 처음에 floor를 int로 선언하고, 스캐너의 메서드가 nextInt였기 때문에 B는 받을 수 없었음
		
		// switch문이니까 switch로 시작하고 소괄호
		// 실제 엘리베이터라는 가정 하에, floor에 들어올 수 있는 것은 3가지
		// B1 B2 B3
		// switch 안에 case로 만들 수 있음
		// 소괄호 안의 것과 case를 동등비교해서 true가 나오는 곳으로 점프
		switch(floor) {
		case "B1" : System.out.println("지하 1층입니다. 문이 열립니다.");
		break; // 위에 것이 수행되면 switch문을 나가고 싶으므로
		// switch문에서 break를 만나는 순간 switch문 블럭 바깥으로 나감
		// 특별한 경우가 아니면 case마다 달려있음
		// 일반적으로 switch문에는 break가 들어가는 편
		// 사실 마지막 break는 없어도 됨
		// break가 하나도 없다면?
		// 지하 3층에 가는건 문제가 없는데, 지하 2층이나 1층으로 실행해도 지하 3층까지 계속 나옴
		// 안내리고 계속 감
		case "B2" : System.out.println("지하 2층입니다. 문이 열립니다.");
		break;
		case "B3" : System.out.println("지하 3층입니다. 문이 열립니다.");
		} // 문이 열렸으니까 break를 걸자
		
	} // 해봤으면 메인 메서드 가서 주석처리

	/*
	 * switch 문
	 * switch문이니까 switch로 시작
	 * if문이랑 똑같이 생겼네, ~~문은 다 똑같이 생김
	 * case 뒤에는 반드시 값을 적어줌
	 * if문처럼 조건을 넣고싶은데 조건의 대상이 동등비교임
	 * 
	 * [ 표현식 ]
	 * 
	 * switch(case문에 기술할 동등비교할 대상) {
	 * case 정수, 단일문자, 실수, 문자열(값들) : 실행할 코드;
	 * }
	 * 
	 * switch(정수 || 실수 || 문자 || 문자열){
	 * case 값1 : 실행할코드a; // 동등비교대상 == 값1 true일 경우 실행할코드 a를 수행
	 * break;				// swtich영역을 빠져나감
	 * case 값2 : 실행할코드b; // 동등비교대상 == 값2 true일 경우 실행할코드 b를 수행
	 * break;
	 * case 값n : 실행할코드n; // 동등비교대상 == 값n true일 경우 실행할코드 n를 수행(얼마든지 쓰고싶은 만큼)
	 * break;
	 * default : 실행할코드; // == else(if문의 마지막 else와 같은 역할, 위에것중에 true인 것이 없음, 전부 false인 경우)
	 * }
	 * 
	 */
	
	// 메뉴 주문
	// 부대찌개, 떡갈비, 제육볶음, 칼국수, 수제비
	public void method1() {
		
		// 사용자에게 구매할 음식의 이름을 입력받아
		// 각 음식마다 가격을 출력해줄 것
		
		// 부대찌개, 		떡갈비, 	제육볶음, 	칼국수, 수제비
		//  11000, 	   13000, 	  7000,	8000, 7000
		
		Scanner sc = new Scanner(System.in);
		System.out.print("메뉴를 선택해주세요(부찌, 떡갈비, 제육, 칼국수, 수제비) > ");
		String menu = sc.nextLine();
		// System.out.println(menu); // 모범시민 출력해보기
		
		// 조건을 switch문으로 만들어보자
		// if로 했다면 조건식 안에 menu.equals("부찌")
		/*if(menu.equals("부찌") {
			System.out.println("11000원 입니다.");
		} else if(menu.equals("떡갈비") {
			System.out.println("13000원 입니다.");
		} else if ...
		*/
		
		/*
		switch(menu) {
		case "부찌" : System.out.println("11000원 입니다."); break;
		case "제육" : System.out.println("7000원 입니다."); break;
		case "떡갈비" : System.out.println("13000원 입니다."); break;
		case "칼국수" : System.out.println("8000원 입니다."); break;
		case "수제비" : System.out.println("7000원 입니다."); break;
		default : System.out.println("그런 메뉴는 없어용 ~ "); // 웬만하면 break를 쓰지 않는다, 어차피 얘가 끝나면 switch 블럭이 끝나니까
		} // 소괄호 안의 것과 case 다음의 값을 동등비교하고 참일 경우 그 다음을 수행함
		*/
		// 주의사항
		// 코드의 중복이 너무 많음, System.out.println 이런 부분이랑, 원 입니다. 이런 부분들
		// 가독성도 별로고 유지보수가 힘드니까 중복을 없애고싶다
		// 중복을 제거해야 하는데 switch는 break를 쓰지 않으면 아래로 내려가서 작업을 수행한다!
		// 제육이랑 수제비는 가격이 같아서 실행할 코드가 똑같음
		// 제육 행의 중복코드와 break를 없애도 되지 않을까?
		// 처음에 생각했으면 안써도 됐겠다! 근데 정말 위험한 생각
		// break를 없애서 의도적으로 아래 코드를 실행시키게 하는 방식은 절대 하면 안됨(fall through)
		// 개발자가 흔히 하는 실수는 break 빠뜨리는 것, 다른 개발자가 봤을 때 실수한 것인지 의도한 것인지 의문을 가질 수 있음
		// 새로운 case를 추가할때도 가독성을 위해서 글자 수를 맞추거나 해둔 것을 깨뜨릴 수 있으니 고려할 것
		// 자바 14버전 이후부터는 case "제육", "수제비" 이런 식으로 작성할 수 있음
		// 이렇게 하지 말고 통째로 뜯어고쳐보자!
		
		// 중복제거하기
		// 중복인 부분과 중복이 아닌 부분을 잘 비교
		// 1. 중복된 부분은 하나로 빼기
		// 2. 중복이 아닌 부분은 변수로 처리
		
		int result = switch(menu) {
		case "제육", "수제비", "칼국수" -> 3000;
		case "떡갈비", "부찌" -> 5000;
		default -> 0;
		};
		System.out.println(result);
		// 이건 3주 정도 있어야 할 것 같은데~
		// switch문을 이용해서 어떤 특정 변수에 조건을 통해서 값을 대입하고 싶을 때
		// -> Arrow 연산자(자바 마지막에, 진도가 빠듯하다면 자바스크립트 시간에)를 사용해서 값을 대입하는 방법도 있음
		// 일반적으로 잘 사용되는 방법은 아님
		
		int price = 0; // 선언만 하면 못씀, 변수를 쓰려면 초기화(initialize), 선언해놓고 모든 케이스에 못들어가면 값이 없는 것, 아직 값이 대입되기 전이므로 0
		// 변수 선언과 초기화 후에 case 마다 대입할 price 부분 작성
		// 중복이 아닌 부분만 변수 선언해서 대입하는 것으로 만들었음 --> 중복 제거를 해냈다!
		switch(menu) {
		case "부찌" : price = 11000; break;
		case "제육" : price = 7000; break;
		case "떡갈비" : price = 13000; break;
		case "칼국수" : price = 8000; break;
		case "수제비" : price = 7000; break;
		default : System.out.println("그런 메뉴는 없어용 ~ ");
		return; // 현재 실행되고 있는 메소드 영역을 아예 빠져나간다.
				// 메소드를 호출한 곳으로 돌아감
		} // break를 만나면 빠져나오는 부분(switch문 내부에서 break를 만나면)
		
		// if(price != 0) {
			System.out.println(price + "원 입니다."); // 중복인 부분은 바깥으로 뺐음, return을 만나면 이 부분은 실행이 안됨
		// }
		
		// 변수는 자기가 선언된 스코프 안에서만 쓸 수 있음, switch문 안에서 선언하면 출력문을 수행할 수 없다
		// 밖에서 switch문 밖에서 선언해야 하는데 아래가 아니라 위로
		
		// 없는 메뉴를 입력하면? 중복된 츌력문을 밑에 빼놨으니까 무조건 실행이 됨
		// 가격이 있을 때만 출력문을 수행하고 싶음
		// 출력문을 default에서 출력하고 싶음
		// 가격이 있을때만 --> 조건! --> if일단 쓰고 생각하자
		// 가격이 있고 없고는 price를 보면 알 수 있음 --> price가 어떤 상태면? 0이 아니면 가격이 있다는 뜻, 골랐으면 가격이 대입되어 들어갔을 테니까
		
		// if절까지 가지 말고 default 절에 왔을때는 출력 안하고 끝났으면 좋겠는데 라고 생각했다면
		// default 다음에 return; 추가
		// 이러고 나면 if는 주석처리 하고 가격을 출력하는 출력문만 남겨도 됨

	} // return을 만나면 빠져나오는 부분(메서드를 닫는 블럭), 나를 부른 곳으로 돌아감, 메인 메서드에서 불렀으니까 메인 메서드로 돌아감

	// 조건문 끝!
	// 웹개발자니까 웹을 가정하고 해보자
	// 보편적으로 가장 먼저 만드는 기능인 로그인 기능
	// 로그인 기능 만들기 귀찮으면 소셜 로그인으로 퉁치기 가능
	// 일반적인 로그인 기능 구현하기
	public void login() {
		
		// 이번 목표는 로그인 구현하기!
		//수도없이 많은 기능들을 구현해볼텐데, 개발자가 기능을 구현(개발)해야 하는 상황이라면
		// 우리는 프로젝트를 해야 함 --> 만들어보세요~ 가 시작이 아님
		// 시작은 기획 / 설계 단계부터
		
		// 기획 -> 뭘 만들지? (클라이언트 요구사항에 의해서 정해지는 것, 별로 안중요함)
		// 설계 -> 어떻게 만들지? (개발자에게 중요한 것, 중요한 것, 시간이 오래 걸리고, 많이 고쳐야 하고)
		
		// 어떤점을 먼저 생각해봐야할까?
		// 로그인 사용 -> 분석 -> 이해 (이 과정이 필요)
		// 로그인이란 뭘까...?
		
		// 아이디 비밀번호
		//     입력
		// 보편적으로 생각했을 때
		
		// 로그인 구현할 때 필요한 값 : (내가 사용자에게 받아야 할 값은?) 
		// 1. 사용자가 입력한 아이디 값 -> (자료형 생각하기, 일반적으로는)문자열 -> String
		// 2. 사용자가 입력한 비밀번호 값 -> 문자열 -> String
		
		// 로그인 시 필요한 선행 작업 :
		// 회원가입이라는 기능을 성공적으로 잘 사용했어야만 로그인이라는 기능을 사용할 수 있음, 회원가입 안하면 로그인 못함
		// 내가 만드려고 하는 구현하려고 하는 기능이 다른 사이트들에서는 어떻게 돌고 있는지 먼저 많이 사용해봐야 함
		// 그래야 값이 뭐가 필요한 지 알고, 성공했을 때, 실패했을 때 어떻게 해줄 지 정할 수 있음
		// 제품을 만드는 사람들이니까 당연히 시장에 나와있는 것들을 잘 조사해야함
		
		// 1. 회원가입 시 사용자가 원하는 아이디 값과 비밀번호 값을 입력하여 회원가입을 진행함
		// 2. 가입 시 입력했던 아이디와 비밀번호를 둘 다 정확히 입력한다면 로그인 성공 화면 출력
		// 3. 가입 시 입력했던 아이디 또는 비밀번호가 하나라도 일치하지 않다면 로그인 실패 화면 출력
		
		// 하단의 정보로 회원가입을 진행했다고 가정
		String id = "user01";
		String password = "pass01";
		String name = "홍길동";
		// 회원가입 한 것을 어딘가에 저장해두었음
		
		// ---------- 회원가입 완료됐다!
		
		// 아이디도 받고 비밀번호도 받아야 함
		// 일반적으로 입력받고 싶은 것이 적혀 있음, 메세지
		System.out.println("KH업텐");
		System.out.println("====================");
		System.out.println("로그인 서비스 입니다.");
		System.out.println("====================");
		
		// 입력받아야 하니까 스캐너
		Scanner sc = new Scanner(System.in);
		System.out.println("--------------------");
		System.out.print("아이디 > ");
		String userId = sc.nextLine();
		
		System.out.println("--------------------");
		System.out.print("비밀번호 > ");
		String userPwd = sc.nextLine();
		
		System.out.println("--------------------");
		
		// 만약에 사용자가 로그인 시 입력한 아이디 값과 회원가입 시 가입한 아이디 값이 동일하고
		// 사용자가 로그인 시 입력한 비밀번호 값과 회원가입 시 가입한 비밀번호 값이 동일하다면
		// 이것을 코드로 바꿔야함
		// 조건이 써져있다 --> 일단 if로 시작
		// 사용자가 로그인 시 입력한 아이디 값은 userId 보면 알 수 있고, 회원가입 시 입력한 아이디 값은 id를 보면 알 수 있음 --> 동등비교 해야하는데 문자열끼리 동등비교는? --> equals
		// 비밀번호도 마찬가지
		// 아이디와 비밀번호 둘 다 일치해야 하므로 &&
		if(userId.equals(id) && userPwd.equals(password)) {
			System.out.println("로그인 성공 ~ " + name + "님 환영합니다 !");
		} else { // 아이디와 비밀번호 둘 다 일치하는게 아니라면
			System.out.println("아이디 또는 비밀번호가 일치하지 않습니다.");
		}
		
		// 기본자료형 : boolean, char, byte, short, int, long, float, double(타입별, 크기별 순서대로 말하는 연습)
		// => 기본자료형의 경우 동등비교 연산자를 수행하는 데 있어 문제가 없음(==, !=)
		
		// 참조자료형 : 그 외(String이 대표적)
		// => 동등비교 연산자(==, !=)를 통해서 값을 비교하는것이 불가능!!
		// 실제 변수에 담기는 값이 '주소값'이기 때문
		// 문자열의 값을 비교 : equals() => true / false(equals 메소드를 호출하여 비교하면 참/거짓으로 반환해줌)
		
		// 기본적인 로직 상으로는 이게 로그인이고, 여기에 살을 붙이는 것
		
	}
	
}
