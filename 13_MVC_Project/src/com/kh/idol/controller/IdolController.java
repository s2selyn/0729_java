package com.kh.idol.controller;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import com.kh.idol.model.vo.Board;
import com.kh.idol.model.vo.Fan;
import com.kh.idol.model.vo.Idol;

public class IdolController {
	
	private List<Fan> fans = new ArrayList(); // 회원가입하면 회원정보 담아둘 리스트
	private List<Board> boards = new ArrayList(); // 게시글 담아둘 리스트
	
	// 아이돌들도 어디에 담아놓고 고걸 읽어와서 정보를 출력해줘야 하지않을까? --> 이러면 VO가 하나 더 필요함(아이돌의 정보를 담을 VO)
	// 과감하게 만듭시다~
	
	// 아이돌들 담아놔야지, 에스파가 솔로가수가 아니니까, 아이돌형 배열로 할까 리스트로 할까? 에스파 하다가 한명이 나가거나 들어올수도 있으니까 리스트가 맞지 않을까!
	private List<Idol> aespa = new ArrayList();
	
	private int boardNo;
	
	// 사용하는 쪽을 위헤 제네릭 작성해줌, 컴파일 시점에 컴파일러가 이 타입을 알 수 있음, 다형성을 적용할 수 있어서 강제 형변환을 안해도됨!
	
// 12:43 List란?
// 컴퓨터공학 추상적 자료형중에 하나, 순차적으로 저장하는 자료구조
// 자바에서는 자료구조 담당하는 컬렉션 프레임워크중에 하나, 알고리즘들이 들어있음, 인터페이스로 구현되어있음
// 실제 구현하는 구현체들은 ArrayList 등등이 있는 부모자료형의 인터페이스
	// 너무 길게 말하지는 말고 간결하게 내 강점에 맞춰서 설명, 이런걸 공부하는 시점에 정해두자, 나중에는 시간없다, 잘 말하는 연습도 하고
	
	// 리스트 구현체 중에 ArrayList를 써볼건데, 부모타입 자료형을 사용해야 구현체를 마음대로 바꿀 수 있는 유연성이 생김, 나중의 유지보수, 기능확장을 생각해서 프로그램 만들기
	// 지금은 이렇게 작업하지만 나중에 이렇게 안하면 큰일나기도 하고!
	
// 12:48 제네릭 컬렉션 프레임워크 알고리즘 추상적..? 뭐가 합쳐진거지
	// 코드 이용해서 문제 해결하는 방법을 알고리즘이라고 할 수 있음, 나의 논리 회로를 돌려서 알고리즘을 만들어내는것
// 12:48 컬렉션은 자료구조에 포커싱이 맞춰져있어서 장점이...? 자바에 메소드로 구현되어 있고?
	
// 12:50 초기화 블록을 이용해서 정보를 담아놓도록 하자
	
	{
		
		aespa.add(new Idol("카리나", "리더", "Rocket Puncher"));
		aespa.get(0).setImage("""
				
				아마도 이렇게 생긴 카리나
				
				""");
		aespa.add(new Idol("지젤", "외국인1", "Xenoglossy"));
		aespa.get(1).setImage("""
				
				아마도 이렇게 생긴 지젤
				
				""");
		aespa.add(new Idol("윈터", "불자", "Armamenter"));
		aespa.get(2).setImage("""
				
				아마도 이렇게 생긴 윈터
				
				""");
		aespa.add(new Idol("닝닝", "외국인2", "E.D Hacker"));
		aespa.get(3).setImage("""
				
				아마도 이렇게 생긴 닝닝
				
				""");
		
	}
	
	public List<Idol> findAll() {
		
		// view에서 요청이 올것임, controller는 요청에 return을 해줘야함, List의 주소값!
// 14:29 무슨 주소값? 아이돌들의 주소가 담겨있는 배열을 필드로 가지고 있는 리스트의 주소값??
		return aespa; // --> 반환타입 수정
		
	}
	
	// 그냥 와서 컨트롤러가 특정 한명의 아이돌 주소를 반환할 수 있나?
	// 누구의 주소가 필요한지 컨트롤러 입장에서는 모름 --> 요청을 보낼 때 알려줘야함
	public Idol findMember(int memberNo) {
		
		// 메소드 시그니처 수정, 넘겨주는 정수값을 받아야함, 매개변수 있어야함
		// menuNo로 변수 이름을 일치시킬수도 있지만 의미상으로 memberNo가 더 맞는 것 같아서 수정함
		// 1은 카리나, 2는 지젤, 3은 윈터, 4는 닝닝 줘야함 --> 조건!
		/*
		if(memberNo == 1) {
			return aespa.get(0);
		} else if(memberNo == 2) {
			return aespa.get(1);
		} else if(memberNo == 3) {
			return aespa.get(2);
		} else {
			return aespa.get(3);
		}
		*/
		// 이러면 중복이라 참을 수 없음^^ 중복을 없애고 싶다! 단순히 생각하면 n-1의 인덱스를 돌려주는거잖아, n은 memberNo이고
		return aespa.get(memberNo - 1);
		
	}
	
// 15:22 ㅇㅅㅇㅅㅇㅅㅇㅅㅇ
	// 사용자가 아이디를 입력했을 때 1. 입력한 아이디가
	// 2. Fan들이 들어가는 List의 3. 요소의 userId필드값과 4. 중복되는 게 있는지
	// 확인을 한 뒤에 결과를 View로 다시 반환
	
	// 오늘 자바 기본 문법 마지막날이라서 .. 내가 해야 할 일을 한글로 쭉 적어놓고 작업하자
	// 처음에는 이렇게 시작하는 것이 좋다. 이게 숙련되면 무슨 코드를 작성해보나요? 처음부터 코드로 만들어야지 하면 동시에 해야 할 생각이 두개, 생각이 복잡해짐
	// 작업을 하기전에 해야될일이 뭐지? 나의 언어 한글로 적어놓고 이걸 한글을 코드로 바꾸는 방법 뭐지? 하고 문법 찾아보고 적어도됨
	public boolean checkId(String userId) {
		
		// 1. 입력한 아이디가 --> userId
		// 2. Fan들이 들어가는 List --> fans
		// 3. 요소의 userId필드값 --> fans.get(i).getUserId()
		// 4. equals()
// 코드작성하는 과정과 생각방법
		
		for(int i = 0; i < fans.size(); i++) {
			if(userId.equals(fans.get(i).getUserId())) {
				// 중복아이디 있음! --> 니가 지금 입력한걸로 가입할 수 없음
				return true;
			}
		} // 중복아이디 없음! --> 니가 지금 입력한걸로 가입할 수 있음
		
		return false;
		
	}
	
	// view의 요청을 또 받아줘야한다
	// 사용자가 입력한 아이디, 비밀번호, 닉네임을 View로 부터 전달받아
	// 새로운 Fan이라는 객체를 생성하면서 필드에 값을 대입해주고
	// 생성된 Fan객체의 주소값을 내가 가지고 있는 Fan들이 들어가는 List의 요소로
	// 추가를 해주는 메소드를 구현을 해야함
	public boolean signUp(String userId, String userPwd, String nickName) {
		// 이 메소드 좋다! 컨트롤러가 해야할 일을 선생님이 명확하게 설명해주실 수 있대요
		// 컨트롤러는 도대체 뷰로부터 요청을 받아서 무슨 일을 해야하는지
		
		// view한테 문자열값 세개를 받았음, 컨트롤러는 보편적으로 여러개의 값을 앞단에서 받았을때는 데이터를 가공해줌
		// 1. 데이터 가공
		// 가공의 형태는 개발자가 정함, 값이 여러개면 다루기가 힘들다. 여러개의 자료형일수도 있다. 우리는 잘 알지..
		// 변수로 다루기는 힘들고, 배열은 한가지 자료형만 다룰 수 있음
		// 첫번째로는 이런것들을 다룰 수 있는 VO를 쓴다 또는 두번째로 사람들이 잘 알아볼 수 있게 Map을 쓴다
		// 회원의 정보를 받아왔는데, 우리는 fan이라는 모양으로 다루기로 했음, 객체로 가공해주겠다!
		Fan fan = new Fan(userId, userPwd, nickName);
		// 값이 하나밖에 안넘어왔다면 데이터 가공작업은 없지만 두개이상(여러개)이 넘어왔다면 보편적으로 컨트롤러에서 가공처리함
		
		// 2. 요청 처리(아직 요청 처리하는 계층(Layer)을 안배웠으므로 컨트롤러에서 처리)
		// 지금은 새로운 팬을 만들어달라는게 요청이었음 --> 정석대로는 팬을 만드는 어떤 작업 절차를 처리하는 애가 따로 있음
		// 얘는 걔한테 넘겨주는게 사실 요청처리임! 지금은 아니고 다다음주에 배울 예정
		// 컨트롤러는 넘겨주기만 하고 중간에서 왔다갔다 중간다리 역할만 하는 애임
		// 근데 지금이야 List에 넣으면 끝이지 뭐
		// fans.add(fan);
		
		// 일반적으로 생각했을 때 이건 문제가 일어날 수 없음, 리스트는 들어가는대로 쭉쭉 늘어날테니까
		// 근데 우리는 개발자이기때문에 이런 일이 발생할 수도 있을 것 같은데? 하고 염두해야함
		// 일어날 수 있는 케이스 한가지...
		// 첫번째 회원이 가입할 아이디를 user01 이라고 입력함, 4~10글자 통과, 회원이 없으니 중복체크도 통과(아이디 유효성 검증 코드 넘어감, 사용할 수 있음)
		// 근데 user01이라고 가입하는 사람이 우리라고 가정하자. 여기까지 하고 나서 밥먹으러 간다고 쳐. 그사이에 누가 와서 user01이라고 적었어. 그러면...? 아직 비밀번호를 입력하지 않았기 때문에 회원가입이 안된 상태
		// 그럼 내가 돌아오기 전에 user01로 가입이 끝나버림, 근데 나는 밥먹고 돌아왔을 때 이미 아이디 유효성 검사를 통과한 상태니까 똑같은 아이디로 가입이 될 수 있음...헉
// 15:49 뭐 일반적으로는 시간제한을 걸어두든가 어쩌구저쩌구 함
		// 이미 검증하는 메소드 구현 끝났으니까 체크 한번 더해서 중복된게 없을때만 가입시킨다면 어떨까?
		// 문제가 발생할 수 있는 여지를 줄일 수 있겠다!
		boolean result = checkId(userId); // true가 오면 그사이에 누가 가입한거
		
		if(!result) {
			fans.add(fan);
		}
		
		// 마지막으로 해야 할 중요한 일, 성공실패를 반환해서 출력할 수 있도록 해줘야함
		// 3. 결과값 반환
		return result; // 이러고 반환 타입을 boolean으로 바꿔줌
		// 지금은 result 변수 자체를 돌려주면 된다. true는 가입실패, false는 가입성공을 의미하게 됨
		
	}
	
	// 사용자가 로그인 요청 시 호출되는 메소드
	// 뭘 받을지 정해뒀음, 이미 뷰에서 보냄
	public Fan login(String userId, String userPwd) {
		
		// (컨트롤러가 가지고 있는)Fan의 정보를 필드에 저장하는 Fan객체들의 주소를 가지고있는
		// fans라는 리스트의 요소에 하나하나 접근해서
		// Fan객체의 userId필드 및 userPwd필드를
		// 사용자가 입력한 userId값 + userPwd값과 각각 비교하여
		// 둘 다 일치하는 Fan객체가 존재한다면 사용자의 정보가 담겨있는 Fan을 반환(Fan의 주소를 반환, 없으면 돌려줄게 없으니 null값을 돌려주자)
		
		// 결국 할일은 반복문 돌려서 리스트의 요소에 접근하는거지
		for(int i = 0; i < fans.size(); i++) {
			
			// get으로 하면 너무 길어지니까 미리 변수로 뽑아서 사용하자
			// 반복하면서 순차적으로 접근할 요소 객체를 변수로 선언
// 16:13 get을 미리 뽑아서 주소를 변수에 담아?????
			Fan fan = fans.get(i);
			
			// 만약에 fan에 userId 필드값이 사용자가 입력한 값이랑 똑같고
			// 사용자가 입력한 비밀번호 값이 fan에 비밀번호 값이랑 똑같으면
			if(userId.equals(fan.getUserId()) && userPwd.equals(fan.getUserPwd())) {
				
				// 사용자가 입력한 아이디 & 비밀번호와 일치하는 Fan객체가 존재함
				return fan;
				
			}
			
		}
		
		// for문을 다돌고 나왔다면 존재안한다는뜻이니까 널값 반환
		return null;
		
	}
	
	// 로그인에 성공한 사용자가 게시글 작성 요청을 할 때 마다 호출이 되는 메소드
	public void post(String boardTitle, String boardContent, String userId) {
		
		// 이 안에서는?
		// 기존 boardNo 보다 1증가시킨 값과
		// 사용자가 입력한 게시글 제목, 내용 값과
		// 현재 로그인된 사용자의 아이디 값과
		// 현재 게시글 작성 요청이 들어온 시간 값을 가지고
		// Board객체를 만들어서 Board타입들이 들어가는 List의 요소로 추가
		
		// 1. 데이터 가공
		// 넣어야 할 게 다섯개, 보드 모양으로 하나로 합쳐서 넣어야함, 세개는 이미 정해져있음
		Board board = new Board();
		board.setBoardTitle(boardTitle);
		board.setBoardContent(boardContent);
		board.setUserId(userId);
		
		// 제일 첨 글은 1, 기준점이 있어야 1 2 3 4 올리겠지
		// 기준점이 지금 없음, 기존에 게시글이 하나라도 있으면 보드 리스트에서 마지막것을 뽑아서, 그것의 보드넘버를 뽑아서, 거기에 +1을 하면 값을 얻어낼 수 있겠지
		// 지금은 게시글이 하나도 없어서 불가능, 기준점을 하나 만들어줘야함, 지역변수로 만든다면? 게시글 작성때마다 1번이 들어감.. 여기있으면 안될듯
		// 어디다가 만들어요? 선택지 2개정도.. 1. 필드로 선언해서 사용(그럼 기본값이 0이니까 부를때마다 1씩 증가해서 들어갈 수 있음)
		// 2. 스태틱에 올리는 방법(스태틱은 결국 다른애도 써야 의미가 있는건데 우리가 보드를 만들때만 쓰려고 하니까 이것보단 1번 ㄱ)
		board.setBoardNo(++boardNo);
		
		// 날짜는? 어떻게함? LocalDateTime 이건 아직 안했는뎅ㅎ 예습을 너무 열심히 하신 듯. 나중에 배워요~
		// 저번에 유틸에서 뭐 가져와서 했더라? Date? 이거하면 어떻게 나옴? wed aug 21 kst 17:xx어쩌고 나오겠지
		// string으로 해놔서 Date 타입으로 못넣음.. 포맷으로 했던것같은데? 그냥 포맷은 아님 ㅎ
		// 어떤 친구를 포맷팅하고싶은거지? 날짜형식의 값을 포맷팅하고싶은것이므로.. 단순하게 하고싶은것이므로.. 형식은 내맘대로고
		String createDate = new SimpleDateFormat("yyyy년 MM월 dd일").format(new Date()); // 이것도 데이터 가공이지, 내가 원하는 날짜 형식으로 사용할 수 있게끔
		board.setCreateDate(createDate);
		
		// 데이터 가공 과정은 끝, 이제 해야 할 건 Board타입들이 들어가는 List의 요소로 추가
		// 2. 요 청 처 리
		boards.add(board);
		// 원래 반환값 돌려야하는데 시간없어서 ㄱㄱ
		// 3번 해야지. 근데 혼자서도 할 수 있겠지. 쟤도 boolean이라 true/false로 반환하면됨
		// view로 돌아감
		
	}
	
	public List<Board> selectBoardList() {
		
		// View의 요청에 의해 호출되며,
		// 게시글 목록이 담겨있는 것을 되돌려주어야함
		// 되돌려줄거니까 뭐 써야해요? 일단 return 확정, 게시글 목록이 담긴 친구를 되돌려줘야함 어디 담겨있음? 보드들이 담길 수 있는 boards라는 리스트에 주소가
		return boards; // 반환형 타입 맞춰주기
		// 이러고 돌아감
		
	}
	
	// 그냥 달라고 해도 되나요? 컨트롤러가 알아서 줄 수 있나요?
	// 메소드 이름(식별자)만 봐도 boardNo가 있어야 할 것 같음~
	// 전달해주고 받아서 써야함
	public Board findByBoardNo(int boardNo) {
		
		// 기왕이면 게시글 누를때마다 랜덤 사진이 나오도록 구현하기... ㅎ 재미있을 것 같은데 재미없을수 없을 것 같은데 시간없어서 못함
		// int randomPhoto = (int)(Math.random() * 3 + 1);
		
		// 이거 받아서 어떻게 해야함?
		// boards에서 get을 호출하면서 boardNo - 1을 인자값으로 넣음????
		// boards.get(boardNo - 1); // 삭제가 없으니까 지금 우리 코드에서 가능함, 1, 2, 3, 4 이렇게 들어감 0, 1, 2, 3 인덱스에 차곡차곡(아까 멤버랑 똑같은거임)
		// 만약에 게시글 삭제가 구현되어 있으면? 2번 게시글을 지웠으면 1번 인덱스가 날아가고 한칸씩 땡겨짐, 4번 게시글 요청하면 인덱스 아웃 예외 발생함
		// 이런것들 고려해야함! 지금은 우리가 삭제기능이 없기 때문에 이렇게 해도 문제없음
// 17:35 나중에 삭제기능 추가하려면 보드리스트 반복돌려서 똑같은 어...객체를 찾아서 반환해줘야함
		// 근데 지금도 그런문제 발생가능, 2번까지 있는데 없는 값 입력해버리면 터짐 --> 최소한의 안전장치 추가
		if(boardNo > this.boardNo) {
			return null;
		}
		
		return boards.get(boardNo - 1);
		
	}
	
}
