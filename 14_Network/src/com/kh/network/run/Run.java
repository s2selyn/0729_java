package com.kh.network.run;

import java.net.InetAddress;
import java.net.UnknownHostException;

public class Run {

	public static void main(String[] args) {
		
		/*
		 * 어제부터 했던 내용 정리
		 * 
		 * 네트워크(Network, 그물망처럼 연결되어있는 형태)
		 * 
		 * 통신 가능한 두 대 이상의 장치들을 물리적 또는 논리적으로 연결한 환경
		 * 네트워크의 목적 : 데이터의 교환(왜 네트워크를 만들었나요? 데이터를 주고받으려고)
		 * 
		 * 통신이 가능한 장치는 일반적으로 Host라고 통칭하며, (제일 끝과 끝)종단간의 실제 통신 장치는 EndPoint라고 표현
		 * 
		 * 통신을 할 때 필요한 주소 두가지
		 * MAC(Media Access Controller) Address / IP(Internet Protocol) Address
		 * 
		 * - MAC Address : NIC(Network Interface Card)에 실제 제조시 붙여지는 몰리적인 주소
		 * 옛날에는 이렇게 얘기함, 어차피 통신할때 MAC이 찍히니까 IP 우회해봤자 소용없다 --> 근데 이제 실제 환경에 가면 가상에 올려서 씀
		 * 실무에서는 다 가상으로 올려놓고 씀, 개념적으로는 물리적인 것이기 때문에 고정해놓고 쓴다(실무랑 다르지)
		 * 
		 * - IP Address : Internet상에서 각 Host들을 식별할 수 있는 논리적인 주소
		 * 가변적, 언제든지 변화 가능
		 * 
		 * 주소는 아니지만 포트 번호도 필요함
		 * 
		 * - Port Number : Host 내부에서 작동하는 Process를 식별할 때 사용하는 내부 번호
		 * 프로그램들을 식별할 때 씀
		 * 
		 * MAC => 이론상 절대 고정값 => 실제 가상으로 올려서 사용함(실무 환경에서는 가짜 MAC을 만들어서 돌림)
		 * 
		 * => IP주소와 Port번호는 항상 고정값이 아니라 변동이 가능한 유동적인 값(언제든, 시도때도없이 바꿀 수 있음, 쉽기도 함)
		 * 	  단, 값을 바꿀때 IP주소는 같은 네트워크 범위 안에서(공유기로 묶인 동네, 강의실 안에서 겹치면 호스트 충돌이 발생함), Port번호는 컴퓨터 내부에서
		 * 	  중복이 발생되어선 안됨!!! 충돌이 일어남!!!
		 * 
		 * - Server와 Client
		 * 
		 * Server : Client(사용자)에게 서비스를 제공해주는 물리적인 컴퓨터 또는 프로그램(중의적인 의미)
		 * 			즉, Client의 요청에 대한 응답을 제공해주는 서비스 제공자
		 * 실제로 서버 컴퓨터가 있음, 일반적인 서버 컴퓨터의 형태가 있음, 저장장치와 연산장치와 포트가 매우 많이 달린 컴퓨터
		 * 요청을 받아서 처리해주는데 특화되어있다
		 * 데이터센터나 회사 서버실에 가면 랙(lack)에 서버를 하나씩 꽂아서 사용함, 잘돌아가는 컴퓨터라서 24시간 돌려서 매우 뜨거움, 1년 365일 냉방을 매우 돌림! 여름에 시원하고 겨울에도 춥고
		 * 포트 많이 쓸 수 있고 램 많이 달린 컴퓨터~
		 * 조그만 서비스 해주는것도 서버 컴퓨터고 은행에서 쓰는건 메인프레임(찐 대용량 연산처리 왕 서버 컴퓨터, IBM에서만 만들고있다, 독점은 유지보수비용이 문제)
		 * 하나은행이랑 기업은행이 IBM 드러워서 못써먹겠다 하고 갈아엎으려다가 그동안 축적된 데이터가 많아서 실패
		 * 천공카드로 작업했던 사람이 아직도 유지보수 작업을 한다네요
		 * 핀테크 기업, 최신 디지털 기업 아니면 은행 같은 경우에는 옛날 기술 유지보수하면서 씀. 안정성이 제일 중요함(은행 3분 서버 멈추면 바로 금융감독원 출동)
		 * 물리적인 컴퓨터를 서버라고 하기도 하고, 이 컴퓨터 안에서도 요청을 받고 응답을 보내줄 프로그램이 있어야함, 이 프로그램도 서버 프로그램이라고 함
		 * 서버 컴퓨터 / 서버 프로그램 이렇게 표현
		 * 광화문, 종로 이쪽에 금융 증권 이런 회사 많음
		 * 원래는 서울이 이렇게 포화되어있지 않고, 땅값도 비싼 이곳에 왜왔을까? 원래는 다 지방에 있었음
		 * 해외주식 거래하는 사람들이 실제로 돈이 오르내리는게 바로 반영되어야 하는데, 광화문과 광주가 1초 차이난다고 함(바깥에 있는건 인천으로 들어오기 때문에)
		 * 1초에 목숨거는 사람들, 그래서 다 서울로 올라옴, 요새는 체감하기 힘들지만
		 * 
		 * Client : Server에게 서비스를 요청하는 물리적인 컴퓨터 또는 프로그램
		 * 			즉, 서비스를 제공받는 고객
		 * 
		 * 이것을 클라이언트-서버 모델이라고 함, 클라이언트가 시작임(대전제)
		 * 
		 * => 서버는 자기 혼자 응답을 보낼 수 없음! 클라이언트의 요청이 들어와야만 응답을 보낼 수 있는 구조
		 * 내가 컴퓨터를 켰는데 갑자기 네이버가 내 화면에 뜨면 누가 내 컴퓨터를 해킹한거지.. 서버가 내 IP를 알고 먼저 데이터를 보내줄수가 없음! 있을 수 없는 일
		 * 선행조건이 반드시 클라이언트의 요청! 요청이 없는데 보낼 수 없음
		 * 
		 * => 클라이언트는 서버에 요청을 보내기 위해서 서버의 IP주소와 Port번호를 알아야 함
		 * 이거 두개를 모르면 어차피 요청을 보내봤자 응답을 못받음, IP만 알고 가도 Port번호를 모르면 서버가 거절함
		 * 
		 */
		
		// 자바로 네트워크 맛보기
		// InetAddress : 네트워크 정보를 확인할 수 있는 클래스
		
		try {
			
			InetAddress localHost = InetAddress.getLocalHost(); // 스태틱 메소드 호출
			// 로컬호스트 내놔의 의미, 리턴을 로컬호스트의 주소를 반환해줌(Returns:the address of the local host.)
			// 메소드 떤지기를 하고있음 UnknownHostException --> try-catch 처리
			
			// localHost : 현재 프로그램을 동작시킨 장치(컴퓨터)를 의미
			// getLocalHost() : 작업하고 있는 Host의 정보를 반환해주는 메소드
			
			System.out.println(localHost); // DESKTOP-O25KJL4/192.168.10.91
			// --> PC이름 / IP주소(안쪽에서 쓰는 가짜 IP)
			// 이게 필드로 들어있음, hostName, address / 클래스니까 getter/setter 다 있음
			System.out.println(localHost.getHostName());
			System.out.println(localHost.getHostAddress());
// 14:08 자바 개발자들끼리의 약속(사실 자바뿐만아니라) : get/set 이름짓기
			
			System.out.println("==================================================");
			
			// 웹에서 IP보다는 도메인을 입력해서 감
			// 우리도 나중에 도메인 구매해야함, Gabia에서
			// 도메인을 사서 내 서버의 IP와 연결함, 그럼 전세계로 전파함, 15분에서 20분이면 전파 끝, 사흘까지 걸리기도 함
// 14:13 전파과정
			
			// 명령프롬프트에서 nslookup --> name server 보는 방법
			// 도메인을 넣으면 서버 IP 주소를 알아낼 수 있음
			// 반대로 IP로 도메인을 알아내는 방법도 있음
			// 자바에서 코드로 해보자! 코드를 써서 도메인으로 IP주소 얻어내기
			// 도메인네임을 통해서 서버컴퓨터와 관련된 정보를 얻어 낼 수 있음
			// 도메인이라는 표현이 애매해...
			// DomainName : 사용자가 서비스를 이용할 때 서버의 IP주소를 외우기 어려우니까
			//				외우기 쉬운구조로 사용자에게 제공되는 이름(별칭, Alias)
// 웹브라우저 주소에 도메인을 입력하면 DNS로 요청을 보내서 서버의 IP주소를 가지고 웹서버로 요청을 보냄
			// www.google.com -> hosts파일 -> DNS(Domain Name System)
			// google서버의 IP주소를 가지고 웹서버로 HTTP(s)요청
			// InetAddress 스태틱 메소드를 보면 getByName이 있음, 도메인을 인자로 전달해서 정보를 받아올 수 있는 방법
			InetAddress googleHost = InetAddress.getByName("www.google.com");
			// getByName() : 도메인네임을 이용해 서버의 정보를 반환
			
			System.out.println(googleHost);
			System.out.println(googleHost.getHostName());
			System.out.println(googleHost.getHostAddress());
			
// 14:24 IP는 다르게 나올 수 있음, 요즘은 클라우드 환경때문에
// 근본부터(무슨 환경?)
			// 요즘은 기업에 대한 인터넷상의 공격이 심함
			// 서버는 클라이언트 요청이 오면 무조건 응답을 줘야함
			// 만약에 클라이언트 1만대가 동시에 하나의 서버에 요청을 보내게되면 어떻게될까? 실생활에서도 만날 수 있음, 티켓팅, 수강신청, 인기있는 무언가를 예매한다거나, 드로우, 야구장 등
			// 어떻게됐든 마지막에는 케이블로 들어감, 물리적인 연결을 통해서 컴퓨터로 들어감(이건 바꿀 수 없음)
			// 하드웨어 성능은 날이갈수록 좋아짐, 하나의 서버가 처리할 수 있는 양은 늘어남, 실질적인 컴퓨터의 성능은 올라갈 수 있는데 케이블은 한번에 받을 수 있는 데이터의 양이 정해져있음
			// 물론 좋은 케이블을 쓰면 되지만, 좋은 케이블은 억단위라 너무 비쌈! 쉽게 못함.. 정상적인 요청이면 괜찮은데 악의적인 목적으로 하는 경우도 많음(좀비PC, 나도모르게 내 컴퓨터가 공격하는데 이용될 수 있음)
			// 사이트 공격을 그만해줄테니 비트코인 내놔 이런식
			// 지금도 계속 공격을 당하고 있는 회사들이 이런것들을 막기 위해 앞쪽에 보안장치를 둠(결국 얘네도 컴퓨터고 프로그램임), 하나말고 여러개 필터들, 얘네를 다 뚫어야됨
			// 다 뚫고 나면 서버가 있을 수 있음. 하나의 서버로는 받을 수 있는 요청에 한계가 있음(케이블탓)
			// 지금 전세계인구가 얼마나 많은 구글 서버에 요청을 보낼까? 하나의 서버로는 요청을 다 처리할 수 없음 --> 서버가 분산구조로 되어있음 --> 서버 앞에는 L4스위치 또는 로드밸런서라는 장치를 둠
			// --> 서버가 일하고 있는 상태에 따라서 어느 서버에 보낼지 판단, 똑같은 요청을 보내더라도 실제로 요청을 받는 서버는 다를 수 있음
			
			// 서버는 분산구조로 이루어져있음
			// 영화에서 생각하는 해커의 이미지, 상상하는 모습.. 왜그렇게 불끄고 살아? 모자달린거 뒤집어쓰고..
			// 요즘 젊은이들은 그렇게 살지 않고 요새는 다 사회생활하고 직장생활 하면서 집에서 딸깍 한번 눌러놓고 밖에나가서 활동하면서 될때까지 세네달 기다림
			// 어디 되면 비트코인을 보내라 이러고~
			// 기본적으로 우리가 이름을 알고있는 모든 회사는 공격을 받고 있다고 생각해야함, SK, Yes24 등등 이런식으로 뚫린건 아니지만
			// 불법 도박 사이트도 결국 웹으로 운영하지. 한국에서 하면 100% 잡힘! 안잡히는애들 없음. 죄다 나가있음(중국, 베트남, 필리핀 등)
			// 월세도 비싸지 않고 크게 해두고 컴퓨터 풀로 돌려놓고 작업한다고 하네요, 이거 하나 만드는데 현금 3억이 필요하다고 들었다고 하시네요^^
			// 사이트 구축, 도메인 받기, 점조직이고 위에서 관리하는데가 따로 있어서 돌리는데도 하루 돌아가는 현금이 필요하고.. 여러명이 3억을 모아서 위에다가 요거 할래요 하고 나가서 한다네요
			// 그렇게 하는데 IT쪽 지식을 가지고 시작하는게 아니고 운영만 하는거니까(돈굴리기) 얘네도 공격을 많이 받는다네요
			// 러시아, 중국, 인도에서 불법 사이트를 공격. 운영 못하면 매우 손해니까. 그런데서 공격하는건 비트코인이 아니라 달러로 받는대요. 한화 500만 정도 요구한대. 그래서 그냥 500을 준대
			// .. 근데 6시간 뒤에 또 공격하고 500 뜯어가는 뭐 그런식? 근데 돈 주면서 한다네요
			// 뒷세계는 서버 관리를 유명한 한사람이 한다고 하네요? 돈을 어마어마하게 번대요~
			// 돈 많이 벌려면 나쁜짓.. 범법자가 되어야해? 쉽지 않은 세상이 되어버림..
			
		} catch(UnknownHostException e) { // import 주의 --> import java.net.UnknownHostException;
			e.printStackTrace();
		}
		
		/*
		 * 클라이언트가 요청을 보내야 통신이 시작이니까 클라이언트-서버 모델
		 * 선생님은 서버-클라이언트 모델이라고 하고싶으시대요
		 * 
		 * Client - Server Model
		 * 
		 * 현재 구동중인 서버가 존재하다면 클라이언트는 언제든 서버로 요청을 보낼 수 있음(서버 특 : 클라이언트가 요청 보내면 무조건 응답을 해줘야함)
		 * => 무조건 응답 결과를 돌려 주어야함
		 * 
		 * 우리도 나중에 우리가 만든 프로그램에서 웹서버에서 돌려야함, 웹서버는 만들어져있는걸 쓸거임
		 * 백엔드도 마찬가지(백엔드 서버에서 돌릴거고, 백엔드 서버는 만들어진거 쓸거임) --> 이거도 자바로 만들어짐
		 * 
		 * "요청(request)"과 "응답(response)"으로 프로그램이 동작(통신)함
		 * 클라이언트가 요청하면 서버가 응답하는 방식으로(영상, 웹, 게임 등)
		 * 
		 * 조금 헷갈릴 수 있는 개념의 예 : 카카오톡의 경우에, 데이터 전송이 목적인 프로그램
		 * 철수와 영희가 있음, 철수가 하이 --> 데이터 전송 --> 영희한테 바로 가는게 아님 --> 철수와 영희 모두 클라이언트임, 일반적으로 사용하는 프로그램은 클라이언트에서 클라이언트로 바로 갈 수 없음
		 * 클라이언트-서버 모델이기 때문에 철수의 하이는 카카오톡 서버가 받음 --> 서버가 연산을 함(철수가 누구한테 보내는거지? 영희한테 보내는거네? 영희가 없을수도 있고 이상한 데이터가 왔을수도 있고) --> 클라이언트가 영희한테 하이 보내줘 하고 요청한것임!
		 * --> 영희한테 갈 수 있다면 영희한테 보낸것(요청 처리한것임) --> 나한테도 보여야함 --> 서버가 철수와 영희에게 둘 다 응답해줌
		 * 서버가 둘 다 보내는데, 영희는 카톡에 들어가서 볼때까지 모름 --> 항상
* 14:43 서버없이 왔다갔다는 토렌트같은거
		 * 일반적인 실시간으로 되는 모든 것은 로그가 찍히고 있음
		 * 우리는 그중에서도 웹!
		 * 
		 * 웹에서의 통신 방식 : HTTPS(Hyper Text Transfer Protocol Secure)
		 * 현시대의 기본 베이스, 디폴트
		 * 우리는 이걸 신경안쓰고 살지만 네이버에 요청을 보낼 때 https:// 이렇게 붙어있음, 구글에도 붙어있음
		 * 원래 붙여서 가야 웹 통신 요청, 뒤에 포트번호 붙이는거랑 똑같음(443포트로 갈거야 하고 요청 보내는거)
		 * 이거 안붙여도 편하게 이용할 수 있는 이유는 브라우저가 해주기때문, 자기가 알아서 작업해줌
* 하이퍼 텍스트를 전송하기 위한 통신 규약 보안(하이퍼 텍스트는 하이퍼링크가 달린 텍스트)
		 * s는 보안 관련된 내용이 추가된것
* 원래는 클라이언트가 서버로 요청 보낼 때 종단간 통신에서 웹통신은 데이터가 암호화가 안됨, 사이에 연결된 사람은 모두 볼 수 있고 인터넷은 기본적으로 public 환경
* 인터넷에 연결된 모든 사람은 알 수 있다고 생각할 수 있음
		 * http로는 종단간 암호화가 되어있지 않아서 내가 뭐하는지 다 알 수 있음
		 * https는 중간에서는 볼 수 없도록 보안적인 것을 강화한 프로토콜
* 우리는 https로 동작하는 프로그램을 만들건데, 이걸 만들거면 자바 끝나고 DBMS ,JDBC .... 끝나고
* http 하고 또 뭐뭐뭐뭐뭐뭐뭐 배우고 https
		 * 
		 * 순수 자바만을 사용해서 클라이언트와 서버의 간단한 통신 해보기
		 * 우리가 클라이언트 프로그램도 만들고 서버 프로그램도 만들어서 두개의 프로그램 사이에서 데이터를 주고받겠다는 의미
		 * 
		 * 소켓(Socket)
		 * 
		 * Process(프로그램이 메모리에 적재된 상태) 간의 통신을 담당
		 * 
		 */
		
		// 클라이언트-서버 통신을 해볼건데, 필요한 개념이 있음
		// 이건 다른 디바이스들끼리의 통신이 아님, 내 컴퓨터 안에서 도는 프로세스와 프로세스 사이의 통신임
		// 프로그램 두개를 메모리에 올려놓고 그 프로그램들끼리 데이터를 주고받는 구조를 만들 것임
		// 소켓이 필요함! 오늘 할 것은 소켓 프로그래밍
		// 웹에서 채팅 서비스 만들거나, 일대일 상담 서비스같은거 구현할 때 웹소켓이라는 기술을 써서 구현함
		// 그때 다시 이야기하시겠지만 개념은 똑같은것, 나중에 웹소켓 할때의 기반이라고 생각하자!
		// 그냥 소켓만 배워서는 쓸모없음.. 그냥 자바에서만 쓰는것, 웹소켓의 맛보기로 생각하자
		
	}

	// 우리가 자바라는 프로그래밍 언어를 가지고 프로그램을 만드는 작업(프로그래밍)을 함
	// 우리가 만든 결과물을(자바라는 언어를 써서 만든 결과물) 뭐라고 함? 소스코드! 작업해서 만드는거, 결과물
	// 개발자가 만들어놓은 자바라는 언어를 가지고 써놓은 결과물, 확장자가 .java인 파일 안에 적어놓는것 --> 소스코드(Source Code)
	// 개발자를 코더라고도 부름
	// 사람이 쓰고 사람이 알아볼 수 있고 영어로 쓰는 소스코드,, 우리는 자바로 했지만 프로그래밍 언어를 최소 하나 더 배워야함, 아무튼 언어로 만드는 것은 소스코드라고 함
	// 소스코드는 문자열 데이터, 열면 텍스트만 나열되어있음(사람이 문자열로 쓰고, 사람이 문자열로 해석할 수 있고) --> 컴퓨터는 못알아봄(사람이 보는 문자열이라서) --> JVM이라는 가상의 컴퓨터가 알아볼 수 있는 언어로 바꾸는 과정을 컴파일
// 15:10 자바는 (??) 컴파일러 두개가 있음 사람이 써놓은걸 컴퓨터가 알아볼수있도록, 실행가능한 모양으로 바꿈
	// 실행 가능한 모양을 프로그램이라고함
	// 사람이 소스코드를 쓰고, 소스코드를 컴파일하면 그게 프로그램이 되는 것
	// 이클립스는 저장하면 자동으로 컴파일이 이루어짐 컴퓨터가 알아볼 수 있는 컴파일된 형태
	// 컴퓨터는 얘를 알아볼 수 있으니까 실행함, 실행은 얘를 메모리에 올리겠다(적재)는 의미, 메모리에 올라가서 한줄한줄 돌아간다는 의미
	// 메모리에 올라가서 돌아가고 있는 상태를 프로세스라고 함, 프로그램이 돌아가고 있는 상태, 메모리에 올라간 상태
	// 지금 우리는 하나의 프로세스를 가지고 계속 작업했고, 이 안의 실행 흐름도 하나만 만들었음
	// 프로세스가 동작하면서(배운내용토대로생각하면)위에서 아래로 실행흐름이 한개임, 실행흐름을 표현하는 단어는 스레드(thread)
	// 싱글스레드로 작업하고있었음 여러개의 스레드(멀티스레드)환경으로 만들수있음
	// 하나의 흐름 단위를 스레드라고 표현한다.
// 15:13 하나의 프로그램을 만들어서 하나의 프로세스를 동작시켰는데, 이번에는 두개의 프로세스간의 데이터를 주고받는 작업을 할것임
	
// 15:13 전제조건 : 서버가 동작하고 있을 것 --> 서버 프로그램 먼저 작업하자
	// 웹이랑은 다른 소켓통신을 할것임!!
	
}
