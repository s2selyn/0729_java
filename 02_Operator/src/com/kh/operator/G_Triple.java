package com.kh.operator;

import java.util.Scanner;

public class G_Triple {
	
	/*
	 * 삼항 연산자 : 피 연산자가 3개 => 값 3개와 1개의 연산자로 이루어짐(보통 조건문의 형식으로 쓰임)
	 * 
	 * 조건문 : 값에 따라 연산을 처리하는 방식
	 * 		  결과값이 true일 경우 첫 번째 문장을 처리~~~
	 * 		  결과값이 false일 경우 두 번째 문장을 처리~~~
	 * 조건에 따라서 여러개의 문장을 쓰겠다는 뜻
	 * 
	 * [ 표현식 ]
	 * 조건식 ? 조건식이 true일 경우 결과값 : 조건식이 false일 경우 결과값
	 * 
	 */

	// 원섬후레이스
	public void method1() {
		
		// 앞에서 못했던 것들을 많이 할 수 있게 됨!
		// 앞에 했던 것들을 진화시켜보자!
		System.out.println("시즌 메뉴판 : ");
		System.out.println("1. 더 멜론 오브 멜론 프라푸치노");
		System.out.println("2. 자몽 망고 코코 프라푸치노");
		System.out.println("3. 카페 브륄레 프라푸치노");
		
		// 중간점검 해봐야지~ 메인 메서드로 갔다옵시다
		
		// 메뉴번호 가지고 주문받기
		// 스캐너 쓸까? 이제 import 졸업해야지
		// import 타이핑 하지 않고 하는 방법은 스캐너에 마우스 커서를 갖다대면 뜨는 팝업에서 import 선택
		// 또는 Ctrl + Shift + 알파벳 o를 누르면 바로 됨(import 자동완성 단축키)
		Scanner sc = new Scanner(System.in);
		
		System.out.print("메뉴 번호를 입력해주세요 > ");
		int menuNo = sc.nextInt();
		
		// String selectedMenu = (menuNo == 1) // 조건식
							// ? "더 멜론 오브 멜론 프라푸치노를 주문하셨습니다." // 입력한 메뉴 번호가 1번이면
							// : "1번 아닌거 시킴"; // 입력한 메뉴 번호가 1번이 아니면
		// 조건식 ? 조건식이 true일 경우 결과 값 : 조건식이 false일 경우 결과 값
		// 조건식은 항상 비교연산자를 통해 만듦, 비교연산자의 결과는 참 또는 거짓
		// menuNo가 1과 같다면 "더 멜론 오브 멜론 프라푸치노를 주문하셨습니다."
		// menuNo가 1과 같지 않다면 "1번 아닌거 시킴"
		
		// System.out.println(selectedMenu); // 여기까지 하고 중간점검해봄
		
		// 흐름 읽기
		// 메인 메서드로 진입
		// 메서드를 호출한다는 것은 어떤 의미일까?
		// 메인 메서드로 진입한다는 것은 프로그램을 실행시킨다는 의미
		// 프로그램을 실행시키면 컴퓨터에서는 무슨 일이 일어날까?
		// 저장장치에 값을 올려서 연산을 함
		// 현실 세계의 연산을 하려고 해도 종이가 있고 펜이 있어야 적으면서 연산을 함
		// 저장장치가 없으면 연산을 하기 힘듦, 기록한 내용을 가지고 연산함
		// 컴퓨터도 저장장치에 적재함(값을 올리는 것)
		// 프로그램을 실행한다는 것의 의미는?
		// 우리가 만든 소스코드는 아무 의미 없는 문자열, 사람이 컴퓨터에게 내리고 싶은 명령을 사람의 언어를 사용해서 작성한 것(개발자가 만든 명령어의 집합)
		// 컴퓨터는 소스코드를 봐도 이해할 수 없어서 못돌림 --> 컴퓨터가 이해할 수 있는 언어로 변환하는 과정 : 컴파일
		// 컴파일러가 컴파일을 해줌
		// 자바는 바이트코드로 변환됨
		// JVM설명을 안하셨음
		// 컴퓨터가 동작시킬수 있는 소스코드의 변환집을 프로그램이라고 부름(소스코드를 컴퓨터가 실행할 수 있는 형태로 변환한 것 = 프로그램)
		// 프로그램도 아무 의미가 없음.. 어플리케이션도.. 받아만 놓으면 아무 의미 없음
		// 실행부터 설명하고싶다
		// 프로그램을 실행하면 메인 메서드의 스코프로 진입함 = 이것은 실제로는 메모리상에 올라가는 것
		// 메모리상에 올라가면 위에서부터 아래로 읽으면서 수행하는데...
		// 프로그램이 메모리상에 올라가있는 상태를 프로세스라고 표현함
		// 메인 메서드도 결국은 메서드이므로 메모리에 올라가있어야 함
		// 메인 메서드와 메인 메서드가 아닌 것을 구분해서 만들고 있음
		// 메모리 영역을 2개로 나누어서 설명해보자, 각각의 영역에 이름을 붙일건데, 왼쪽은 static 영역, 오른쪽은 stack 영역
		// 메인 메서드는 static 영역에 올라가서 동작함, 메서드 선언부부터 static이 붙어있음
		// 메인 메서드에서 호출하는 다른 메서드(메인이 아닌 메서드)는 stack 영역으로 올라감
		// 메서드들은 호출될때마다 아래에서 위로 쌓임
		// 계속 쌓이다보면 메모리가 부족해질 수 있음
		// 운영체제도 있고 이것저것 켜서 프로세스를 많이 올려둠
		// 저장공간은 모두가 나눠쓰는 공간임, 여러개의 프로세스들이 공관을 나눠쓰게됨
		// 메서드는 호출되는 시점에 stack 영역에 적재가 됨
		// 메뉴판 출력문 수행, Scanner 별명 붙이고 생성
		// 변수 선언부를 만나면 메서드가 받아둔 stack의 영역 안에 menuNo라는 공간을 하나 생성함
		// Scanner에 의해 받아온 입력버퍼에 있는 정수형 리터럴 값을 menuNo 공간에 대입함
		// String 변수 선언을 만나면 selectedMenu 공간을 만들었음
		// (menuNo == 1) ? 을 만남, menuNo 가 1과 같니? -> t/f로 나옴
		// :을 기준으로 같으면 왼쪽, 안 같으면 오른쪽
		// 대입 연산자 기준으로 오른쪽이므로 값이 되어야 함, 이 값이 왼쪽(selectedMenu)에 대입됨
		// 선택한 번호에 따라서 메뉴명을 출력
		// 1번 입력 시 == "더 멜론 오브 멜론 프라푸치노를 주문하셨습니다."
		// 메소드 블럭이 끝나면 나를 부른 곳으로 돌아감
		// stack은 모두가 사용하는 소중한 공간이므로 stack에 올라가 있던 메모리들은 다 방을 빼버림!
		
		// 보통 삼항연산자에서는 거짓일 경우에 다른 값을 쓰는 것이 아니라 삼항연산자를 또 사용함
		String selectedMenu = (menuNo == 1) // 조건식
							? "더 멜론 오브 멜론 프라푸치노를 주문하셨습니다." // 입력한 메뉴 번호가 1번이면
							: (menuNo == 2) ? "자몽 망고 코코 프라푸치노를 주문하셨습니다." // 입력한 메뉴가 2번이면
							: (menuNo == 3) ? "카페 브륄레 프라푸치노를 주문하셨습니다." // 입력한 메뉴가 3번이면
							: "없는 메뉴를 주문하셨습니다."; // 1도 2도 3도 아니면
		
		System.out.println(selectedMenu);
		
	} // 다 해봤으면 메인 메서드 가서 호출한 부분 주석처리
	
	// 홀짝 구하기
	public void method2() {
		
		// 사용자에게 정수 값을 하나 입력받아서
		// 입력받은 정수가 홀 / 짝 판별해서 출력
		
		// 입력도구 별칭 짓기
		Scanner sc = new Scanner(System.in);
		
		// 필요한 값을 입력받을 수 있도록 메시지 출력 --> 출력문 작성
		System.out.print("숫자를 입력해주세요 > ");
		
		// 사용자로부터 입력받은 값을 연산해야하므로 저장해야 함 --> 변수 선언, 정수를 넣을 거니까 int 타입
		// 정수형 변수를 선언한 뒤 스캐너의 메소드를 호출해서 입력 버퍼에 있는 정수값을 받아와서
		// 정수형 변수 공간에 초기화(변수에 처음으로 값을 대입하는 것)
		int num = sc.nextInt();
		
		// 모범시민! 착하게 살아야해
		// System.out.println("착하게 사는법 : 변수값 찍어보기 > " + num);
		// 메인 메서드에 가서 호출하고 실행해보기, 해봤으면 주석처리
		
		// 입력받은 정수가 홀 / 짝인지 판별하기 위해서 연산해보기
		// 1. num % 2 != 0 홀
		// 2. num % 2 == 1 홀
		// 3. num % 2 == 0 짝 ==> 연산(판별)은 요걸하기로 결정
		// 왜 이렇게 방법이 많을까?
		// ((num % 2) == 0) 이것으로 연산하면 최종 연산이 동등비교이므로 true / false로 나옴
		// 같으면 짝수에요! 안같으면 홀수에요! 라고 출력하고 싶으니까
		// 이 때 쓸 수 있는 방법 중의 하나가 삼항연산자
		char oddEven = ((num % 2) == 0) ? '짝' : '홀';
		
		System.out.println("입력하신 " + num + "은(는) " + oddEven + "수 입니다.");
		
	}
	
	public void upOrLow() {
		
		// 일단 입력받기
		Scanner sc = new Scanner(System.in);
		
		// 알파벳을 입력하세요 서비스 메세지 출력
		System.out.print("알파벳을 한 글자 입력하세요 > ");
		
		// 입력할 수 있는 환경
		char yourLetter = sc.nextLine().charAt(0);
		
		// 알파벳 일단 출력해보기(모범시민)
		// System.out.println(yourLetter);
		
		// 알파벳이 소문자인지 대문자인지 판별하는 연산
		
		// (65 <= yourLetter) && (yourLetter <= 90)
		// 대문자 코드 65~90
				
		// 판별결과가 담길 변수 선언과 연산
		// String yourLetterIs = ((65 <= yourLetter) && (yourLetter <= 90)) ? "대문자" : "소문자" ;
		
		// 출력형식
		// System.out.println(yourLetter + "은(는) " + yourLetterIs + "입니다.");
		
		// 근데 char는 연산하면 int로 자동으로 바뀌지 않나?
		// ('A' <= yourLetter) && (yourLetter <= 'Z')로 바꿔봄
		String yourLetterWas = (('A' <= yourLetter) && (yourLetter <= 'Z')) ? "대문자" : "소문자" ;
		System.out.println(yourLetter + "은(는) " + yourLetterWas + "입니다.");
		
	}
	
	public void 메소드명알아서정하기() {
		
		// 사용자에게 알파벳 한 글자를 입력받아서
		// 스캐너는 무조건 있어야 함
		// 한글자만 받아야 함
		Scanner sc = new Scanner(System.in);
		System.out.print("한 글자만!!!!!주쎄용 > ");
		char ch = sc.nextLine().charAt(0);
		// System.out.println(ch);
		
		// ch == 'a' ~~~~~~ 'z' || 'A' ~~~~~~ 'Z'
		// char형이기 때문에 어차피 연산하면 int로 바꿔서 연산하게 될 것임
		// 'a' <= ch <= 'z' == 소문자
		
		char result = ('a' <= ch) && (ch <= 'z') ? '소' : '대';
		// 입력받은 알파벳이 소문자인지 / 대문자인지 판별 후 출력해주세요.
		System.out.println(ch + "는 " + result + "문자 입니다.");
		
		// 출력형식
		// XXX(사용자가 입력한 알파벳)은(는) 소문자 / 대문자입니다.
		
	}
	
}
