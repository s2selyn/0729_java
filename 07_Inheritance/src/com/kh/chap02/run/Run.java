package com.kh.chap02.run;

import com.kh.chap02.model.vo.ItalyFood;
import com.kh.chap02.model.vo.JapanFood;
import com.kh.chap02.model.vo.KoreaFood;

public class Run {

	public static void main(String[] args) {
		
		// 챕터1에서 클래스에 중복되는 부분들이 있었음 --> 중복되는 것들을 클래스 하나로 빼보자
		// 상속은 보통 has-a 관계라고 이야기함, 묶을 수 있는 추상적인 상위개념을 생각하는게 좋다
		// 식품 삼총사의 공통점은? Food라고 표현해보자 --> 각각 Food에 포함된다! --> 상속으로 구현할 수 있겠따! 라고 생각
		// 클래스 이름 Food라고 하나 만들자
		
		KoreaFood kf = new KoreaFood(); // import 할때 주의!
		kf.setFoodName("비빔밥");
		
		// KoreaFood 객체의 foodName 필드값 출력하고싶다 --> 출력문 쓰고 --> 객체의 주소 찾아가야함 kf, .로 참조해서 getFoodName() getter호출
		System.out.println(kf.getFoodName());
		// KoreaFood 클래스에는 setFoodName,getFoodName이 없음, foodName필드도 없음, 그래도 잘 동작함
		// 이 메소드들은 Food 클래스가 가지고있음 --> Food 클래스가 가진 메소드를 호출하기 위해서 전제조건은? Food 객체가 heap 메모리에 올라와있어야함
		
		// 무슨 일이 일어나는지 그려보자~
		/*
		 * [	KoreaFood kf = new KoreaFood(); 에서 일어나는 일	]
		 * 1. stack에 먼저 kf라는 이름의 변수공간이 생김
		 * 2. heap 영역에 객체가 올라감 무슨모양으로? 어떻게 생긴애가? KoreaFood 생성자를 호출해서 얘를 올림 --> 지금 기본생성자로 만들어뒀음 --> 근데 여기에 추가로 상속이라는 친구가 붙어있음
		 * KoreaFood는 지금 자식클래스 --> 자식이 되기 위한 전제는? 필요한것은? --> 부모가 있어야 자식이 됨! 부모가 먼저 태어나야 자식이 태어남
		 * --> 자식 클래스가 올라갈 때, 출력문을 하나 작성하고옴 --> 생성자 호출했으니 생성자 호출 구문에서 우리가 만든 출력문이 출력됨
		 * --> Food 클래스에 가서 Food 클래스의 기본생성자에 출력문 추가 --> 실행하면 부모클래스 생성자에 작성한 출력문이 먼저 실행되고, 자식클래스에 있는 출력문이 출력됨
		 * --> 따로 작성하지는 않았지만 KoreaFood의 기본생성자를 호출하면 --> KoreaFood 객체가 올라가기 전에 먼저 부모클래스의 객체가 생성된다, 부모가 있어야 자식이 생겨날 수 있음 
		 * --> 먼저 부모클래스의 객체가 생성된것 --> KoreaFood의 기본생성자 내부에도 생략되어있음 --> super();
		 * KoreaFood 객체가 heap에 올라가서 객체생성되기 전에 부모(Food)가 먼저 heap 메모리에 객체로 생성된것 --> 부모에게 자식이 상속을 받은 형태, 부모의 주소값을 가리키고 있음 --> 부모 생기고 자식 생기고 -->
		 * 3. 자식의 주소값이 kf에 대입됨
		 * 자식이 생겨나려면 부모가 먼저 올라가야함, 부모객체가 먼저 생겨나야 부모객체 다음에 자식클래스가 생겨날수있음
		 * 
		 * [	kf.setFoodName("비빔밥"); 에서 일어나는 일	]
		 * kf에 들어가있는 주소를 참조해서 KoreaFood객체로감 --> setFoodName이라는 메소드를 호출함 --> 자식객체에 이 메소드는 없음 --> 부모객체로 올라가서 찾음 --> 부모객체에는 setFoodName 메소드가 있음
		 * --> 부모의 필드에 값을 대입함("비빔밥") --> 메소드에 커서얹고 F2 눌러보면 void com.kh.chap02.model.vo.Food.setFoodName (String foodName) 라고 뜸 --> 부모객체에 가서 찾은것임
		 * 
		 */
		
		// 호출을 하는 메소드가 해당 클래스에 존재하지 않는다면
		// 자동으로 해당 클래스의 부모클래스에 있는 메소드를 호출
		
		// 이탈리아 음식도 올려보자
		ItalyFood yf = new ItalyFood("기름파스타", "기름", 15, 5); // import 주의
		// 인자값 전달해서 초기화해보자
		// 값 네개를 객체의 필드에 담아줄건데, 지금 빨간줄 생김! 여기서 호출하는 생성자는 매개변수가 String String int int인생성자를 부르고있음 --> 가서 만들어야함
		// yf.foodName = "여기서도"; // 부모클래스의 접근제한자를 public으로 바꾸면 여기서도 부를 수 있음
		System.out.println(yf.information()); // 이태리푸드에 이 메소드는 없다, 부모클래스의 information을 호출함
		// 어? 내가가진(이태리푸드가 가진) 필드는 출력이 안됨..ㅠ --> 음식명 : 기름파스타, 주재료 : 기름, 조리시간 : 15 --> 라고 출력됐음
		// 물려준거 마음에 안들면 바꿔야함 --> 염색하러가자, JapanFood 클래스로 ㄱㄱ
		
		JapanFood jf = new JapanFood("스시", "밥", 20, 5); // import 주의
		System.out.println(jf.information()); // --> 신선도 안나옴, 아 신선도까지 출력해주고싶다!
		
		// yf, jf 둘다 information을 호출함
		// 이태리푸드 객체 생기고, 일식 객체도 생김 --> 부모 객체도 각각 생겼을것임
		// 이태리는 자식클래스에 인포메소드가 없어서 부모객체로 가서 인포를 호출함
		// 일식 자식클래스는 새로 인포메소드를 만들어줌(재정의) --> jf에 가서 info 호출하니 자식에 있음! --> 자식클래스에 존재하는게 우선순위가 높음! 자식클래스에서 먼저 찾아보고 없으면 부모클래스로 감
		
		// 자식클래스에 메소드를 재정의 했을 경우
		// 자식클래스에 존재하는 메소드가 우선권을 가져서 호출됨! ☆★☆★☆★☆★☆★☆★
		
		/*
		 * 누군가 상속이 뭐냐고 물어본다면? --> 기존의 클래스를 이용해서 새로운 클래스를 만드는 기술!
		 * 기존거를 이용안하면 똑같이만드는건 의미없음, 지금단계에서 느끼기에 기존것을 이용하니까(상속하니까) 어떤점이 좋아? 중복이 줄어들었당
		 * 
		 * 상속
		 * 
		 * - 중복된 코드를 공통으로 관리
		 * => 보다 적은양의 코드로 새로운 클래스를 만들 수 있음
		 * 
		 * => 생산성 향상(적은 시간에 많이 만들 수 있음!), 가독성 향상
		 * 원래라면 클래스별로 필드와 메소드를 봐야하는데, 부모클래스만 봐도 한번에 자식클래스가 가진 멤버 전부 파악가능
		 * 공통으로 들어가야 할 필드나 메소드가 있다면 부모클래스에만 추가하면됨 --> 자식클래스에 알아서 상속돼서 사용할 수 있게됨 --> 장점이라기보다는 단점에 가까움!
		 * 
		 * 상속의 단점은 명확함! 결합도가 높아진다!
		 * 
		 * 객체지향에서는 관점이 중요하다고 했음(내부적/외부적 관점)
		 * 상속이라는것은? 부모에 대한것은 자식이 전부 알고있음 --> 외부에서 모두 활용하고 쓰고 관리할수있음
		 * 부모에 있던 내용이 수정되면? 생성자가 사라진다면? 상속받고있던 나머지 친구들(호출하던것들) 전부 영향받음 --> 부모것을 사용하고 있었으므로(자식클래스는 부모클래스를 너무 잘알고있었음)
		 * 
		 * 객체간의 결합도가 높아짐(옛날에는 상속이 객체지향의 꽃이라고 표현했지만, 만들때는 문제가 없음 --> 수정하고 고치고 유지보수할때 문제가 생김)
		 * 부모클래스를 고치면 자식클래스가 전부 영향을 받음!
		 * 
		 * 옛날에는 많이 썼는데 지금은 한물감^^! 자버지(제임스 고슬링)가 자바 만들긴 만들었는데 상속은 잘못 만든 것 같애 라고 했다네요
		 * 근데 중요함, 과거에 객체지향의 꽃이었으니까, 현재 객체지향의 꽃(합성)을 구현하려면 전제조건이 상속이기때문에 상속을 모르면 쓸 수 없음
		 * 상속을 구현해서 쓰지는 않음, 우리도 안씀(쓸 상황은 있었다, 리모콘 만들때 RV에서 RC를 상속받으면 다 활용할수있었다 --> 근데 그러면 RC수정될때 RV도 수정되어야함 --> 필드로 두고 호출해서 썼음 --> 이게 Composition!)
		 * 
		 * 상속의 특징
		 * 
		 * - 클래스간의 다중상속은 불가능하다(단일 상속만 가능, 되는 친구도 있는데 자바는 안되게 막음) --> 자식이 부모를 두개? 어느것을 참조하는지 알수없게됨
		 * 
		 * - 명시되어있지는 않지만 모든 클래스는 Object클래스의 후손클래스
		 * 	 (내가 만든 클래스, 자바에서 원래 제공하는 클래스 전부!)
		 * 
		 * => Object클래스에 있는 멤버를 사용할 수 있음
		 * => Object클래스에 있는 메소드가 마음에 안든다면 재정의를 할 수 있음 --> 이 두개를 들고 chap03으로 넘어가자!
		 * 
		 */
		
		// jf. 하면 나한테 없는 부모클래스의 메소드가 보임 --> JF에도 안만들어놓고 Food에도 안만든 메소드들이 같이 보임 --> 얘네는 접근해서 왜 사용할 수 있대? --> 기본적으로 모든 클래스는 생략된 것이 있음 --> extends Object
		// --> extends를 안붙인것은 자동으로 extends Object가 붙어있음 --> 모든 객체는 Object클래스가 가지고있는 멤버를 사용할 수 있다!
		// 상속은 한단계로만 상속되어있지않음 --> 자식의 자식의 자식의 자식의... --> 두단계 이상이면 조상/후손으로 표현
		
	}

}
