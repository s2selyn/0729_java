package com.kh.chap07.remote.view;

import java.util.Scanner;

import com.kh.chap07.remote.controller.RemoteController;

	// 사용자에게 값을 입력받고 내용을 출력해주는 메소드들을 넣어둘 클래스
public class RemoteView {
	
	private Scanner sc = new Scanner(System.in);
	// 스캐너를 필드로 두자. 클래스 블록에 선언해서 필드로 만들어서 이 클래스 안에서 전부 사용할 수 있는 것으로 만들어보자
	
	private RemoteController rc = new RemoteController(); // 여기 들어가야(필드로 선언한것임) 프로그램 시작부터 끝날때까지 쓸 수 있음
	// 프로그램 실행과 동시에 생겨남 RemoteView view = new RemoteView();의 우항에서 시작되어 줄줄이 Array까지 전부 생성됨, RV가 죽기전까지 다같이 살아있음!
	// 언제 죽냐면 메인 메소드에서 만들었기 때문에 프로그램 종료되면!
	
	// 메소드를 만들어서 메인화면출력하도록 만들어주기
	// 여기 만들거지만 Run에서 부를거임, 접근제한자 public
	// 프로그램 시작 시 보여질 메인메뉴를 출력해주는 메소드
	// 연산, 값을 받아서 계산하는게 아니고 단순히 출력만 --> 반환타입은 void
	public void mainMenu() {
		// 컨트롤러에 메소드를 만들어놓고, 여기서는 컨트롤러에 만들어놓은 메소드를 호출할것이므로 컨트롤러 객체를 이안에서 생성할것임
		// 컨트롤러 선언, 호출해서 돌릴것 --> 이 메소드 안에서 RC 선언하고 객체 생성하고, while문 안에서 메소드 불러서 작업해도 되기는 하지만, 그렇게 하면 switch문 안에 작업하는 라인이 늘어남
		// 메뉴를 선택했을 때, switch문 안에서 코드를 작성해서 뭐 하지는 않고, 선택하면 나오는 화면도 메소드로 따로 분리하려고함
		// 원래라면 사용자가 1을 입력했다면 case 1에 출력문도 썼고 입력도 받았을것임
		// 1을 입력했을 때 출력해주는 메소드를 만들어서, 그것을 호출해서 출력하도록 하자! --> powerOn 만들기
		
		while(true) {
			
			// 출력문, 프로그램 시작하면 보여줄 내용
			System.out.println("리모콘 조작 프로그램입니다.");
			System.out.println("이렇게 저렇게 조작을 열심히 해보세요.");
			System.out.println("이용하실 메뉴를 선택해주세요.");
			System.out.println("1. 전원켜기");
			System.out.println("2. 채널 바꾸기 ↑");
			System.out.println("3. 채널 바꾸기 ↓");
			System.out.println("4. 전원끄기");
			System.out.println("5. 프로그램 종료"); // 프로그램 종료의 의미는 지금우리로 따지면 메인 메소드의 블록 끝에 오면 끝나는거니까(메모리 상에서 사라지는것)
			// 5를 입력했다면 우리가 해줄 일은 일단 메인 메소드 블록 끝으로 돌려보내야함
			// 방법 1. while문 밖으로 나가면 됨, while문이 계속 반복하고 있으니까(끝나면 위로 다시 올라감), 근데 while문 바깥으로 나가면 메소드 블록 끝이니까 return 만나서 돌아갈것임 --> 보내야 반복이 끝남, 메인메뉴에 실제로는 존재하고 있는 return을 만나서 돌아감 --> 지금 코드는 해결이 안됨
			// case 5에서 while문 밖으로 나가려면? --> 지금 코드로는 해결이 안됨, 변수같은게 하나 더 있어야함, case 5에 있는 break는 switch만 나감(while문 나갈때도 switch문 나갈때도 break를 쓰는데, 여기서는 switch문 나가는 break이므로 끝나면 다시 while문 스코프 시작으로 올라감)
			// 우리는 while문 밖으로 내보내야 하니까 방법 2. 나 부른 곳으로 돌려보내는 방법
			// 종료되는거 알려주고 끝내고 싶음 --> 돌아가서 종료되는거 알려줘도됨(서비스메세지) --> 돌아가면 서비스 메세지 출력하고 메인 메소드 끝나서 종료될것임. 근데 출력해주는 코드는 출력해주는 클래스에 모아놓고싶음 --> case 5의 return문 앞에 출력문 작성
			// 출력해주는게 많을텐데 여기저기 클래스에 넣으면 출력해야되는 내용이 바뀌었을 때 내가 클래스들을 찾아가서 바꿔야함 --> 하나에 몰아놓으면? 입력을 받는거라든지 출력을 받아야하는거라든가 --> 이걸 몰아넣어서 해주는 클래스에 가면 찾아서 수정할 수 있음(그래서 출력해주는 클래스 바깥에 쓰고싶지않음) --> 유지보수를 위해서
			// 출력하는 건 이 클래스에서 하고 돌아가는 건 바뀌는 게 없음
			
			// 사용자가 입력한 것에 따라서 켜지고 꺼지고 채널도 바뀌고 해야함
			// 채널을 바꾸면 최소한 뭐가 나오는지 정도는 출력해주고싶음
			// 전원이 꺼져있는데 채널을 올리고내리고 되면 안됨, 올리고내리고는 전원이 켜져있을때만 이용할 수 있어야함, 채널 올리면 몇 번 채널인지도 나와야하고
			// 이런것들을 수행할 때 필요한 값들을 저장할 클래스를 하나 더 생성 --> model.vo.Television
			
			// 스캐너 선언, import하고와서
			System.out.print("어떤 기능을 이용하시겠습니까 > ");
			int menuNo = sc.nextInt(); // 정수값을 입력받겠다, 정수 받을거니까 nextInt, int형 변수에 담아뒀음
			sc.nextLine(); // 입력버퍼 비워주기용 호출
			
			// 사용자가 입력한 번호에 따라 각각 다른 기능을 수행시키고 싶음
			// 몇번을 입력했을때 --> 조건 --> if 아니면 switch --> 비교할 대상(피연산자 2개)은 정수와 정수(menuNo에서 정수로 받음) --> 각각의 정수들과 비교할 방법은 동등비교 --> if도 좋지만 switch는 동등비교연산자를 안써도되니 이게낫겠다
			switch(menuNo) {
			case 1 : powerOn(); break;
			case 2 : channelUp(); break; // 채널올리기(0인데 1번채널가기), 켜면 0이 기본채널이라고 가정하자
			case 3 : break;
			case 4 : break;
			case 5 : System.out.println("리모콘 조작하기는 즐거우셨나요? 안녕히가세요."); return; // 어떻게하면 프로그램 종료시킬 수 있음?
			default : System.out.println("없는 메뉴를 선택하셨습니다. 다시 입력해주세요."); // 1, 2, 3, 4, 5, 다 아니고 이상한 걸 눌렀으면?
			}
			
			// 메인 메소드에서 이 메소드를 호출했을 때 출력문이 출력됨 --> 출력이 끝나고 나면? 안보이지만 return이 있음, 돌아가면 뭐 없어서 끝남
			// 켜져있어야 이것저것 조작가능, 한번 동작하고 끝나는 게 아니라 뭔가메뉴를 이용할수있고 반복하게 해주고싶다 프로그램 종료하기 전까지 --> 출력문들을 종료하기 전까지는 계속 반복하게 해주고싶다면? while로 감싸기
			// 반복해서 출력하고싶은게 아니라 메뉴를 선택하고 이용하고싶음 --> 스캐너를 필드로 선언하러 올라감
			
		}
		
	} // 프로그램 시작하면 이것들이 출력되게 하고싶으니 Run 클래스로가자
	
	// 안에서만 쓸거니까 접근제한자 private으로 선언, 밖에서 볼 필요 없음
	private void powerOn() {
		
		// RemoteController rc = new RemoteController(); // <-- 생성하고 rc.powerOn();으로 차이점 확인하러감
		// 이러면 메소드가 끝났을때 객체가 줄줄이 다 죽어버림, 메소드가 끝나더라도 컨트롤러가 계속 살아있게하려면? 적어도 얘가 프로그램종료전까지 살아있으려면 어디에 올라가야하는가?
		// 프로그램이 종료된다는 것은 stack이 전부 비워지는 것 --> stack에 쌓인 것들이 사라지기 전까지는 RV와 RV가 가리키는 스캐너는 계속 살아있음 --> 스캐너는 RV가 필드로 갖고있기 때문에 살아있음!
		// 그러므로 RV가 필드로 갖고있으면 stack의 영역에서 메소드가 전부 사라지기전까지 다른애들도 안죽음! --> 스캐너를 필드로 선언한 곳 아래에 RC 생성 선언하러감
		System.out.println("====================");
		System.out.println("전원 켜기 메뉴입니다.");
		System.out.println("====================");
		
		// 전원 켜기를 하면 우리가 해줄 일? TV의 boolean 타입 on값을 true로 바꾸고싶음 --> 이러려면 일단 TV가 생성되어있어야함(메모리에올라가있어야함, 그래야 boolean 타입이 메모리에 있을거고 그것을 변경가능) --> TV 생성은 지금 컨트롤러에서 함, 컨트롤러를 만들어야 컨트롤러의 필드부에 있는 TV가 만들어짐, 컨트롤러를 view에서 먼저 만들어야함, 근데 어디에서 만들어야하는지?
		// 이 메소드 안에서 컨트롤러를 생성하면? 일단 확인해보자 --> 전원 켜기 메뉴입니다. 출력문 덩어리 위에 생성해봄
		// rc.powerOn(); // 아직 안만든 메소드라서 빨간줄생겼음 만들거임 --> 컨트롤러에 메소드 만들러 다녀옴
		// 문제가 있음 --> 메인 메소드 가서 흐름이랑 메모리 그림그림
		
		// 파워온이 가져올 값을 사용하려면 저장할 공간(변수)이 필요함, 1또는 0이 올것임, 뭐가올지는 모르지만 자료형은 아니까 int
		int result = rc.powerOn();
		
		// 조건에 따라 수행할 내용이 2개임 --> if else
		if(result > 0) { // 조건 = TV가 꺼져있었다면? view 내부에서는 확인 불가능, TV 컸는지 껐는지는 RC가 알고있음(자기가 껐다켰다했음) --> 티비 켜고껐을때의 결과를 보내주고싶음 --> return 작성하러감
			System.out.println("전원이 켜졌습니다 축하드립니다!"); // 꺼져있을때는 얘를 보여주고싶고 --> 조건
		} else {
			System.out.println("이미 전원이 켜져있습니다."); // 켜져있을때는 얘를 보여주고싶음 --> 조건
		}
		
		System.out.println();
		System.out.println();
		System.out.println();
		
	}
	
	private void channelUp() {
		
		// 기존 채널에서 +1해서 무슨 방송 나오는지 출력해주자
		// 지금 0번 채널이라면 눌렀을때 1번이 되어야함
		// 1번채널에 뭐있는지는 어디가야알아? --> Array의 1번인덱스(최종목적지) --> 우리는 지금 RV에 있음 --> Array까지 가려면? 줄줄이 호출해서 찾아가야함
		// 컨트롤러야 채널하나 올려줘 그리고 뭐하는지 알려줘 --> 뭐 해달라고 하려면? 주소를 알아야함 --> 주소는 rc에 있음
		// 객체가 다른 객체한테 뭐 해줘 하고싶으면 메소드 호출밖에없음(RV 객체가 RC 객체한테 뭐 해달라고 하고싶은것) --> rc.channelUp(); 객체간의 상호작용
		// rc.channelUp(); // RC에 지금은 없으니까 만들어주고오자
		// 돌아온값을 써먹으려면 변수를 써서 대입(저장)해둬야함
		String channel = rc.channelUp();
		// System.out.println(channel); // 일단 출력해봤음, 근데 무조건 1번채널 보고싶은게 아님
		// 현재 채널보다 하나 +된 채널의 프로그램을 받아서 출력하고싶음 --> 기존 채널이 몇번이었는지에 대한 정보는 어디? 이것도 어딘가에 저장해놔야 +하든 -하든 할수있을것 --> RC의 필드로 선언하러감
		// 다녀와서 상영중인 프로그램 보여주는 출력문 작성함
		// 몇번 채널인지도 보여주고싶음 --> getChannelNo()로 가져옴
		
		if(channel != null) { // TV가 꺼져있었다면 RC가 가진 channelUp 메소드가 null값을 돌려주도록 작성했음
			// channel 값이 돌아왔을때(null이 아닐 때)에만 출력해주고싶음
			
			int channelNo = rc.getChannelNo(); // 1. channelNo를 가져오자 2. 문자열에 합쳐주자
			System.out.println(channelNo + "번 채널입니다."); // RV 입장에서는 몇번 채널인지 모름, 채널이 몇번인지는 누가 아느냐? RC의 필드에 담아뒀음 --> getter가 필요함, 가서 getter 만들어주고옴
			System.out.println("=================================");
			System.out.println("현재 상영중인 프로그램 입니다 : ☆" + channel + "☆");
			System.out.println("=================================");
			
		} else { // null이라면
			System.out.println("먼저 전원을 켜주시기 바랍니다.");
		}
		
		System.out.println();
		
	}
	
}
