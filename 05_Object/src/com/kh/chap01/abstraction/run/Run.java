package com.kh.chap01.abstraction.run;

import com.kh.chap01.abstraction.vo.Puppy;

public class Run {
	
	// 실행합시다! 하고 만드는 것
	public static void main(String[] args) {
		
		// 메인 메소드는 클래스 생성할때 선택해서 넣을수도 있고, 그냥 들어왔다면 mai 정도까지 입력하고 ctrl + space로 띄운 팝업에서 호출할 수 있음
		
		/*
		 * 객체 지향 프로그래밍(Object Oriented Programming, 보편적으로 자바라는 프로그래밍 언어를 배우면서 만나게되는 두번째 통곡의 벽(첫번째는 for문))
		 * 붕어빵틀?
		 * 
		 * 객체 지향 프로그래밍(정의) : 현실세계에서의 독립적인 존재(개체)를 속성과 행위를 (가지도록)가진 객체로 만들어서
		 * 						  객체간의 상호작용을 통해 프로그래밍 하는 기법(보편적으로 이렇게 써있음)
		 * 
		 * 구현하고자 하는 프로그램에 객체를 만들기 위해서는(생성하기 위해서는)
		 * => 클래스를 먼저 생성해야함!
		 * 
		 * 클래스란? 자바에서 클래스는? 각 객체들의 정보(속성, 행위)들을 담아내는 그릇 또는 틀 또는 설계도 또는 명세
		 * 
		 * 지금은 클래스를 강아지가 가질 수 있는 속성을 저장할 용도로 만들었음, 퍼피가 가진 필드들에 현실 세계에서 필요한 강아지의 값들(value)을 넣었음 --> Value Object(값들을 담은 오브젝트, 값을 담는 객체)
		 * --> 강아지의 값을 담는 클래스. new 키워드를 이용해서 강아지 모양의 객체를 만들었음, 사실 heap 영역에 올라가는 강아지 정보를 가지고 있는 데이터 덩어리를 객체라고 함
		 * 
		 * 클래스 : VO(Value Object)
		 * VO 클래스로 만든 것을 VO 객체라고 함
		 * 
		 */
		
		/* 
		 * 오늘의 숙제!
		 * 
		 * 현실세계에 존재하는 나만의 그 무언가를 찾아서
		 * VO클래스를 만들고
		 * PuppyCareRun클래스를 참고하여 생성한 객체를 관리할 수 있는 프로그램을 작성하시오.
		 * 
		 * 개수 ) VO 클래스 5개 + VO관리프로그램 5개
		 * 각 VO클래스의 최소 필드 수 5개
		 * 최소 한 개 이상의 필드 값을 변경할 수 있는 메소드 생성 --> Puppy클래스의 bark()처럼
		 * 
		 * 제출할 곳 : 우리반게시판 게시글 작성
		 * 			 과제 탭을 선택 할 수 있음
		 * 제한시간 : 2025 / 08 / 07 07:59까지
		 * 게시글 제목 : 홍길동 VO클래스 만들기
		 * 
		 * + 메모리구조 그리기(하나만)
		 * 
		 */
		
		/* 
		 * 객체? 지향? 현실세계? 독립적인 존재? 속성? 행위? 객체로 만들다? 상호작용? --> 단어들부터 통곡의 벽(추상적인 개념이라 그렇다)
		 * 
		 * 이론적, 추상적인 내용이지만 단순하게 기술적으로 접근하기(객체를 뭘 지향해,, 독립적인 존재도 어렵고 속성도 어려워잉)
		 * 프로그램은 현실세계의 무언가를 컴퓨터로 하려고 만드는 것, 게임 쇼핑몰 OTT 등
		 * OTT 프로그램이라면? 영상이 핵심일것, 드라마 영화 시트콤, 카테고리가 나뉨, 제목 배우 시간 제작사 등 영상이 가진 속성이 있을거고
		 * 영상으로 할수있는기능들 재생 중지 빨리감기 다시보기 등
		 * 이런것들을 저장하고 하나에 몰아서 관리하려고 함, 값과 정보들을 저장해야하는데? 자바에서는 변수밖에 없음, 변수의 위치는 클래스 스코프에 있는 것 --> 객체가 가질 수 있는 속성이라는 의미에서 필드라고 부름
		 * 행위나 기능은? 어떻게 저장하거나 구현하나? --> 메소드로!
		 * 속성은 변수에 담고 행위는 함수(메소드)에 담아서 두개를 클래스라는 틀을 가지고 new라는 키워드를 이용해서 객체를 만들어 --> 객체는 메모리에 올라간 데이터 덩어리
		 * 객체랑 상호작용하는 방법은 메소드 호출
		 * 다른 언어는 이 속성과 행위를 다른 말로 표현함, 자바에서는 필드와 메소드
		 * 
		 * 기술적인 이야기부터 해보자
		 * 프로그래밍 언어의 역사에 대해서도 이야기해야함
		 * 1950년대에는 전자식 계산기, 컴퓨터라는 것을 처음 생각해낸 아저씨는 앨런 튜링(컴퓨터에 대한 정의를 내린 인물, 개념적인 내용을 정리함)
		 * 앨런 튜링이 정립한 내용을 가지고 폰 노이만이라는 아저씨가 실제로 전자계산기 구조를 만들어냄
		 * 오늘날의 컴퓨터는 전부 폰 노이만 구조로 만들어져있다고 말함(맨날 선생님이 얘기하시는 저장장치에 값을 올리고 + 연산장치에서 연산을 처리하자)
		 * 1920년대임(100년전 정도) 컴퓨터공학, 이론의 역사가 오래된 것은 아님
		 * 최초의 컴퓨터 ABC --> 장치를 만들어내서 사람들이 컴퓨터를 동작시키려면 프로그램이 있어야하네? 기계장치로는 의미가 없네? 하고 프로그램을 만들어내기시작
		 * 우리가 지금 쓰고 있는 자바는 3세대 언어(1세대와 2세대는 기계어와 어셈블리어)
		 * 컴퓨터 개념, 컴퓨터 구조를 만들어낸 사람들은 굉장히 난다긴다하는사람들, 세기의 천재다! 초기에 컴퓨터를 다룬 사람들, 컴퓨터는 고급문화, 그시대의 수학자, 암호학자 이런사람들이 컴퓨터를 다뤘음
		 * 이런 사람들이 프로그램을 만들어낼때, 결국 하드웨어는 성능이 조금씩 계속 발전할수밖에 없음
		 * 하드웨어의 발전에 따라 하드웨어를 조작하는 프로그램의 규모도 계속 커짐 --> 관리하기 어려워짐(프로그램뿐만아니라 세상모든일들도)
		 * 
		 * 문법은 다 쓰잘데기없다. 문법은 쓰다보면 자연스럽게 익혀지는거다.
		 * 코드 작성할 때 생각하고하자. 어떻게 생각하자? 순서대로! 컴퓨터처럼! 컴퓨터가 어떻게 동작하는지, 메모리상에서 무슨 일이 일어나는지 이해하고 생각해라
		 * 인간 컴퓨터가 되세요 --> 초창기에 프로그래밍을 학습하는 방법
		 * 포트란, 코볼, C언어 --> 코드를 이렇게 작성하면 컴퓨터가 이렇게 동작한다 는 식으로 작성함
		 * 
		 * 프로그램 규모가 커지면 관리도 어려워지고, 코드도 다시 쓰기 어려워지고, 데이터랑 함수 분리하기도 어려워지고, 유지보수도 어려워지고
 		 * 똑똑이들이 생각함 --> 컴퓨터는 기계잖아? 그럼 기계를 조작하는 법은 알겠어, 불켜면 앞으로가고 끄면 뒤로가고 이렇게하면 왼쪽으로 가고 이렇게하면 오른쪽으로가네? 이것까진 알겠어
 		 * 근데 이렇게 하다보니 조금 불편한데? 그러면 우리가 컴퓨터처럼 생각해서 프로그램을 만드는게 아니라 우리처럼 똑똑이들이 생각하는것처럼 생각해서 프로그램을 만들어보자, 컴퓨터에 주체를 맞추지말고 사람이 생각하는 대로 한번 프로그램을 만들게 해보자, 왜냐 우리는 똑똑이들이니까~
 		 * 이 이론 자체는 1952년 나옴(논문), 프로그램을 짤때 컴퓨터가 생각하는대로 만들지말고 사람이 생각하는 것 처럼 돌려보면 어떨까? --> 근데 안될것같은데~ 하고 지나다가...
 		 * 이 개념을 접목시켜서 가장 성공한 언어가 자바가 되면서 객체 지향이 떴다!(자바가 최초의 객체 지향 언어는 아님)
 		 * 자바가 객체 지향을 도입함으로써 굉장히 많은 절차 지향에서 해결하기 어려웠던 일들을 해결하게 됨
 		 * 객체 지항을 함으로써 얻을 수 있는 이점이 뭔데?
 		 * 
		 */
		
		// 어떤 관점에서 객체 지향이 나오게 되었는가?
		// 결국 소프트웨어는 현실 세계의 문제를 해결하기 위해서 만드는 것 --> 계산하고 풀어야하는데 사람이 하기 귀찮으니 소프트웨어를 만들어서 해결
		// 예를 들어서 학사 정보를 저장하는 프로그램이 있다고 치자. 이걸 만들어야겠어!
		// 정보를 저장해놔야 함 --> 누군가의 정보를 저장해야 한다고 가정해보자.
		// 1. 누군가의 이름을 저장하려면? 저장할 공간이 있어야 함, 변수는 선언을 어떻게 해야 함? String, 변수명은 name --> String name = "강병준";
		// 2. 강병준이라는 이름이 다른 여러곳에도 있을 수 있음, 강의실을 같이 저장하고싶음, 공간을 만들어야 함 --> 문자열로 선언, 변수명은 className, value값은 "A강의장" --> String className = "A강의장";
		// 3. 전화번호도 저장해야한다~ 연락해야 할 수 있으니까, 정수로는 안됨(자바에서는 0으로 시작하면 8진수로 계산함), 중간에 대시를 넣으려면 int형일때 빼기연산을 함, 문자열로 받는것이 좋겠다 --> String phoneNumber = "010-2323-2323";
		// 4. 문제가 있음 --> 사람들의 정보를 저장하는 프로그램임 --> 한사람만 있는게 아니라 자연스럽게 출석번호 2번도 필요함 --> 똑같이 이름, 강의실, 전화번호를 저장해야 함
		// 5. 이름은 문자열(String)로 선언, 변수명은? name2 = "강현성";
		// 6. className 못쓰네요? className2 = "A강의장";
		// 7. 이런식이면 전화번호도 자연스럽게 String phoneNumber2 = "010-4444-5555";
		// 8. 출석번호 3번은요? String name3 = "김윤기"; String className3 = "A강의장"; String phoneNumber3 = "010-2222-6666";
		// 고작 세명, 한사람당 세개의 정보인데 변수가 9개 필요함, 우리반이 23명인것만 따지면 69개 변수가 필요함
		// 우리반만 있는게 아님, 여러반이 있음, KH가 여러군데 있음, 게임학원도 있고 영상제작학원도 있고 부산에도 학원이 있고... 필요한 변수가 도대체 몇개임
		// 기술적 관점에서 감당이 안됨, 1년에 개발에서만 1800명이 수료함, 이름 생년월일 주소지 이메일 이런거 다 쓰는데 어떻게해...?
		// 하면 해.. 돈주면 해야지.. 일단 변수명도 굉장히 마음에 안들고, 변수명을 보고 이사람이 누군지 알수도 없음
		// 이 문제를 해결하고싶으면 어떻게해야함? 배열을 배웠음! 배열은 동일한 자료형들 끼리는 하나의 배열에 담을 수 있음
		// 세명이 필요하면 names라는 배열을 만들어서 String[] names = {"강병준", "강현성", "김윤기"};
		// 클래스는 String[] classes = {"A강의장", "A강의장", "A강의장"};
		// 전화번호도 String[] phoneNumbers = {"010-2323-2323", "010-4444-5555", "010-2222-6666"};
		// 배열을 썼더니 변수 1800개 필요한 시절보다는 나아졌다
		// 문제 1. 이렇게 가다보니 배열은 크기가 고정되어있음 --> 새로운 요소를 추가하려면? 깊은 복사
		// 문제 2. 정보를 지워야 할 경우 --> 요소를 지우면 남은 데이터를 한칸씩 옮겨야함 --> 중간에 끼워넣어야 하는 경우에는? --> 새로 복사해서 수정?
		// 문제 3. 누군가의 정보가 필요함 --> 누군가가 배열의 몇번 인덱스에 들어있는지 알아야 함 --> 모두의 인덱스를 알아야 함 --> 배열이 수정될때마다 인덱스 번호는 계속 달라짐
		// 문제 4. 한 사람의 정보를 인식할 때는 전체의 이름만 모아둔 배열로 인식하는게 아님 --> 배열은 컴퓨터에 저장하는 용도로 만들어둠
		// 배열만으로는 해결이 안되는 문제점들이 있음
		
		// 대표적으로 C언어는 이 문제를 해결하기 위해서 구조체라는 개념을 만들었음 --> 데이터를 사람의 정보라고 생각할때 한 사람에 대해서 생각하니까 구조체를 만들어서 그 안에 사람의 이름을 담을 수 있는 공간, 사람의 반을 담을 수 있는 공간, 사람의 전화번호를 담을 수 있는 공간을 만들어서 관리하자!
		// 프로그램이 값만으로 이루어지지는 않음
		// 학원에 오면 출석, 퇴실을 해야함 --> 프로그램의 기능들을 함수라는 이름을 붙임 --> 입실하기() 퇴실하기() 등을 만들어서 구조체와 섞어서 썼음
		// 날이 갈수록 할수있는것들이 늘어남 --> 입실의 방법도 여러개, 퇴실의 방법도 여러개
		// 입퇴실 체크기능, 휴가기능 등 함수들도 많아짐
		// 기능을 사용할 수 있는 사람들도 다름 --> 구조체와 함수를 엮기 힘들다 --> 여기까지 C언어 이야기
		
		// 그래서 하나로 합치면 어떨까? 정보 + 정보가 사용할 수 있는 기능 --> 이러면 관리하기 훨씬 편하지않아?
		// 결국 소프트웨어로 해야 할 일은 정보를 가지고 연산을 수행하고.. 원래는 정보따로 기능따로 사용했는데 하나로 묶어버리자
		// 이렇게 개념이 나옴
		// 묶은 것을 뭐라고 부를까? --> 자바에서는 클래스
		
		// 지금까지는 C언어의 방식으로 프로그램했음
		// 지금부터는 객체 지향 방식으로 프로그램을 만들고 실행할것임!
		
		// 데이터 관리의 용이성
		
		// 사람이 생각하는대로 프로그래밍해보자! 컴퓨터가 생각하는대로 하려니 이것저것 어려워
		// 사람이 생각하는 방식은?
		// 잠자기라는 기능이 있음, 현실세계에서 잠자기라는 기능만 존재할 수 있나? 잠자기가 있으려면 잠을 잘 수 있는(잠자기를 수행할) 주체가 있어야 함
		// 현실세계에서는 기능을 수행할 주체가 필요함 --> 이발하다 라는 기능이 혼자 떠다닐수는 없음 --> 누가 이발을 해야 함? 선생님이 이발하다! --> 현실세계의 모든 주체가 가질 수 있는 기능은 아님(모니터나 책상 등) --> 사람이나 동물이 가질 수 있는 기능임
		
		// 현실세계에서는 잠자기 기능이 있고~ 이발하기 기능이 있고~ 그렇지만 기능만 수행될 수는 없음
		// 기능이 수행되려면 주체가 있어야함 --> 선생님이라는 주체를 만들어주어야만, 선생님이 가지고 있는 기능중에 이발하기를 할 수 있음!
		// 사람이라는 주체가 있어야만 사람이 이발을 할 수 있음
		// 주체는 주체가 가진 정보(값)들이 있음 --> 이름 직업 나이 핸드폰번호 주소 등 --> 배열로는 해결이 안되는, 구조체라는 개념으로도 해결이 안되는 불편한 문제점들
		// 정보와 기능을 저장하는 단위를 하나로 묶어버리자! --> 묶은 것을 실제 램에다가 올리면 객체라고 부르자 --> 객체 지향 프로그래밍의 시작점! 현실세계에 있는 것들을 객체라는 것으로 만들자!
		// 객체는 눈에 보이고 기능이 붙어있는 세상의 모든 것들로 만들 수 있음 --> 이것을 확장하면 눈에 보이지 않는 추상적인 개념들도 소프트웨어상에서 객체로 만들 수 있음(감정, 궁금증, 분노, 사랑 등)
		// 다 객체로 만드는게 좋은건 아니고 우리가 접근해야 할 방식은? --> 우리가 객체를 만들때는 만드려고 하는 프로그램 설계의 목적에 부합하는 단위로 만들어야 함
		// 학생관리프로그램을 만들거면 학생을 객체로 만들어야 함, 김밥천국 프로그램을 만들거면 메뉴를 객체로 만들어야할거고, 회계관리 프로그램을 만드려면 회계 관련된 세법 이런것들을 객체로 만들거고..
		
		// 현실세계를 프로그래밍해서 자바세계로 옮겨보자
		// 동물 => 강아지
		// 현실세계의 독립적인 존재, 윤기님네 강아지를 자바세계로 옮겨보자
		
		// 강아지
		// 정보
		// 
		// 종 : 포메라니안
		// 이름 : 똘똘이
		// 나이 : 4
		// 성별 : 암컷
		// 색상 : 갈색
		// 몸무게 : 3kg
		
		// 이렇게 하면 밑도끝도없음, 정보가 매우 많음, 눈동자색, 발바닥색, 마지막 목욕날짜, 산책횟수 등
		// 모든 정보를 가져오는 것이 아니라, 내가 만드는 소프트웨어에 필요한 정보들만 추출하는 작업이 필요함! 아침산책시간까지 다 끌고올 수는 없음
		// 이 작업을 추상화라고 함(너무 정보가 많음, DNA정보를 다 가져올 수는 없음) --> 추상화(abstraction)해서 객체로 만들것임
		// 추상화는 클래스와 연관이 있음 --> 클래스의 뜻? --> 생물 분류 단계의 강 --> 강아지는 생물 분류 단계가 종으로 갈수록 구체적이고 계로 갈수록 추상적 --> 생물 분류 체계의 강이 클래스임
		// 똘똘이는 종의 단계, 여기서는 정보를 너무 많이 가져와야함 --> 추상화해서 가져와야 하니까 강(Class)의 레벨까지 올리자 --> 선생님의 추측(클래스라는 단어는 누가 붙였는지 왜 그랬는지는 알 수 없음)
		
		// 똘똘이를 클래스화 해보자!
		// 똘똘이를 객체로 만들기 위한 설계도가 필요함
		
		// Puppy 클래스에 다녀왔음
		
		// 객체 생성해보기
		// 강아지 객체 생성 --> 이걸 하려면 뭐가 있어야 함? 강아지 설계도(클래스)가 필요함
		// Puppy가 import 되었음
		Puppy smart = new Puppy(); // 객체 생성, 좌항은 변수 선언(자료형과 변수명), 우항은 객체 생성, 객체를 생성해서 변수에 대입함, 대입하면 뭐가 들어감?
		// 우리가 계속 했던 것, 사실 항상 객체 지향 프로그래밍을 하고있었음! 그동안 한 게 객체 생성
		// "클래스 이름"과 "클래스명을 대신할 별칭"을 작성해서 생성했음
		// 지금 봤을 때 둘째날부터 했던 PrintController pc <-- 이것은 변수 선언, 자료형과 변수이름을 썼으니까, 대입연산자 기준 왼쪽은 항상 공간이니까
		// 객체를 생성할때는 new 라는 예약어를 사용
		// 배열도 자바에서는 객체로 취급됨, 여태까지 주구장창 썼음.. 모르고 썼지
		// 객체를 생성하겠다 의 진정한 의미는? 기술적 관점에서 보면 객체를 만들면 일어나는 일은?
		// Memory의 heap영역에 데이터를 생성(객체가 올라가는 곳은 heap이다) = 이게 객체를 만들겠다는 뜻
		
		// smart.sniff(); // 우리가 계속 해오던 그것, 이것을 설명해보자
		// 우리가 항상 클래스를 사용했던 방법, 클래스 안에 메소드를 선언하고 이렇게 써서 메소드를 호출한다
		// heap에 주소 찾아가서 이거 불러야지 라는 뜻
		// 메모리 공간 왼쪽은 stack, 오른쪽은 heap
		/*
		 * Puppy smart = new Puppy();를 만남, 우리는 항상 대입연산자의 왼쪽을 본다 --> 공간 내놔, stack의 공간에 이름은 smart라고 붙인 영역이 생김 --> 1번 끝!
		 * 2번은? 대입연산자의 오른쪽을 본다 --> new 하네? 배열할때도 new 했음 --> heap 메모리에 공간을 할당함
		 * 배열같은 경우에는 heap에 얼마만큼 공간을 만들지 우리가 크기를 지정했음 --> 이번에는 크기를 지정 안함 --> new 다음에 클래스명을 한번 더 썼음 --> 우리가 클래스에 설계한 만큼(필드부에서 선언했던것들) 공간을 만들어냄
		 * 배열은 하나의 같은 자료형만 데이터를 저장할 수 있음, 우리가 저장하고 싶은 강아지가 가질 수 있는 값들은 다양한 자료형을 가질 수 있음 --> 이것을 설계도(클래스)에서 필드로 묶었고, 그만큼 heap에 뉴 퍼피를 통해서 퍼피의 데이터를 저장할 수 있는 공간이 생김 --> 2번 끝
		 * 3번은? 대입, heap에 생긴 공간은 주소가 있을것임(0x11z로 가정) --> 0x11z(주소값)을 smart 변수에 대입(배열했을때랑 똑같음!)
		 * stack의 변수를 통해 heap에 생긴 영역에 도달할 수 있음
		 * 
		 * .을 참조연산자, 직접접근연산자라고 불렀음
		 * smart가 뭐길래 sniff를 참조함? --> smart는 알고보니 객체의 주소가 들어있음, 주소를 찾아가면 메모리상의 heap 영역에 객체가 있음 --> heap 영역에 올라가있는 객체가 기능을 가지고 있을 것
		 * smart.sniff(); --> heap에 있는(어디 생겼을지는 모르지만 주소는 smart에 담아뒀음) 주소를 찾아가서 객체가 가지고 있는 기능(sniff)을 호출함
		 * 메모리상에 있기 때문에 부를 수 있음(없으면 못부름)
		 * 결국 smart.sniff();의 뜻 --> smart는 heap에 주소 찾아가서 sniff 불러야지 라는 뜻
		 * 
		 */
		
		// System.out.println(smart);
		// 출력해보면 smart는 주소를 담고 있으므로 com.kh.chap01.abstraction.vo.Puppy@7960847b 이런거 나옴
		
		// stack영역에 smart라는 이름의 공간을 만들어뒀음, heap영역에 Puppy 클래스에서 설계한 모양으로 공간을 만들었음, Puppy 클래스 모양은? 값을 저장할 수 있는 영역 6개와 기능 1개가 있음, 주소값도 생김, smart에 주소값을 담았음
		// smart라는 변수는 객체를 가리키고 있음, smart를 출력하면 주소를 보여준다. 우리는 주소를 보고싶은게 아님.. 이름같은거 보고싶다면?
		// smart의 name 속성값을 보고싶다
		// heap 영역에 생성되어 있는 name 안에 들어있는 value값을 찍고싶음 --> 어떻게 해야 함?
		// heap 영역의 주소를 먼저 찾아가야 함(배열이랑 똑같음, 값을 저장하는 공간에 가고싶은 것) --> 주소값이 저장된 곳은 smart --> smart를 쓰면? 이건 주소값, 주소값으로 접근(참조)해야 함 --> 참조연산자 . 찍으면 heap 영역에 갈 수 있음 --> heap에 있는 영역이 가지고 있는 속성(요소)이 나옴 --> name에 접근하고 싶으니 name이라고 씀
		// System.out.println(smart.name); // 지금 출력하면 null이 나옴, name은 비어있지 않다! heap에 할당받은 공간은 비어있을 수 없으므로 null이 들어있는 것
		// 객체가 heap에 올라갔다는 것은? 기본적으로 String 타입에는 null이 들어있고, int형에는 0이 들어있는 상태
		
		// 우리는 null값을 담고싶은게 아니라 똘똘이에 대한 정보를 공간에 대입하고싶음
		// 이름이 무난하니까 이름부터 해보자 --> 객체의 저장공간에 똘똘이를 대입하고싶다
		// 자바에서 값을 대입하는 방법은? --> 공간 = 값; 이번에 대입하고 싶은 리터럴 값은 문자열 똘똘이, 공간은? heap에 있음, 공간의 이름은? name
		// name만으로는 접근할 수 없고, smart가 가진 주소에 있는 name에 대입하고 싶은 것이므로 --> smart를 부르고 참조연산자, 그다음 name
		smart.name = "똘똘이"; // 예외는 없음, 왼쪽은 공간, 오른쪽은 값
		// System.out.println(smart.name);
		
		// 똘똘이를 완성시켜보자!
		smart.species = "포메라니안";
		smart.age = 4;
		smart.gender = "암";
		smart.color = "갈색";
		smart.weight = 3;
		// 이러면 heap에 할당받은 공간 안에 있는 각 공간(객체의 필드)에 값들이 들어가있는 상태가 됨
		
		// 모범시민
		// 이름은 heap영역에 있는 객체에 주소값을 참조해서 가야함, 주소값은 smart에 대입해뒀음 --> 참조연산자를 찍어야 찾아감
		System.out.println(smart.name + "는 "
		// 갈색 찍고싶다 --> 객체를 찾아가야 하니까 객체의 주소값을 가지고 있는 smart를 참조하고 color 속성
						 + smart.color + " "
						 + smart.species + "입니다.");
		System.out.println(smart.age + "살 "
						 + smart.gender + "컷에 "
						 + smart.weight + "kg입니다.");
		
		// 똘똘이를 자바의 세상에 객체로 만들어서 데려오는 것까지 성공^^!
		
		// 똘똘이를 객체로 만들기 위해서 먼저 만든 것은? 클래스, 강아지를 추상화하고 우리가 필요한 정보들만 넣을 수 있도록 클래스를 만들었음
		// 클래스란? 그릇 또는 틀 또는 설계도 또는 명세, 또는 붕어빵틀에 비교하기도 하고, 청사진이라고 하기도 함(주물도 마찬가지) --> 설계도가 하나 있으면 이 모양으로 계속 만들어낼 수 있음
		// 하나를 클래스를 가지고 내가 원하는 수도없이 많은 객체를 만들 수 있음
		
		// 틀만 있으면 속재료는 바꿔넣을 수 있음, 모양새만 같음
		// 한번 객체를 만들어냈다고 해서 클래스가 사라지는게 아님
		// 동일한 클래스를 가지고 새롭게 객체를 또 만들어낼 수 있음
		// 상근이를 만들어보자
		Puppy soldier = new Puppy();
		// 메모리상에서 일어나는일!
		// Puppy soldier라는 공간은 stack 영역에 생김(smart라는 이름의 공간 위층에 생김!)
		// heap 영역에 new Puppy()의 결과로 new 키워드 만나는 순간부터 heap에 데이터가 올라감 --> 얼마만큼? Puppy만큼 공간을 할당받음 --> 설계한대로 값을 저장할 수 있는 영역 6개와 기능 1개, 주소값이 생성됨
		// stack 영역에 만들어진 soldier 공간 안에 주소가 대입됨(0xbb22라고 하자) --> soldier는 주소(0xbb22)를 가리키고 있음
		// heap 영역에 생성된 것은 기본값이 들어있음
		
		// 찾아가야 대입할 수 있음 --> 뭘 봐야 ? 변수를 봐야함 --> 참조연산자를 써야함
		soldier.name = "상근이";
		soldier.age = 22;
		soldier.species = "그레이트 피레니즈";
		soldier.gender = "수";
		soldier.color = "흰색";
		soldier.weight = 60;
		// 이러면 heap에 할당받은 공간 안에 있는 각 공간(객체의 필드)에 값들이 들어가있는 상태가 됨
		// 클래스는 명세, 설계도, 틀, 똑같은 모양으로 찍어낼 수 있다!
		// 강아지모양 설계도이고 속 내용은 무슨값을 넣느냐에 따라 달라진다
		
		// 모범시민
		// 이번에는 상근이 정보를 출력하고싶다! --> soldier 변수에 있는 주소값을 찾아가야 heap 영역에 생긴 객체로 갈 수 있음
		System.out.println(soldier.name + "이는 "
						 + soldier.color + " "
						 + soldier.species + "입니다.");
		System.out.println(soldier.age + "살 "
						 + soldier.gender + "컷이며, "
						 + soldier.weight + "kg이예용");
		
		// 기술적 관점으로 접근하면 객체는 메모리상의 heap 영역에 생긴 데이터 덩어리, 값을 저장하는 공간
		// 이론적으로 개념적으로 추상적으로 표현하면 현실 세계에 있는 뭐시기 ~~
		// 사람이 생각하는 것처럼 어떤 현실세계의 무언가가 가질 수 있는 데이터 그리고 현실세계의 무언가가 가질 수 있는 기능 이런것들을 따로 관리하면 작업이 어려우니 하나의 저장소로 묶어놓자! 묶은 것을 클래스라고 함
		// 여러가지 형태의 값을 저장할 수 있는 저장소
		// 변수도 한가지의 자료형만 가질 수 있음, 배열은 값은 여러개 담을 수 있지만 하나의 자료형만 저장할 수 있음
		// 클래스는? 내가 원하는 자료형(String int boolean char 등)을 내가 생각하는 내 입맛대로 저장할 수 있음 --> 현실세계의 무언가가 구현할 수 있는, 할 수 있는, 수행할 수 있는 기능들도 같이 저장할 수 있다
		// --> 이걸 다르게 얘기하면? 클래스는 내가 생각하는 모양새를 만드는 것, 이번에 만든 모양새는 Puppy의 모양으로 만들었음
		// 강아지의 값들을 저장하고 있음, 이걸 할 수 있는 강아지 모양새의 설계도를 만들었음
		// 이 값들은 강아지를 나타낼 수 있는 값들, 강아지의 속성들, 데이터가 올라갔는데 강아지 모양으로 올라감 --> 이걸 우리는 뭘로 쓰고 있나? 변수? 변수는 soldier(주소값을 담은 공간)가 변수고, 강아지 모양은? 자료형!으로 쓰고있음(자료형이 들어가는 자리에 Puppy를 썼다)
		// 실질적으로 우리는 강아지의 모양으로 자료형을 만든 것(우리가 만든것은 자료형!)
		// 클래스를 뭐라고 생각하면 되냐? 개발자가 만드는 사용자 정의 자료형이라고 생각! 개발자가 만드는 사용자 정의 자료형을 자바에서는 클래스라고 함
		// 사용자 정의 자료형에는 들어갈 수 있는 값(value)이 주소밖에 없음
		// 여태 사용한 변수공간에는 뭐가 들어감? 주소! 항상 자료형을 만들고 주소값을 담았음(new로 객체 생성 이후에)
		// 우리가 만든것들을 참조자료형이라고 표현함, 우리는 계속 참조자료형(사용자정의자료형)을 만든 것, 앞으로도 만드는 것은 항상 새로운 자료형
		// 자바에서 기본자료형을 제외한 나머지 자료형은 전부 참조자료형
		// 전부 참조자료형 변수에는 주소값만 들어감(어떻게 생길 지 알수없음) --> 변수에는 주소값만 들어가서 실제로 생긴 것을 참조함
		// 참조자료형(reference type)
		// C언어에 비해서 자바는 쉽다, 메모리 관리 안해도 되니까(개발자가 직접할필요가없어서 좀더 비즈니스로직에 집중할 수 있음)
		// C언어에서는 pointer가 어려움(통곡의 벽), 이중포인터, 포인터배열 등
		// 자바는 기본자료형을 제외한 나머지가 전부 포인터, 포인터밖에 없음, 사실은 쉬운 언어가 아님...
		// 점찍는것(point)은 가리킨다는 의미, heap 영역의 주소를 가리킴, 여기부터 시작~
		
		System.out.println("==========");
		
		smart.sniff(); // 똘똘이도 냄새맡기 있음
		soldier.sniff(); // 상근이도 냄새맡기 있음
		// 강아지가 가지고 있는 기능이라서 이렇게 나옴
		// 조금 더 구체적으로 이름을 붙여서 누가 냄새를 맡는지 같이 출력을 해주고싶음 --> 어떻게 해야할까?
		// sniff는 Puppy클래스에 있는 기능, 강아지들이 각각 가지고 있음
		// 현재 생성된 객체가 가진 name의 속성값을 찍어주고싶음
		// sniff를 호출하는데 이름을 같이 띄워주고싶다
		// Puppy에 가서 수정
		
		// 상근이를 다이어트시키고싶다.
		// Puppy 클래스에서 다이어트 기능을 만들고옴
		System.out.println("짖기 전 상근이 몸무게 : ");
		System.out.println(soldier.weight);
		
		soldier.bark();
		soldier.bark();
		soldier.bark();
		// 짖어 세번 했으니 15kg빠질것임
		// 굉장히 위험한 메소드임
		// 상근이가 아니라 똘똘이가 만약에 짖으면?
		// 똘똘이 3kg니까 -2kg가 됨 --> 현실에서는 말이 안됨, 최소 가져야하는 몸무게게 있어야함
		// 똘똘이는 한번만 짖어도 비정상적인 값이 대입되므로 이런 일이 생기지 않도록 우리가 막아줘야함
		// 다시 bark 메소드로 가서 수정
		
		System.out.println("난 후 : ");
		System.out.println(soldier.weight);
		
	}

}
