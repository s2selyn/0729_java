package com.kh.chap04.controller;

public class FieldController {
	
	// 클래스에서 필드부에 필드를 선언해서 사용하는데, 값을 저장하는 공간이라는 건 알겠는데, 이 챕터에서 구분에 맞게 용도에 맞게 정리해보자
	
	/*
	 * 필드(field), 자바에서는 필드 == 다른 표현으로는 클래스가 가지고 있는 멤버중의 변수라는 의미에서 멤버 변수라고도 함 == 인스턴스 변수(객체가 가지고 있는 변수, 클래스를 객체로 올렸을 때 가지고 있는 변수, 이런 표현은 드물다, 보통은 필드나 멤버 변수)
	 * 
	 * 클래스를 구성하는 요소 중 하나(삼총사, 필드부-생성자부-메소드부 중에 하나임)
	 * 데이터를 저장하기 위한 역할(변수)
	 * Object 프로젝트에 들어오기 전까지는 변수 선언 위치(영역, scope)가 항상 메소드 스코프(영역) 안에 있었음 
	 * 
	 * 필드가 선언되는 위치는? 클래스 스코프 안
	 * 클래스 내부에 정의하지만 메소드 영역 밖에 존재
	 * 
	 * 변수 구분
	 * - field : (필드가 선언되는 위치는) 클래스 블록(Scope)에 바로 선언하는 변수!
	 * - (local) variable : 클래스 영역 내부에 특정한 구역!!!에서 선언됨({})
	 * 						=> method, for, if, while 등등...
	 * 넓은 범위에서는 메소드 안에서 선언되는 것일수도 있음
	 * 메소드 안에 있는 if문에 포함되었다면 if문꺼, 메소드꺼라고는 할 수 없음, if문 안에서만 살아남음
	 * 
	 * 우리가 여태까지 배운것만 보면 변수는 필드와 지역변수로 구분
	 * 언어를 공부하다보면 지역변수 말고 전역변수라는 개념이 있음(프로그램 전체 어디든지 사용 가능한 변수)
	 * 결론적으로 자바에는 전역변수라는 개념 자체가 없지만 전역변수의 역할을 하는 친구들은 있음
	 * 
	 * 1. 전역 변수의 역할을 하는 친구들(그렇다고 전역변수라고 하면 안됨)
	 * 
	 * - 필드(멤버변수, 인스턴스변수) : 
	 * 						   생성시점 => new 키워드 사용해서 해당 객체를 생성 하는 순간 heap에 할당(객체가 살아있는 동안은 계속 쓸 수 있음!)
	 * 						   소멸시점 => 객체가 소멸될 때(언제 없어질 지 모름, 연결은 끊어줄 수 있음, 연결이 끊기는 것은 객체가 없어지는 것을 의미하는 것은 아님 --> 연결이 끊어지면 GC가 데려감, 그때 없어짐)
	 * 								  => G.C가 일을 안하면 OOM(Out Of Memory) 발생(자바개발자라면 안친하고싶음, 메모리 터졌당, 큰 규모의 무언가를 하다보면 만나게됨)
	 * 
	 * 메모리에 객체가 계속 올라가면 메모리가 부족하게 될 수 있음
	 * 나중에 관리자가 되면 해결해야 할 수도 있음...
	 * 
	 * 요즘엔 인프라 자체가 클라우드로 옮겨가서 직접 보기 쉽지는 않음
	 * 서비스를 이용하다가 공지사항 탭에 이런 글이 올라옴 --> 서비스 이용에 불편을 드려 죄송합니다. 언제부터 언제까지 서비스가 원활하지 못해 어쩌구저쩌구
	 * 웹이든 게임이든 이런 경우는 --> 아 저희 프로그램이 언제 메모리가 터졌는데 급하게 금방 고쳤습니다 를 돌려서 표현한 것
	 * 보통 코드상의 문제임, 잡아서 해결할수도 있고, JVM의 메모리할당 등을 부분을 바꿔야하기도하고 등등
	 * 요새는 컴퓨팅 자원을 가져와서 사용하는 경우가 많아서 OOM 잘 없게됨
	 * 
	 * 클래스 최상단에서 선언됨, 얘가 선언되고 나서는 적어도 클래스 내부에서는 전역으로 사용할 수 있음
	 * 조심할 것 --> 값을 저장하는 공간을 이야기할때는 두가지를 생각(1. 필드라는 공간의 생성시점
	 * 
	 * 클래스 안의 필드는 언제 생성되는가? 선언하면? 공간이 생기는 시점은 언제?
	 * 초기화 안하면 못씀
	 * 
	 * - 클래스 변수(static, 스태틱변수, 정적변수) : 변수 앞에 static이라는 예약어가 붙어있는 변수(아까 out에서 봤음)
	 * 										 생성 시점 : 프로그램 시작과 동시에 static영역에 올라감
	 * 										 소멸 시점 : 프로그램 종료되면 소멸
	 * 
	 * 2. 지역 변수
	 * 			생성 시점 : 특정 영역( { 스코프 } ) 내부에서 선언되는 시점에 메모리 영역에 할당 -> stack에 생김
	 * 			소멸 시점 : 특정 영역( { 스코프 } )이 종료될 때(예를 들어 메소드가 날아가면 얘도 같이 ㅂㅂ)
	 * 
	 * 우리반 스타일 : 때려놓고 확인하고 설명하기
	 * 
	 */
	
	// 필드 선언!
	// 접근제한자 안숨기고 public으로 달아두겠음
	public int global;
	// 객체가 살아있는 동안은 필드를 계속 쓸 수 있다!
	// 객체가 생성되면 생겨나고, 객체가 사라지면 사라짐
	
	// 메소드를 하나 만들자
	public void checkVariable(int parameter) {
		// 매개변수 하나 넣자
		// int parameter 하면 강제성이 생김 --> 이 메소드를 호출하려면 무조건 정수값을 전달해야 하도록 만들어진 것
		// 이 메소드 영역 안으로 들어왔다는 것은 매개변수가 초기화 되어있다는 뜻임 --> 그러므로 아래 인쇄시 매개변수는 초기화 안해줘도 빨간줄 안생김
		// 다른 곳에서 이 메소드를 부르면 checkVariable()은 stack영역에 올라감 --> 올라가면서 매개변수는 메소드 호출하면서 넣은 인자값으로 초기화됨
		
		// 지역변수 하나 넣자
		// local(지역변수) 할당 및 초기화
		int local = 1; // 지역변수 특 : 초기화 안하면 사용할 수 없음
		
		// 메소드 안에서 변수 역할을 할 수 있는 삼총사(global, parameter,local)를 출력해보자
		System.out.println(global); // 필드, 멤버변수
		System.out.println(parameter); // 매개변수(지역변수)
		System.out.println(local); // 지역변수 --> 빨간줄(int local; 인 상태라면), 지역변수는 반드시 초기화를 해줘야함 --> int local = 1;로 초기화
		// Run 클래스로 가자
		
	}
	
	// 메소드를 하나 더 만들어서 static 영역을 써보자
	
}
