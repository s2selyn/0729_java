package com.kh.chap05.constructor.model.vo;

public class Member {
	// 클래스를 만든 목적 : 우리는 웹개발자니까 사이트에 회원가입한 회원들이 생기면 정보를 담아둘 용도
	
	// [ 필드부 ]
	// 아이디, 비밀번호, 닉네임
	private String userId;
	private String userPwd;
	private String nickName;
	
	// [ 생성자부 ]
	/*
	 * 생성자(Constructor) : 객체를 생성하는데 사용하는 특수한 유형의 메소드(개념적으로는 일반적인 메소드는 아님, 생성자로 표현하는 것이 맞다, 자바 내부에서는 기술적으로 메소드로 구현되어 있음)
	 * 
	 * [ 표현법 ]
	 * 접근제한자 클래스식별자(매개변수(생략가능)) { <-- 중괄호는 생성자 블럭
	 * 		해당 생성자를 통해서 객체 생성 시 실행하고자 하는 코드; <-- 생략 가능
	 * }
	 * 
	 * 객체를 만들 때 생성자를 항상 호출함
	 * 생성자의 역할
	 * -- 기술적인 관점 : 객체가 생성될 때 어떤 상태로 시작을 해야하는가(new는 메모리에 할당받는 역할(heap에다가 메모리 주세요!), 메모리가 어떠한 상태일지를 정해줘야함 --> 생성자는 어떻게 생긴 것을 할당받는 것인가를 정해줌), 언어적으로도 객체를 생성하고싶어? 생성자를 호출해! 라고 해둠
	 * -- 개념적인 관점 : 객체가 처음부터 유효한 상태를 가지도록 강제
	 * 
	 * 멤버 클래스의 목적은 회원가입에 성공한 회원들의 정보를 담는 것, 객체 생성하고 출력해보면 기본값이 들어있음(null로 대입되어있음)
	 * 멤버가 생겼다는 것은 누군가 가입해서 회원가입을 성공한 사람이 있다는 것인데, 기본생성자를 쓰면 안에 회원정보가 없어서 개념적으로 유효하지 않은 상태임
	 * 만들고 setter를 써서 값을 넣어줄 수도 있지만 VO는 setter가 없고, setter쓰다가도 문제가 생길 수 있음
	 * 객체는 메모리에 올라갈 때 모두 유효한 값이 들어있어야 객체 지향 관점에서 좀 더 맞는것이아닌가? 가입했으면 아이디 비밀번호 이런게 있어야지 --> 이것을 위해서 생성자 사용
	 * 
	 * 생성자의 종류
	 * 1. 매개변수가 없는 생성자 => 기본생성자(default constructor)
	 * 2. 매개변수가 존재하는 생성자(기본생성자처럼 딱히 표현하는 말이 없음, 그냥 부르기로는 매개변수생성자)
	 * => 객체를 생성과 동시에 유효하게 만들기 위해서
	 * 
	 */
	
	// 밖에서 부를 수 있도록 생성자를 만들자, 클래스를 객체로 사용할 때 생성하는 친구, Member라는 클래스를 객체로 만드려고 함
	// 접근제한자 뒤에는 클래스 이름을 똑같이 적는다, 대소문자 구분 명확하게, 그다음에 소괄호 열고닫고, 중괄호 열고닫으면 끝!
	// Run에서 객체 생성하기
	
//	public Member() {
	// 기본생성자(매개변수 없음)
	// 객체를 생성할때 기본생성자를 호출함, 내가 무언가 코드를 작성해놓는다면, 나를 불렀을 때 수행될것임
	// System.out.println("하핫 죽어랏~");
	// 기본생성자는 객체를 생성할 목적으로 호출해서 사용, 얘를 부르면 객체가 생성됨!
	// 우리는 생성자 처음 만들어봤음, 여태 안만들었는데 항상 new 하고 생성자를 호출해서 만들었음
	// 기본생성자는 생략해도 에러가 발생하지 않음
	// 클래스 내부에 생성자를 하나도 작성하지 않으면 JVM이 기본생성자를 자동으로 만들어줌!
	// 옛날에는 코드짜다가 사람들이 하도 기본생성자 작성을 까먹고 이거없이 많이 만들어서 에러가 났다고 함 그래서 만들어준대
	// 이거 없이 동작을 시키면 에러가 많이 발생함
	// 우리는 앞으로 기본생성자만 만들게 아니라 매개변수 넣은 생성자를 만들어서 쓸건데, 매개변수 넣은 생성자 만들거나 이러면 클래스 내부에 생성자가 하나 더 존재하면 기본생성자를 안만들어줌
	// 다 해놓고 기본생성자 없어서 프로그램이 정상적으로 동작하지 않는 경우가 많음
	// 여태까지는 몰라서 안만든건데, 앞으로는 기본생성자를 항상 작성하자!!!! ★★★★★★
//	} --> 기본생성자 주석처리함
	
	public Member() {} // <-- 얘는 무조건 꼭 있어야함! 귀찮으면 이렇게 블록 안나누고 해도 만들긴 만들어라~
	// 매개변수가 존재하는 생성자 생성하고 나서 다시 만들어줬음
	
	// 매개변수가 존재하는 생성자
	// 밖에서 부를거니까 접근제한자는 public, 클래스명과 똑같이 대소문자 명확하게 구분해서 적어주기(소문자로 적으면 생성자가 아니라 메소드로 생각함)
	// public member() <-- 메소드라고 인식
	// public void Member() <-- 메소드라고 인식
	// 소괄호 안에 매개변수 = 필드명과 동일한 타입과 식별자로 작성함
	public Member(String userId) {
		System.out.println("매개변수가 한 개인 생성자");
	} // --> Run에 가면 빨간줄생겨있음, 기본생성자를 호출하는 부분이 빨간줄
	// 이런건없어용, The constructor Member() is undefined, 생성자 없당!
	// 우리가 생성자를 하나 만들어줬음
	// JVM 입장에서 봤을때는 의도(이유)가 있어보임(일부러 안만들었다고 생각함, 생성자 호출할때 무조건 값 받으려고 그랬구나~), 생성자가 아예 없으면 실수로 인식해서 기본적으로 만들어줌
	// 지금은 기본생성자를 호출했음
	// 스캐너에서 경험해봤음 Scanner sc = new Scanner(); 라고 하면 어디 도구에서 받을건지(매개변수)가 꼭 필요하므로 에러가 남
	// 스캐너의 생성자는 의도적으로 기본생성자를 안만들었음
	// 우리는 기본생성자를 안만들면 반드시 어디에선가 문제가 생길 수 있음!! 까먹지말고 기본생성자 만들자
	
	// 지금 매개변수가 존재하는 생성자를 만드는 이유? 객체 생성과 동시에 필드에 값이 들어있게 하려고 --> 이러려면 어떤 작업을 해야하느냐? 생성자 호출하면서 필드값을 초기화(대입)해줄것임
	// 보편적으로 회원가입을 성공하려면 아이디랑 비밀번호는 무조건 있을거고 닉네임은 없어도 될것같다(선택)
	// 개발자가 정하는것임, 회원가입은 성공했다면 보편적으로 아이디랑 비번은 무조건 있어야함
	// 매개변수가 두개인 생성자를 호출해보자
	public Member(String userId, String userPwd) {
		
		// System.out.println("매개변수가 두 개인 생성자");
		
		// 변수값 찍어봐야지 --> 잘 전달받음
		// System.out.println("전달받은 아이디 값 : " + userId);
		// System.out.println("전달받은 비밀번호 값 : " + userPwd);
		
		// 객체가 생성될 때 생성과 동시에 유효한 상태(객체)가 되도록 생성자를 통해 초기화
		// 세터에서 하는 일을 생성자에서 해주자!
		this.userId = userId;
		this.userPwd = userPwd;
		
	}
	
	// 많이 하는 실수
	// 생성자를 통해 값을 넘기는데, 비밀번호와 아이디의 순서를 바꿔서 입력했다면? --> 내 생각과 다르게 움직일 수 있음
	// 매개변수는 어쨌든 변수 --> 공간! 변수식별자는 개발자가 지음(마음대로 지을 수 있음), 컴퓨터는 모름
	// 변수는 공간이지 값이 아님!
	// 메소드 호출 시 인자값을 전달할 때 주의할 점! 순서! 전달한 순서대로 대입이 된다, 컴퓨터는 모른다~
	
	// 하는 김에 모든 필드를 매개변수로 가지는 생성자도 만들어보자
	// 모든 필드 초기화하는 생성자를 만들었음, 얘를 부르고싶으면 생성자를 호출할때 인자를 문자열로 3개를 넣으면됨
	public Member(String userId, String userPwd, String nickName) {
		this.userId = userId;
		this.userPwd = userPwd;
		this.nickName = nickName;
	}
	
	/*
	 * 주의사항!
	 * 
	 * 1. 반드시 생성자의 이름을 클래스의 이름과 동일하게 작성해야함(대/소문자 주의)
	 * 2. 반환형이 존재해서는 안됨!(메소드로 판단)
	 * 3. 매개변수 생성자를 명시적으로 작성하면 기본생성자를 만들어주지 않음!
	 * => 우리는 꼭 기본생성자를 억지로 열심히 작성하는 습관을 들여야 함!!!!
	 * 4. 생성자는 동일한 이름으로 여러 개 생성이 가능하지만 매개변수가 중복되어선 안됨!! => 생성자 오버로딩
	 * (오버로딩은 07 프로젝트에서 메소드 오버로딩과 같이 자세히 할 예정)
	 * 
	 */
	
	/*
	 * 2025 / 08 / 07
	 * 오늘의 실습 겸 숙제
	 * 
	 * 기존에 만들어 두었던 다섯 개의 VO클래스 및 실행 클래스를
	 * 오늘 배운 캡슐화 및 생성자를 적용하여 변경하시오.
	 * 
	 * 1) 모든 필드의 접근제한자를 private 으로 변경
	 * 2) 필드에 간접적으로 접근할 수 있도록 getter() / setter() 생성
	 * 3) 모든 필드의 정보를 합쳐서 문자열의 형태로 반환해주는 info() 생성
	 * 4) 기본생성자 및 모든 필드를 매개변수로 가지고 있는 생성자 생성
	 * 5) 직접접근으로 사용하고 있던 실행클래스의 코드들을 전부 다 getter / setter 대체
	 * 
	 * 우리반게시판에 동일한 형식으로 제출
	 * 
	 * 제한 시간 : 08 / 08 -- 07:59까지~ 시~작
	 * 
	 */
	
	// [ 메소드부 ]
	// 16:00는 여러분들이 힘든 시간이기 때문에, 실습을 드리겠습니다.
	// 모든 필드에 대한 getter() / setter() 만들기 + 모든 필드의 정보를 합쳐서 반환하는 info() 만들기
	// 시 ~ 작
	
	// getter
	public String getUserId() {
		return userId;
	}
	
	public String getUserPwd() {
		return userPwd;
	}
	
	public String getNickName() {
		return nickName;
	}
	
	// setter
	public void setUserId(String userId) {
		this.userId = userId;
	}
	
	public void setUserPwd(String userPwd) {
		this.userPwd = userPwd;
	}
	
	public void setNickName(String nickName) {
		this.nickName = nickName;
	}
	
	// info
	public String info() {
		
		String info = "아이디 : " + userId + ", 비밀번호 : " + userPwd + ", 닉네임 : " + nickName;
		return info;
		
	}
	
}
