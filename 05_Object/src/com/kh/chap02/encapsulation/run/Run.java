package com.kh.chap02.encapsulation.run;

import com.kh.chap02.encapsulation.model.vo.Cafe;

public class Run {

	/*
	// 필드 앞에 public을 붙여두었음
	System.out.println("아무생각이 없이 썼던거 같아요.");
	// 이제 아무생각없이 쓸수없는 단계에 도달함
	// 메인메소드의 접근제어자가 private이라면?
	
	오류: com.kh.chap02.encapsulation.run.Run 클래스에서 기본 메소드를 찾을 수 없습니다. 다음 형식으로 기본 메소드를 정의하십시오.
	public static void main(String[] args)
	또는 JavaFX 애플리케이션 클래스는 javafx.application.Application을(를) 확장해야 합니다.

	// 메인메소드는 하나의 약속, JVM이 호출하는데, public static void main(String[] args) <-- 이렇게 생긴것만 호출할 수 있음
	*/
	
	// chap01은 추상화가 핵심 주제였음, 여기서는 캡슐화
	// 캡슐화(encapsulation) 이미 우리는 Puppy 할 때 해봤음!
	// 프로그램을 구현할 때 필요한 값들이 뭔지, 기능이 뭔지(퍼피의 짖기, 냄새맡기) 생각했음 --> 다 흩뿌려놨을거임(가질 수 있는 속성(변수), 메소드 다 따로따로 선언하고 메인안에 있을수도있고 다른클래스에 있을수도있고.. 분리됨)
	// C언어에서는 정보(값)을 담는 구조체와 기능을 담는 함수가 분리되어있었음
	// 속성(데이터)과 해당 데이터를 조작하는 행동(메소드)를 하나의 단위로 묶는 것(묶어서 이름을 붙임)
	// 우리는 하나의 클래스(Puppy라고 이름지은 클래스)에 속성(필드)과 행동(메소드)을 만들어서 몰아서 집어넣었음
	// 그동안 클래스를 이런식으로 만든적이 없음, 그동안에는 필드부에 필드(클래스가 가질 수 있는 속성)를 선언한 적이 없음
	// 이번에는 메소드이름도 제대로짓고 퍼피가 가질수있는 속성을 담을 필드도 잘 적어줘서 온전히 하나의 묶음을 만들었음 --> 이게 캡슐화, 데이터 추상화의 방법, 데이터 추상화를 구현하는 방법
	
	// 정보은닉(information hiding) <-- 캡슐화에 부가적으로 붙는 것
	// 캡슐은 안에 있는 중요한 것을 외부로부터 보호하기 위함, 밖에서는 안을 모름
	// 아까 만든 Puppy는 위험한 상태 --> 누군가 악의적으로 상근이의 나이를 -100살로 수정하는 것을 막을 수 없음
	// 데이터 자체가 데이터에 접근할 수 있는 권한 자체를 바깥에서 누구나 다 접근할 수 있도록 해둔 상태(외부에 노출된 상태)
	// 캡슐화를 통해 안에 있을 것을 다 묶었음 --> 안에 들어있는 정보들을 외부로부터 데이터들에 함부로 접근할 수 없도록 숨겨주는 작업이 필요함(상근이를 -100살로 만들지 못하게 하기)
	// 캡슐화를 통해서 현실 세계의 객체가 가질 수 있는 속성과 메소드들을 하나에 몰아넣고, 속성은 외부로부터 숨기고, 안에 있는 친구들을 내부에서 조작할 수 있는 방법까지 구현할 것
	
	// OOP의 4대 특성 : 추상화, 캡슐화, 상속, 다형성
	// 3대 특성 : 캡슐화, 상속, 다형성
	// 7대 특성 : 추상화, 데이터추상화, 캡슐화, 상속, 다형성, 컴포지션, 합성, 어소시에이션(연관)
	// 어쨌든 캡슐화, 상속, 다형성은 안빠짐!
	
	// 접근제한자 (예약어) 반환형 메소드식별자(매개변수){	}
	public static void main(String[] args) {
		
		// Cafe 클래스를 가지고 객체 만들기
		// 객체 생성하는 방법은 --> new, new 하면 heap에 올라감!!! --> new 뒤에 뭐가 붙느냐가 중요함 --> 어떤 모양새의 객체를 만들겠느냐는 부분임
		// new Cafe(); // import 해야 함
		// new Cafe(); <-- 얘는 뭐임? heap 영역에 생긴 이녀석의 주소값, 결국 값!
		// 주소값이 있으니 접근하고 참조할 수 있음
		// new Cafe().cleaning(); // <-- 이렇게 하면 일회용, 나중에 GC가 가져감
		// 보편적으로는 프로그램이 실행되는 동안 계속 사용함, 누군가는 얘를 가리키고 있어야 유지됨, 그래서 변수에 담아두는 것 --> 블럭이 끝날때까지 유지됨
		Cafe cafe = new Cafe();
		// 대입연산자 기준 좌항을 변수 선언(자료형 식별자)
		// 가운데에 대입연산자
		// 오른쪽에는 객체 생성 == 메모리에 적재
		// 메모리상에 객체가 올라가있을것임, 필드 4개, 메소드 3개를 가지고 있음
		// 필드 접근제한자를 전부 public으로 만들어둔 상태 --> 필드에 얼마든지 접근 가능
		// 여기는 Cafe 클래스 외부임
		
		/*
		cafe.lee; // 없는거 내놓으라고 한것이랑은 다름 --> lee cannot be resolved or is not a field
		// 있는거 숨기면? The field Cafe.name is not visible --> 안보이는데? --> 외부에서 접근이 불가능한데? 라고 받아들이기
		cafe.name = "KH카페";
		System.out.println(cafe.name);
		cafe.signatureMenu = "KH커피";
		cafe.signatureMenuPrice = -500; // <-- 이건 조금 이상함, 일어날 수 있음! 외부로부터 노출되어있기 때문에 가능함(접근, 접근해서 대입, 조회 등 가능)
		System.out.println(cafe.signatureMenu);
		System.out.println(cafe.signatureMenuPrice);
		// 기본적으로 모든 필드가 public 접근제한자를 달고있음 --> 클래스에 직접 접근해서 값을 대입하거나 조회할 수 있음
		*/
		
		// 객체와 객체간은 상호간에 모를수록 좋음(외부에 보여지는게 적을수록, 객체간에 서로의 정보를 모를수록 좋음, 알면 알수록 다침)
		// 필드의 접근제한자가 public인 경우, 외부로부터 접근이 가능해서 값을 조작, 조회할 수 있다
		// 외부로부터 속성값을 직접 접근할 수 없도록 캡슐화할것임(필드랑 메소드 모은것은 캡슐화 절반한거고, 이거해야 조금 더 구조적인 클래스로)
		// Cafe 클래스로 감
		
		// 필드가 보이지 않아서(외부에서 접근이 불가능해서) 오류 발생!
		// signatureMenuPrice에 최소한 1 이상의 정수값이 들어가도록 하고싶음
		// 접근제한자를 public에서 private으로 변경했기 때문에 직접 접근이 불가능
		// cafe.signatureMenuPrice = -500;
		// 그럼 속성(필드)들이 의미가 있는가? 값을 못넣게 해뒀는뎅,, 어떻게든 값을 넣고 읽어오기도 해야하는데 밖에서 접근할수가 없음
		// 직접 접근이 불가능하기 때문에 간접적으로 접근할 수 있는 방법을 만들어주어야 함
		// Cafe라는 클래스에 getter / setter라는 메소드 만들기
		
		// 그전에 내부적관점 외부적관점 다시 설명
		// 카페에 메소드 3개를 만들어뒀음, 오픈하면 메소드 3개를 꼭 수행하도록 하고싶다면?
		// *** 객체의 내부적 관점 / 외부적 관점
		// cafe.dishWash();
		// cafe.cleaning();
		// cafe.windowCleaning(); // 지금 public으로 선언했기 때문에 외부에서 접근 가능
		
		// 청소가 힘드니까 알바생들이 파업했어! 과감하게 그릇닦기는 업체 쓸게, 없애! 이러고 주석처리를 해봅시다 --> 수정이 일어난 클래스는 Cafe 클래스인데 문제가 생기는 부분은 Cafe의 메소드를 호출하고 있는 외부에서!
		// 왜? 이미 너무 잘 알고있었음 --> 어떻게 해결할까? 간단하게 해결할 수 있음 --> 문제의 원인 : 모든 것을 밖에 다 보여주고 있음
		// 밖에서 못보게 숨겨버림 --> 접근제한자를 private으로 바꿈 --> 외부에서 못부름 --> Cafe 클래스의 내부에서 숨긴 메소드들을 부르고, 부른 것들을 포함하는 메소드는 바깥에 보이도록 만들어줌
		// Cafe 클래스에서 선언된 청소3총사는 private이지만 Cafe 입장에서는 내부에 존재하니까 접근제한자에 상관없이 부를 수 있음, 바깥에서는 안보이지만 안쪽에서는 부를거임
		// Run 클래스에서는 보이는 open을 호출 --> cafe.open(); // 결과는 동일하지만, 청소3총사를 외부에서 안보이게 숨기고, 안에서 청소3총사를 부르고 외부에서는 보이는 메소드를 만들어줌
		// 설거지를 없앤다고 가정하면 오픈메소드는 수정해야함(클래스 내부에서는 수정이 일어났으니 주석처리해준다)
		// 오픈을 부르던 바깥에서는 안에서 청소삼총사중에 누굴 부르는지 알수없음. Cafe내부가 수정된다고 다른 클래스가(바깥이) 영향을 받지 않음.
		// 원래대로라면 실행순서나 메소드 추가를 변경했다면, Cafe에서도 작업하고, 클래스 외부에서도 작업해줘야함 --> Cafe에서 일어난 일은 여기에서만 해결하면 됨 --> 유지보수의 관점!
		// 나한테 있는걸 외부에 노출을 많이 시킬수록, 내가 문제가 생겼을 때 밖에서도 고쳐야함 --> 나한테 있는걸 최대한 숨기면 내가 수정이 일어나도 바깥은 영향이 크게 가지 않고 나만 고치면 됨
		// 보일거 안보일거 구분해서 잘 숨겨놓는 과정까지가 캡슐화과정 --> 이걸 잘해놓으면 유지보수가 점점 더 용이해짐
		
		// 필드는 외부에서 바꾸지 못하지만 클래스 내부에서는 바꿀 수 있음, 안쪽에서는 접근 가능
		// 내부에다가 필드를 조작할 수 있는 메소드들을 만들어줄것임
		
		// 메소드를 호출해서 signatureMenuPrice의 속성값을 바꿔보자 --> Cafe에서 먼저 작업
		cafe.setSignatureMenuPrice(5000); // <-- 만들어둔 세터 호출, 가격 설정좀 할게 호출하고 끝날것은 아님, 뭘 넘겨줘야 함? 필드에 담을 int형의 정수값을 넘겨줘야함
		// 목적은 메뉴가격을 변수공간에 대입하는 것, 메소드를 호출하면서 5000을 넣는 게 목적, 5000을 메소드에 넘겨주고싶음, 5000은 값
		// 메소드 호출 부에서는 오로지 값만 넘길 수 있음
		// 값은 괄호 안에 적으면 됨, 일단 5000을 적었는데(메소드를 호출하면서 int형의 인자값을 넘김)
		// The method setSignatureMenuPrice() in the type Cafe is not applicable for the arguments (int)
		// arguments는 인자값
		// 지금 괄호안이 비어있는 메소드밖에 없음, 아무값도 안넘길때는 문제가 없음
		// 우리는 Cafe라는 클래스를 만들었는데 자바에서는 이 클래스를 type이라고 표현함, 자료형으로 인식하고있음
		// 메소드 선언부에서는 어떤 값이 올 지 모르지만 값은 받아서 써야 함 --> 값을 받아야 하니까(타입은 안다 정수형!) 공간이 있어야 함 --> 값을 넣어둘 변수를 선언해서 받아야 함
		// 괄호안에 5000 적었으니까 메소드에서도 괄호안에 변수를 선언해줌
		// 값을 받아서 필드에 대입하고 싶은것이므로 보편적으로 괄호안의 변수명을 매개변수(parameter) 식별자는 필드명과 동일하게 작성(특별한 이유가 없으면, 특히 세터에서는)
		// 메소드 호출시 값을 담아서 전달해줄 수 있음, 선언부에서는 넘어오는 값을 변수를 통해서 받을 수 있음 --> 자료형은 꼭 맞춰줘야함
		
		// System.out.println("메인 메서드에서 찍어본 cafe의 주소 : " + cafe);
		
		cafe.setName("KH카페"); // 값을 전달할것임 --> 클래스에서는 받아줘야함
		// 매개변수를 선언하면 여기 붉은줄 --> 인자값 없다고 경고 --> "KH카페"를 소괄호에 넣어서 전달
		
		// 카페 객체의 주소필드에 값을 대입하고싶다 --> 먼저 객체를 찾아가야 함, 객체 찾아가는 방법은 주소! 주소는 변수에 cafe에 담아뒀음 --> 주소에 가야하니까(참조해야하니까) 참조연산자 --> 갔으면 setter 호출 --> 대입하고싶은 값 전달, 값은 소괄호안에 작성
		cafe.setAddress("서울시 중구 남대문로 120 2층");
		
		// 세개의 필드에 세개의 값을 대입(세팅)했음 --> 잘 들어갔는지 출력해서 확인해보기(값을 얻어내서 출력을 하든 연산을 하든)
		// 모범시민~ Name 필드값을 출력하고싶음, cafe.name으로는 안됨, name 자체는 외부로부터 접근이 안되게 막아두었음
		// System.out.println(cafe.name); 이렇게 직접 접근 불가 --> 메소드를 만들어줘야함 --> 직접 접근이 불가능한 값을 가져오는 것 --> getter --> 다시 Cafe 클래스로 가자
		// cafe.getName();
		// 지금 KH카페를 넣어둔 상태에서 getName을 호출했음 --> return으로 값을 들고 왔음 --> 아직 출력문을 안썼으니까 값이 안나오는것 --> 값만 받아놓은 상태
		// 출력해보고싶다면? 반환받은 값을 사용하고 싶은 것임, 지금은 값이 뭐가 올 지 모름 --> 값을 사용하고싶다면 어딘가에 저장해둬야죠! 우리가 값을 저장하는 공간은 변수, 값이 뭔진 모르지만 무슨모양(자료형)으로 올 지는 알고 있음
		String cafeName = cafe.getName(); // return된 값이 오른쪽에 값으로 들어오고, 왼쪽의 변수에 대입될것임
		// cafe.getName()은 메소드 호출이지만 실질적으로는 name필드의 값임, 오른쪽은 항상 값이다~
		System.out.println(cafeName); // 콘솔창에 출력은 출력문 써야 출력된다!!!
		// System.out.println(cafe.getName()); 이렇게 넣어도(변수 안써도) 똑같이 나오긴함, 값을 써야된다 --> 변수를 선언해서 받아야지!가 바로 안나오므로 이 과정이 익숙해질때까지는 값을 계속 변수에 담아서 사용해보자.
		
		// 주소가 잘 들어갔는지 확인하고싶은데 직접 접근이 안된다 private이니까! Cafe로 다시 가자
		// 만들었으면 써보자
		// address 필드값 받고싶다면 일단 어디가야해? 주소로 가야함 -->  주소는 참조자료형변수에담아뒀음(cafe) --> 접근(참조)해야함 점(pointer) --> address필드값을 얻고싶다면 getter 호출
		String cafeAddress = cafe.getAddress(); // 오른쪽에서 값을 얻어와서 왼쪽의 변수에 대입!
		// 값을 받아서 사용해야하니 변수에 담을것임, String 타입의 값이 반환되었으니 String 타입으로 선언
		System.out.println(cafeAddress);
		
		// Cafe 클래스의 시그니처메뉴가격 가져다주는 getter 만들고오기
		int price = cafe.getSignatureMenuPrice(); // getter 호출해서 값을 받아오고, 값을 대입해서 사용해야함, int형으로 돌아올것이므로 int모양의 공간으로 받아야함
		System.out.println(price);
		
		String info = cafe.info();
		System.out.println(info); // 모든 필드의 값을 확인해볼땐 이렇게 한번에 확인하자
		
	}
	
	// 추상화 --> 클래스로 묶어서 담음 --> 외부로부터 숨겨주는 것 까지 해야 캡슐화 완료!
	// 필드들은 원래 public 접근제한자를 달아두었다가 아무데서나 고치고 조작할 수 있으니 외부로부터 노출되지 않도록 숨김 --> public을 private로 바꾸면 끝!
	
}
