package com.kh.chap02.encapsulation.model.vo;

	// 클래스 이름을 지을 때 무조건 한눈에 파악이 되어야 함
	// 클래스의 역할에 따라 종류가 달라질것임
	// vo 패키지에 넣어서 구분하거나 클래스 이름 뒤에 VO를 붙이거나 할 수 있음
	
	// VO(Value Object) 사실 아님
	// 3개의 영역으로 구분(필드부, 생성자부, 메소드부) 필드는 클래스가 가지는 변수, 메소드는 클래스가 가지는 기능, 생성자는 내일 배움
public class Cafe {
	
	// String[] menu; // 보통의 카페라면 메뉴가 하나일리가 없으니 배열? 몇칸으로 해야함? 지금은 애매함
	// 지금은 메뉴필드를 안넣을게요, 넣을거면 시즌메뉴 넣을거임
	
	// 필드(Field)부
	/*
	 * 객체가 가질 수 있는 속성을 만들어주는 부분
	 * 
	 * 정보(Data)를 담는 부분
	 * 
	 * 필드 == 멤버변수
	 * 클래스가 가지고 있는 변수라서(클래스의 멤버다!)
	 * 
	 * 접근제한자 자료형 필드식별자; <-- 필드는 이렇게 선언
	 * 
	 */
	
	// 카페가 가질 수 있는 속성들을 변수를 선언해서 만들어보자
	private String name; // 카페 이름
	private String address; // 카페 주소지
	// private String signatureMenu; // 시그니처 메뉴, 이 카페만의 무언가가 있을 수 있음
	private int signatureMenuPrice; // 시그니처 메뉴의 가격
	
	// 필드의 접근제한자를 public이 아니라 다른 것으로 바꿔줌 --> private(비밀스러움), public은 공공재 느낌
	// 이걸 수정했더니 Run에서 난리남! 너무 잘 알고 있었어! 클래스 바깥에서(외부에서) --> 빨간색 확인하러감 --> 안보인다고 함 --> 
	// private으로 선언하면 클래스 외부에서는 (필드에)직접 접근할 수 없음
	
	// 생성자(Constructor)부 --> 이건 내일
	
	// 메소드(Method)부
	/*
	 * 기능(Method)를 구현하는 부분
	 * 카페 클래스는 무슨 메소드들이 들어감? 카페가 할 수 있는 기능! 아침에 오픈, 저녁에 문닫기, 주문받기, 결제하기
	 * 현실세계의 카페가 할 수 있는 기능들이 들어감 --> 객체지향관점에서는 맞는 말
	 * 
	 * VO는 예외, VO는 값을 담는 용도, 이것 이외에 뭔가 있으면 VO가 아니게 됨(카페주문받기나 결제나) --> 이러면 VO가 아닌 다른 친구에서 처리해야 함
	 * 값과 관련된 메소드들이 들어가야함
	 * 
	 * 접근제한자 (예약어) 반환형 메소드식별자() {
	 * 		메소드 호출 시 실행할 코드;
	 * } <-- 메소드는 이렇게 생김, 예약어는 생략 가능, 반환형(return type), 메소드식별자(메소드명, 메소드이름)
	 * 메인메소드에서는 static이 예약어
	 * 그외의 메소드에서는 한번 써봤다
	 * 
	 * 메소드식별자() <-- 이렇게하고 소괄호 안에 매개변수(parameter)가 들어올 수 있음(선택의 영역)
	 * 메소드식별자(매개변수) <-- 변수!!!
	 * 
	 * 접근제한자 : 호출할 수 있는 범위를 제한할 수 있음
	 * 객체의 내부적 관점과 외부적 관점을 얘기할것임
	 * public은 객체(내 클래스) 외부에서 어디에서든 호출할 수 있다는 뜻(내외부적 관점 다 OK)
	 * 
	 * 예약어는 나중에~
	 * 
	 * 반환형 : void => (이 메소드를 호출했을 때 끝나면 호출한 부분으로 돌아감, 그때)return할 때 돌려줄 값이 없음
	 * 		  반환 시 결과 값의 자료형을 명시해준다.
	 * 메소드를 호출했을때 무언가 값을 돌려주고싶을 수가 있음(이경우가 더많음) --> 이럴때는 반환형에 반환 시 결과값의 자료형을 명시해줘야함
	 * 
	 * 식별자는 이름짓는거
	 * 
	 * 매개변수(parameter) : 메소드 호출 시 (호출되는 메소드에 전달할 값이 있으면)전달 값을 받아주는 변수
	 * 					   메소드 범위에서만 사용 가능. 생략 가능(우리는 아직 한번도 해본적 없으니까)
	 * 
	 */
	
	public void open() {
		dishWash();
		cleaning();
		windowCleaning();
	} // Run 클래스에서 보이는 이것을 호출
	
	private void dishWash() {
		System.out.println("깨끗하게 빡빡!!");
	} // 설거지
	
	private void cleaning() {
		System.out.println("청소도 빡빡!!!");
	} // 청소
	
	private void windowCleaning() {
		System.out.println("유리도 빡빡!!");
	} // 유리닦기
	
	// 필드가 만들어지면 기본값들이 들어있을것임
	// 이 필드들에 값을 대입 ,기록, 수정할 수 있는 기능의 메소드들부터 구현
	
	// 데이터를 기록 및 수정하는 기능의 메소드 : setter()
	
	/*
	 * DTO(Data Transfer Object) 클래스에는 무조건 들어가는 메소드 -> setter를 만들어줌
	 * VO -> 일반적으로 setter메소드를 구현하지 않음(VO는 값을 넣어두는 역할만 함! setter가 들어가는 순간 엥 이게 뭔 VO야)
	 * 
	 * DTO는 2달뒤에 배울건데 DTO학습 전까지만 VO클래스에 setter를 구현해서 사용
	 * 
	 * setter만들기 규칙
	 * 
	 * 1. setter메소드는 외부에서 접근이 가능해야 하기 때문에 접근제한자 public을 이용
	 * 2. set필드명으로 식별자를 작성하며 낙타봉표기법(camelCase)을 꼭 지키도록 한다. <-- naming convention
	 * 
	 * 3. (예외상황) 우리는 당분간 항상 모든 필드에 대해서 setter를 구현합니당!
	 * 
	 */
	
	// 고유메뉴의 가격정보를 기록 및 수정할 수 있는 메소드(모든 자바 개발자는 세터를 이 모양으로 만든다)
	// signatureMenuPrice에 담기로 마음먹음
	// 무조건 접근제한자는 public, return type은 void, set 하고 식별자 시작하고 필드명을 붙임
	public void setSignatureMenuPrice(int signatureMenuPrice) { // <-- 얘가 필드를 set 할수있는 setter 메소드
		
		/*
		System.out.println("setter에서 전달 받은 정수 값 : "
						 + signatureMenuPrice); // 모범시민
		*/ // 출력해봤으면 주석처리
		
		// Run 클래스에서 Cafe 모양의 변수 cafe를 선언 하고 new Cafe --> heap에 Cafe 모양의 데이터가 올라감 --> Cafe 모양은 필드가 4개(name, signatureMenu, signatureMenuPrice, address), 메소드도 있음, 주소도 달림(0xcccc) --> cafe에 주소가 담겨있음
		// 원래는 필드를 다 노출시켰다가 외부에서 접근할수없게숨김
		// 필드는 값을 담기 위해 만들었음, 5000원을 sMenu 필드에 대입하고싶음 --> 바깥에서 접근할수는 없고, 객체 내부에서는 접근이 가능함 --> 필드를 조작할 수 있는 메소드를 만들어서 메소드를 통해 필드를 조작하자!
		// 필드에 값을 대입하거나 수정하는 역할을 하는 메소드는 관례(일반)적으로 setter라는 이름을 가짐 --> signatureMenuPrice를 수정하려면 setter 만들고 setSignatureMenuPrice라는 이름을 가져야함
		// 메소드 호출부에서 넘겨줄 값을 적어야함 --> 소괄호안에 넣어서 전달해줌 --> 이 값은 인자값, 인수, argument라고 표현함
		// 메소드 선언부에서는 호출부에서 넘겨줄 값을 받아서 사용해야함 --> 얼마가 넘어올지는 모르지만 공간은 어떻게 사용할 지 알고있음 --> 소괄호 안에서 매개변수(parameter)를 선언
		
		// 값 왜받아옴? 출력하려고? ㄴㄴ 필드가 밖에서 접근이 안되니까 안에서 접근해서 값을 담아주려고 setter를 이용해서 메소드 호출 시 전달받아서 사용하고있음
		// 필드에 5000을 대입하고싶다! --> 필드에 값을 대입하는 방법은?
		
		// 메소드의 호출부에서 사용하는 것은 값(인자값, 인수, arguement)! 선언부에서 사용하는 것은 (매개)변수!
		// Cafe 모양의 cafe 공간에 setPrice(); 메소드가 있음
		// setPrice를 호출하면서 5000의 값을 넘김 --> setPrice의 괄호안에 5000이 들어있을것임 --> cafe내부의 sMenu 필드에 5000을 대입해줘야함 --> 공간에 값을 대입하려면?
		// --> 1. 변수명 2. 대입연산자 3. 값(인데! 5000이라는 정수값은 지금 매개변수 안에 있음, 그러므로 매개변수명을 써야함)
		// 그럼 아래처럼 코드가 됨
		// signatureMenuPrice = signatureMenuPrice; // The assignment to variable signatureMenuPrice has no effect --> 아무일도안일어난다는 뜻
		// 왼쪽의 공간에 오른쪽의 값을 대입하는 것인데, 왼쪽의 공간은? 메소드가 호출된 상태이기 때문에 stack 영역에 올라가있는 상태!(메소드가 호출되면 메모리에 올라가야함) --> 올라가면 매개변수자리가 만들어지고, 5000이 대입되어있음
		// 이 코드는 stack의 영역에 원래 5000이 들어있는데 또 5000을 대입하라고 하는 뜻
		// 우리가 원하는건 heap 영역의 필드 공간에 대입하는것 --> 주소를 알아야(찾아가야) 필드에 값을 대입할 수 있음
		// 이 메소드 안에서 자기 자신이 생겨난 heap 영역안의 주소가 필요함!
		// Scope안에서는 해당 영역안에 있는 지역변수에 대한 우선권이 있음(변수랑 필드명이 다르면 상관없음)
		// 우리에게 필요한 것은 내가 지금 heap에 생겼을건데, 나의 주소(0xcccc)가 필요함! 메인 메소드에서는 그냥 주소를 알 수 있음..
		// 지금은? 여기서 주소값을 알고싶은것임 --> 키워드를 작성
		// System.out.println("내 주소가 뭐지 ? > " + this); // 클래스 내부에서 내가 생성된 heap 영역의 주소값을 알아내는 방법 --> this, 내가 생겨난 객체의 주소값을 가리키는 역할
		// this : 해당 객체의 주소값을 가리키는 역할
		
		// signatureMenuPrice = signatureMenuPrice; --> 이걸 다시 써보자
		// 매개변수에 value값(5000)을 대입해야함, 내가 5000을 대입해야 하는 공간은 heap의 48cf768c에 있음 --> 여기에 가려면?
		// 1. 주소값을 쓴다 2. 주소값은 this로 쓸 수 있다! 3. 참조연산자로 외부에서 보이지 않던 필드에 접근하도록 해줌 4. 어디로 갈 지(필드에 있는 공간) 5. 대입연산자 6. 변수(stack에 있던 인자를 전달 받아둔 공간)
		// 참조연산자를 통하면 내부로 접근할 수 있음
		// this로 대입하는거 먼저 작성하고 if 추가
		// 직접 접근할때는 필드에 바로 값을 대입할수있었음. 이런것을 제어할수있게됨, 값을 대입할때의 조건 설정
		if(signatureMenuPrice <= 1000) { // 필드에 의도하지 않은 값, 정상적이지 않은 값, 잘못된 값이 들어가지 않도록 제어할 수 있음
			System.out.println("정상적이지 않은 값을 입력하셨습니다. 1000 이상의 정수를 입력하세요.");
		} else {
			
			this.signatureMenuPrice = signatureMenuPrice;
			// this를 참조해서 공간을 찾아감, 공간 안에 있는 sMenuPrice --> 매개변수 리터럴값 5000을 대입함
			
		} // 이제 음수나 500 대입하려고 하면 대입은 안되고 메세지 출력
		
	} // 이 세터 메소드 안에서 변수를 선언했을 때, 메소드 호출부에서 넘겨준 정수값이 넘어옴
	// 5000 왜받음? 어따쓸라고? 필드가 밖에서 접근이 안되니까, 안에서 접근해서 값을 담아주려고 함(메소드 호출시의 값을 받아와서 대입해야함)
	// 필드에 값을 대입해야겠다면?
	
	// 외부로부터 숨겨둔 private 필드들은 setter 메소드를 호출해서 값을 기록, 수정할 수 있도록 구현함
	
	// name필드를 기록 및 수정할 수 있는 메소드
	// 접근제한자는 뭘로 시작? setter의 목적 : 외부로부터 메소드를 호출해서 내 내부에 있는 필드값을 수정할 수 있도록 하기 위함
	// 외부에서 부를 수 있어야 하므로 접근제한자는 public
	// 메소드를 호출했을때 필드 값을 바꾸고 싶은 것이고 딱히 메소드로 돌려줄 값이 없으므로 반환타입은 void
	// setter를 만들려고 하므로 무조건 메소드 식별자가 set으로 시작
	// 내가 메소드를 호출함으로써 속성값을 바꿔주고싶은 필드의 이름, 카멜케이스
	public void setName(String name) { //필드값을 대입하거나 수정할 용도의 setter, 메소드 호출 방법, 메소드 사용법을 알려줌
		
		// 메인 메소드의 cafe.setName(); 메소드를 호출하는 쪽에서 필드에 대입하고 싶은 값을 전달할것임 --> 메소드가 있는곳에서는 받아줘야함
		// name 필드에 담아야하니까(문자열값을 받아야하니까) 자료형은 String, 문자열값을 담아둘 수 있도록 변수 선언, 변수명은 보통 필드명과 동일하게 맞춤(안헷갈리게)
		// 메소드의 목적이 Name 필드의 값 세팅이므로 문자열 값이 하나 있어야함, 매개변수의 자리에 달아둠
		// 이렇게 해두면 이 메소드를 호출하려면 무조건 문자열값을 전달해줘야함 --> 문자열을 넣지 않으면 메소드를 호출할 수 없음 --> 지금은 값을 안넣고 호출했기때문에 빨간줄
		// 메소드 호출한 곳에서 "KH카페" 라고 괄호안에 넣어줌
		// 메인 메소드의 메소드 호출부와 클래스의 메소드 선언부 사이에 대입연산자가 하나 있다고 생각하자. 매개변수가 써진 공간에 "KH카페"를 대입해준다~ --> 메소드호출시 전달한 인자값은 메소드 선언부의 매개변수에 대입된다
		// name이라는 매개변수에는 "KH카페"가 들어있음 --> 이것을 필드에 대입해줘야함 --> name 필드에 대입하고싶음 --> name = name; 이 아니고~
		this.name = name; // 클래스가 생긴 필드에 대입하고 싶은거니까, heap에 생긴 주소를 찾아가야 하므로 왼쪽에는 this 키워드를 써준다
		
	}
	
	// 주소를 위한 메소드도 만들어보자
	// 접근제한자가 public인 이유, 외부에서 부를 수 있어야 하니까
	// setAddres의 역할은 값을 전달받아서 필드에 대입해주는 것이므로 메소드 호출 시 딱히 돌려줄 값은 없음 --> 반환형은 void
	// setter 메소드는 set으로 시작, set 다음에는 필드명
	public void setAddress(String address) {
		
		// address 필드를 바꾸는거면 필드에 대입할 값이 필요함 --> 값을 받아와서 사용하기 위해서 매개변수를 만든다(address) --> 변수니까 자료형을 맞춰줘야함(String)
		// 클래스 내부에서 필드값 찾아가는 방법은 this
		// this . 필드명 에 전달받은 address값 대입
		this.address = address;
	} // 여기까지 만들고 Run 클래스에 가서 주소 필드에도 값을 대입해보자
	
	// setter 만들 때 생각해야 할 부분
	/*
	 * 관례 위반 : 두 개 이상의 필드값을 변경하는 메소드는 set이 붙으면 XXX
	 * 필드를 필드값에 대입하는건데 어차피 대입할거니까 따로 안하고
	 * public void setNameAndAddress(String name, String address) {
	 * 		setName(name);
	 * 		setAddress(address);
	 * } <-- 이렇게 두개의 필드값을 한번에 대입하는 것으로 하면 편하지않을까?
	 * 이건 개발자의 마음인데 조심해야 할 점은 이렇게 만들었을 때는 setter가 아니게 됨--> 메소드명이 set으로 시작하면 안됨  -> 코드는 잘 동작함, 프로그램을 동작시키는데는 아무 문제가 없지만 관례 위반
	 * 
	 * 하나의 메소드를 통해서 두개이상의 필드값을 수정하면 세터가 아님
	 * 세터는 반드시 하나의 메소드가 하나의 필드값을 수정해야 함
	 * 
	 * 이런걸 만들고싶으면 이름을 set이 아니라 change나 뭐 다른걸 넣어야함
	 * 
	 */
	
	// 데이터를 반환해주는 기능의 메소드 : getter()
	// 세터는 세팅, 게터는 겟-내놔!(메소드는 명령어로 해석)
	
	/*
	 * 규칙!
	 * 
	 * 1. getter()는 접근제한자 public을 사용한다.
	 * 왜? 밖에서 접근해야하니까
	 * 
	 * 2. get필드명으로 짓되, 낙타봉표기법(camelCase)를 사용한다.(세터는 set으로 시작했으니 게터는 get으로 시작)
	 * 3. 모든 필드에 대해서 반드시 무조건 꼭 다 절대로 만들어주세용!
	 * VO의 경우는 setter가 없음, VO, DTO, 도메인, NTT 등 값을 저장하는 용도의 클래스들은 여러가지가 있는데 값을 저장하고 활용해야 하므로 필드들에 대한 모든 getter가 있어야함
	 * 
	 */
	
	// 메소드를 호출한 곳으로 name필드값을 돌려주고 싶음
	// 외부에서는 name 필드로 직접 접근할수없고, 이 안에서는 접근할 수 있음. 누군가 나를 부르면 나를 호출한 곳으로 name 필드값을 돌려주고싶음
	// 메소드는 밖에서 부를 수 있어야하므로 접근제한자는 public, 반환타입(반환형)은 생각해볼 여지가 있으니 일단은 void, 메소드명은 get으로 시작, name 필드값을 돌려주는 메소드이니 Name
	public String getName() {
		
		// name; <-- 호출한 곳으로 돌아갈때 이것을 들고 돌아가고싶음, 메소드 블록 내부에서 나를 부른 곳으로 돌아가는방법은? switch문 안에서 써봤음 --> return; --> 그냥 리턴이 아니고 값을 가지고 돌아가고싶음, name의 값을 가지고 돌아가고싶으므로 name
		return name; // Void methods cannot return a value, 아까 반환타입을 void라고 썼으므로 안됨 --> 변경해줘야함 --> 내가 돌려줄 값의 자료형은 String이므로 void를 String으로 수정함
		// 지금 KH카페를 넣어둔 상태에서 getName을 호출했음 --> return으로 값을 들고 갔음 --> 아직 출력문을 안썼으니까 값이 안나오는것 --> 값만 받아놓은 상태
		
	} // Run의 메인메소드에서 호출할것임 
	
	// 주소지를 반환해주는 메소드
	// 밖에서 부를 수 있어야하니까 접근제한자가 public, 반환타입은 아직 고려해볼 여지가 있음(void), 반환해줘야하니까 get, 그리고나서 필드명
	public String getAddress() {
		
		// 나를 불렀을때 내가 가진 Address필드값을 반환해주고싶음
		return address;
		// return value;
		// value를 메소드 호출 부분으로 반환하겠다.
		// 메소드의 반환형과 반환하고자 하는 값의 자료형이 일치하는가를 꼭 잘 확인해야함 --> 일단 void를 선언한 것을 String으로 맞춰줌
		
	} // 얘도 호출해서 확인해보자 --> Run의 메인메소드로 가자
	
	public int getSignatureMenuPrice() {
		
		// 변수 이름의 단어가 4개 이상으로 이루어져있다면 고민을 해야 할 필요가 있음
		// 변수는 하나의 값을 담기 위한 공간인데 값을 표현하는 단어가 4개 이상 필요하다? 도대체 어떤 값이길래...쓰기 번거롭기도 하고 나중에 해석하는 사람들이 해석에 오래걸림
		// 정수형 리터럴 5000을 대입한 친구를 return하고싶음
		return signatureMenuPrice; // signatureMenuPrice <-- 얘가 정수니까 반환타입도 정수(int)로 작성
		
	} // 메인메소드로 다시 ㄱㄱ
	
	// getter() / setter()다만들었당 ! ==> 캡슐화가 끝남(문법적인 관례에 의하면)
	// 일반적으로, 지금 단계에서 이야기하면 그렇다. 진짜로 끝난 것은 아님
	
	// 캡슐화 방법 자체는 크게 어려운 것이 아님
	/*
	 * 1. 객체가 가지고 있는 값을 숨긴다. => 필드의 접근제한자를 public대신 private으로 선언한다.
	 * 2. 메소드를 통해 필드에 접근할 수 있도록 만들어준다 => getter() / setter() 구현
	 * private으로 바뀌는 순간 외부에서 내부의 필드로 접근할 수 없게 되므로
	 * 
	 * 지금 단계에서는 이제부터 어려울 수 있음
	 * 
	 * 캡슐화를 통해 얻을 수 있는 가장 큰 장점
	 * 데이터를 숨김(외부로부터 내 안에 있는 데이터를 숨김) -> 객체간의 결합도를 낮춤(지금은 어려울 수 있음! --> 캡슐화의 목적은 이게 제일 큼) -> 책임을 분리시킨다.
	 * 어제 한 그릇닦기 설거지하기 등 메소드삼총사를 떠올려보자.
	 * public은 서로간의 상호결합도가 높은 상태, 수정이 일어나면 전부 수정해야하는데, 숨기면 private의 안에것만 수정하면됨
	 * 
	 * private 필드 삼총사를 가지고 있는 것은 Cafe라는 클래스, 얘네는 Cafe의 것(Cafe스코프안에있으니까)
	 * 필드는 카페껀데 캡슐화 하기 이전에는 카페 밖에서 카페것을 작업함
	 * 캡슐화하면 카페꺼는 밖에서 수정못함 --> 작업은 이제 카페 안에서(카페가) 작업함
	 * 밖에서는 카페한테 데이터를 요청하는 것이 아니라 작업을 요청하는 것이 됨(세팅해줘! -> setter, 나한테 줘! -> getter)
	 * 작업을 수행하던 주체가 바깥에서 카페로(카페안에서) 바뀜(private 필드들은 카페꺼니까)
	 * 자기것은 자기가 작업하는 것으로 객체간의 결합도를 낮추는 것이 캡슐화의 목적(getter setter 만드는게목적이아니고)
	 * 책임을 분리시켜 --> 수정이 일어나는 것은 수정이 일어난 곳에서만 수정하면 되도록 하자 --> 유지보수를 용이하게 하는 방법
	 * 정보은닉은 이렇게 해서 얻을 수 있는 장점 중의 하나
	 * 
	 */
	
	// 객체를 객체가 어떤 데이터를 가지고 있어야 하는가? 에 집중
	// 캡슐화는? 이 객체가 어떤 책임을 가지고 있는가? 어떠한 책임을 수행하는가? 초점이 있음 --> 데이터에서 조금 더 가야함 --> 내꺼 내가 관리하자는게 목적, 그러면 밖에서 들어오는 값을 내꺼에 들어갈 수 있는지 없는지 스스로 검증해서 작업 처리
	
	// 캡슐화는 끝, 불편한 게 있음
	// 필드가 많아지면 번거로워질수도 있다 --> 모든 필드 값을 확인할 수 있도록 반환해주는 메소드 생성
	// 밖에서 불러야하니까 접근제한자는 public, 반환타입은 고민하고나서 정하자 일단 void, 메소드명은 info로 하자
	public String info() {
		
		// 이걸 부르면 필드를 다 돌려주고 싶음
		// name, address, signatureMenuPrice --> 얘네를 한꺼번에!
		// 문제는? 하나만 하면 반환타입을 맞출 수 있는데 세개를 하면 어떻게? 자료형이 다 다른데
		// return name, address, signatureMenuPrice; 이건 불가능
		// return 할 때 반환할 수 있는 값 단 한개(기본적으로)
		// 그럼 이 세개를 하나로 합쳐주자! --> 우리의 목적은 필드값들을 콘솔창에 출력하고싶은것임 --> 하나밖에 못들어간다면 하나로 만들어주지뭐!
		// 제일 쉬운 방법은 문자열로 합시다ㅣ
		String info = "[name 필드값 : " + name + ", address 필드값 : " + address + ", signatureMenuPrice : " + signatureMenuPrice + "]"; // 문자열과 다른 자료형을 +하면 문자열이 됨
		// info 호출하면 모든 필드의 값을 문자열로 합친 값을 돌려줄것임!
		return info; // 싹 합쳐진 문자열을 반환해주자! --> 반환타입 수정해야할듯? 문자열 타입의 값을 들고 돌아갈 것이므로 void를 String으로 수정
		
	} // Run 클래스의 메인메소드에서 불러서 해보자
	
} // 클래스안에 선생님이 생각하는 카페를 구현했다! 카페가 가질 수 있는 속성과 행동을 카페라는 이름의 클래스에 묶어둠
	// 근데 이렇게 전부 public으로 해두면 유지보수가 힘들고, 보안이 허술해짐 --> 외부적 관점으로 보면 어디에서든 접근과 조회 가능 --> 외부에 노출되어 있으면 값이 변질되고 오염될 수 있음
	// 캡슐화 해서 필드와 메소드를 만들었으면 데이터들을 어떻게 외부로부터 숨길것인가를 고민해야함
	// 일반적인 캡슐화 방법은 이미 정해져있음, 어떻게 할 지 설명하고, 캡슐화 하면 어떤 점들이 좋아지는지 얘기하실 것
