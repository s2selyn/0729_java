package com.kh.chap06.controller;

public class OverloadingController {

	/*
	 * 메소드 오버로딩(Method Overloading) ☆★☆ => 면접 단골 질문
	 * 
	 * - 하나의 클래스 안에 동일한 메소드 식별자로 여러 개의 메소드들을 정의할 수 있는 기술!
	 * - 매개변수 자료형의 개수, 순서, 종류 다르게 작성해야함!
	 * - 참고로 매개변수 식별자, 접근제한자, 반환타입은 메소드 오버로딩에 아무런 영향을 끼치지 않음
	 * 
	 * 구현할때에는 메소드를 만들어주면서 매개변수가 중요함
	 * 매개변수 자료형의 개수, 순서, 종류 다르게 작성해야야 구현할 수 있음
	 * 
	 */
	
	// 메소드명은 test로 통일
	public void test() {
		System.out.println("메소드 오버로딩 테스트 1");
	}
	
	// 동일한 이름으로 메소드를 선언해봄
	// Duplicate method test() in type OverloadingController
	// type을 자료형, 클래스로 해석 --> OverloadingController 클래스안에 test라는 이름을 가진 메소드는 중복인데? 이름이 중복되는데? 똑같은 이름이 있는데?
	// 오버로딩을 구현하기 위해서는 매개변수를 다르게 만들어줘야함
	public void test(int num) { // 정수형의 매개변수를 하나 넣어줌
		System.out.println("메소드 오버로딩 테스트 2");
	} // 실행하는 곳에서 이 메소드를 호출하고싶으면? 부르는 쪽에서 test 메소드를 호출하는데, 여기서는 인자값을 전달해주는데 어떤 모양의 인자값? 정수형 인자값! --> 2를 입력해서 호출할 수 있음
	// 메소드 호출부에서는 반드시 인자값(arguments)이라고 표현해줘야함 --> 이 상황에서는 정수형 인자값을 메소드 호출과 동시에 전달해줍니다 라고 표현 --> 여기서는 변수를 넘길 수 없음! 호출 시 넘길 수 있는 것은 항상 값
	// 반대로 메소드 선언부에서는 메소드 호출시 전달된 인자값을 매개변수로 받아주어야 합니다 라고 표현
	// 변수와 값은 명확하게 구분할 것! 호출하는데서 넣는 것은 값! 선언되는데서 받는 것은 변수!
	
	// 오버로딩을 구현할 때 매개변수를 다르게 해야한다~
	// 마치 println처럼 인자를 하나만 넘기는데도 매개변수의 자료형이 다르다면 동일한 이름으로 구현이 가능함 --> 매개변수의 자료형으로 오버로딩을 구현함
	public void test(String str) {
		System.out.println("메소드 오버로딩 테스트 3");
	}
	
	// 매개변수의 개수를 다르게해보자
	public void test(int a, int b) {
		System.out.println("메소드 오버로딩 테스트 4");
	} // 동일한 자료형이라도, 매개변수의 개수를 증가시키면 동일한 이름으로 또다른 메소드를 선언할수있음
	// 얘를 호출할때는 정수 두개를 인자로 전달하면됨, 컴파일러가 이 메소드를 부르는거라고 인식
	
	/*
	public void test(int c, int d) {
		컴파일러 입장에서 메소드가 호출되었을때 누구를 부르는건지 알수없게됨
	}
	오버로딩을 구현하는 데 있어 매개변수명은 조건이 아니라는 뜻
	매개변수 식별자와는 상관없이(변수명이 달라도)
	자료형의 개수, 순서가 동일하기 때문에 구현이 불가능함
	*/
	
	/*
	public String test(int c, int d) {
		반환형을 바꿔도 컴파일러는 구분할 수 없음
	}
	반환형과는 상관없이 매개변수의 개수와 순서를 항상 다르게 작성해야함
	*/
	
	/*
	private void test(int c, int d) {
		이것도 안됨, 바깥이 중요한게아님, 안에서 부를수도있음, 내부에서 부를때 구분이 불가능해짐
	}
	접근제한자와는 상관없이 매개변수의 개수와 순서를 항상 다르게 작성해야함
	*/
	
	public void test(int a, String b) {} // 매개변수 개수가 두개인데, 앞에가 정수라도 뒤에가 기존에 존재하는 친구랑 다른 타입의 매개변수다 <-- 이건 가능(자료형이 다르니까)
	public void test(String b, int a) {} // 똑같이 String, int를 받는데 순서를 앞뒤 바꾸면 <-- 이것도 가능(부르는 쪽 입장에서도 구분됨, int, String으로 부르면 위에거, String, int로 부르면 아래거)
	// 메소드 호출하는 시점에서 구분이 되면 구현 가능, 구분이 안되면 구현 불가능
	
}
