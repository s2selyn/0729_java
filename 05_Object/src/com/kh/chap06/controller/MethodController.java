package com.kh.chap06.controller;

public class MethodController {
	/*
	 * 클래스의 용도는 자료형(우리는 계속 자료형으로 쓰고있음, 사람처럼, 커피처럼, 멤버처럼, 생긴 자료형)
	 * 자바에서 제일 중요한 것 타입!
	 */
	
	/*
	 * 메소드(Method)
	 * 클래스가 가지고 있는 기능 == 멤버 함수 : 입력값을 가지고 특정동작을 수행한 뒤 결과물을 내놓는다.
	 * 
	 * 클래스의 멤버 중에서 클래스가 가지고 있는(멤버)의 요소, 멤버 중에서 함수 라고 해서 멤버함수
	 * 
	 * 함수만 생각해보기
	 * 수학익힘책에서의 함수란? 마술상자! 입력값을 가지고 뭐시기뭐시기(함수에따라다름)를 해서 출력값이 나옴
	 * 들어가는 것이 정해져있으면 무조건 나오는 것이 정해져있음
	 * 일반적으로 생각했을 때의 함수는? : 입력값을 가지고 특정동작을 수행한 뒤 결과물을 내놓는다.
	 * 
	 * 프로그래밍 언어에서의 함수 : 특정 작업을 수행하기 위해서 만들어진 코드 블록(뭉치, 덩어리)
	 * 함수의 특징 세가지
	 * 1. 재사용성
	 * 함수를 선언하고 난 뒤에 한번 쓴다고 사라지는게 아니므로 한번 선언하고 나면 사용하고싶을때마다 호출해서 반복해서 사용할수있음
	 * 코드를 뭉쳐놓은 것이므로, 원래라면 코드를 계속 따로 썼어야겠지. 하나에 몰아놓으니 재사용성이 높아지고 중복도 제거됨
	 * 
	 * 2. 모듈화
	 * 부품으로 만든다는뜻, 복잡한 해결해야 할 문제가 코드로 쓰려면 어려우니까 작은 단위(부품)로 나눠서 쪼개쓰면 만들어둔것을 여기저기서 쓸수있음
	 * 이것도 재사용성을 높아진다고 얘기할 수 있음
	 * 
	 * 일반적으로 프로그래밍 언어에서 이야기하는 함수와는 차이가 있음
	 * (개념적으로는)객체지향 프로그래밍에서의 메소드(란) : 객체가 수행할 수 있는 행동(액션, 기능)을 정의한 코드 블록
	 * 추상적이라 어려우니 처음 받아들일 때는 기술적으로 접근해보자
	 * 자바라는 프로그래밍 언어에서 클래스의 의미, 용도는?
	 * 
	 * 메소드는 특정 자료형에서만 사용이 가능한 함수 (클래스가 가지는 함수라는 의미로 메소드라고 지음, 그리스어라네요)
	 * 클래스가 자료형이기 때문에 이렇게 부름
	 * 자료형에 따라서 (현실에서도) 수행할 수 있는 기능이 다름
	 * 더하기 연산(기능)은 정수처럼 생긴 애들이 할 수 있음, 문자처럼 생긴 애들은 문자만 할 수 있는 기능들이 있고...
	 * 
	 * [ 표현법 ]
	 * 
	 * 접근제한자 예약어 반환형 메소드식별자(매개변수의자료형 매개변수식별자) {
	 * 		수행할 코드;
	 * 		return 반환값;
	 * }
	 * {}의 안을 메소드 블록 안이라고 부름
	 * 
	 * 일반적으로 생략 가능한 것 : 예약어, 매개변수, return문(반환타입이 void일 경우에만)
	 * (첫번째 주의할 점)반환형 : return시 반환할 값의 자료형
	 * (두번째 주의할 점)호출할 때 메소드 전달 인자값 => (반드시 메소드가 생긴대로)매개변수의 자료형과 개수가 정확하게!!! 일치해야함 ☆
	 * 
	 * 메소드의 최대 장점 : 한 번 정의해두면 필요할 때마다 언제든 호출이 가능~~~
	 * 
	 */
	
	// 아까 했던 더하기 프로그램을 생각
	// 더하기를 해서 결과를 반환해주는 코드 블럭을 만들고 싶다.
	// 함수를 선언해야함, 접근제한자, 반환타입, 함수명, (), {} 으로 선언
	public int add(int a, int b) { // 여기를 메소드 시그니처라고함(접근제한자, 반환타입, 함수명, 매개변수까지)
		// 반환타입은 아직 모르겠으니 일단 void --> 이후에 int로 수정함
		// 이 안을 본문이라고 함, 메소드 바디(함수 호출했을때 실행시키고 싶은 코드를 적는 곳)
		
		// 더하기를 해서 결과를 반환해주는 무언가를 만들고 싶은 것 --> 더하기를 할거면 피연산자가 필요함, 이 함수를 호출할때는 내가 무언가 두개의 정수값을 받아야겠다(필요하겠다) --> 매개변수자리에 그 내용을 작성
		// 우리가 하고싶은건 더하기
		int sum = a + b; // 메소드바디
		
		// 이걸하고 나서는 더하기한 결과를 돌려주고 싶은 것
		return sum; // 반환값, int형을 돌려줘야하므로 반환타입 int로 수정
		
	} // 더하기를 해서 더하기 결과값을 반환해주는 함수를 만들었음
	// 이 함수를 만들어두면 이 함수가 필요한곳 어디든지 이 함수를 호출해서 사용할수있음 --> Run 클래스에서 부름
	
	// 메소드를 여러가지 형태로 선언하고 사용(호출)해볼것임
	// 1. 매개변수가 존재하지 않고 반환값도 존재하지 않는 메소드
	// 객체지향파트 들어오기 이전까지 가장 많이 사용한 형태
	// 외부에서 호출이 가능해야하므로 접근제한자는 public
	// 항상 호출하면 그안에서 해결했기 때문에 반환할 만한 것이 없어서 void로 반환타입을 적음
	// 메소드식별자를 적을때도 그때는 메소드나 클래스의 의미를 몰랐기 때문에 method1() 이랬음
	public void method1() {
		
		// 이 안에서 보편적으로 했던 작업은 출력문으로 출력하기
		System.out.println("매개변수와 반환값이 둘 다 존재하지 않습니다.");
		
		// 원래 return은 항상 있음, 있어야 돌아감
		// return; // 얘도 결국 클래스의 기본생성자같은것. 지금 기본생성자 안만들었는데 Run에서 불렀음 --> JVM이 만들어준것
		// return도 우리가 안적고 생략해도 JVM이 만들어줬음
		// returnType이 void일 경우 return문을 생략 할 수 있다. 사실 항상 존재함
		
	} // 이렇게 하고(선언하고) 나서 메인 메소드로 갔었음 --> Run 클래스 다녀오자
	
	// getter / setter 할 때 사용하기 시작해봄
	// 2. 매개변수는 존재하지 않지만 반환값은 존재하는 메소드(getter가 이렇게 생겼음)
	// 매개변수는 없지만 리턴하고 값은 돌아감
	/*
	public String getName() {
		return "이름";
	}
	
	public int getAge() {
		return 23;
	}
	*/
	
	public String method2() {
		
		System.out.println("매개변수는 존재하지 않지만 반환값은 존재합니다.");
		// 여기까지만 작성하면 This method must return a result of type String 메세지가 뜸
		// 이 메소드는 문자열 타입의 결과를 반드시 돌려줘야한다 --> 반환타입에 String이 적혀있으니까
		return "returnValue"; // 반환타입이 void가 아니게 된 순간부터 반드시 return 구문이 꼭 붙어야 함
		// return을 안붙일수있는건 오로지 void뿐
		
	} // 메인메소드(Run)에서 불러보고오자
	
	public String method3() {
		
		// 문자열값을 반환할것임
		return method2();
		
	}
	
	//만약에 프린트문이 이렇게 생겼다고 가정해보자
	public void println(String parameter) {
		System.out.println(parameter);
	}
	
	// 3. 매개변수는 존재하지만 반환값은 존재하지 않는 메소드(setter가 이렇게 생겼음)
	/*
	public void setName() {
		this.name = name;
	}
	*/
	
	public void mehtod4(int num) { // 뭔가를 전달받아서 뭔가를 하겠지, 할일이 있으니까 받았겠지
		System.out.println("매개변수는 존재하고 반환값은 존재하지 않습니다."); 
		System.out.println("전달받은값 + 100 : " + (num + 100));
	} // 불러보자
	
	// 4. 매개변수도 존재하고 반환값도 존재하는 메소드(우리가 가장 많이 사용하게될것)
	public int method5(int num) {
		System.out.println("매개변수도 있어요~ 반환값도 있어요 ~ ");
		return num + 50;
	} // 이 모양을 많이 사용할것임, 정석적인 함수라면 입력값이 있으면 반드시 뭔가 출력값도 내줄것(x가 들어가면 y가 나오겠지, 뭘 수행하려고 함수를 만든거니까)
	// x가 들어가면 y가 나올 것이고, y를 받아서 무언가를 하겠지~
	
	// 당분간 가장 많이 만들 메소드는 getter / setter, 값을 필드(변수)에 세팅하고, 필드에 있는 값을 반환해주는 메소드들
	
	// 메소드 사용시 주의점 --> a는 b를 부르고 b는 a는 부르는 상황이 되었다면? --> StackOverflow --> 메소드가 끝나면 스택에서 빠져서 공간을 만들어줘야하는데 상호간에 부르면서 계속 쌓이다가 stack이 터짐
	public void a() {
		System.out.println("메소드 a호출!");
		b();
	}
	
	public void b() {
		System.out.println("메소드 b호출!");
		a();
	}
	
	// 내가 나자신을 부르는 경우(재귀호출) --> 이것도 똑같이 계속 부르다가 stack 터짐
	
	// 우리에게 좀 더 중요한 메소드 만들어보기
	// 앞에서는 항상 메소드를 setter를 만들 경우에도 메소드 호출 시 전달한 인자값을 기본자료형 값들을 보냈음
	
	// mc.test(mc); 이렇게 불러보려고 함, test를 호출하면서 인자값(변수값)으로 mc 전달해보기
	// 밖에서 불렀으니 접근제한자는 public
	// 딱히 반환받은거 없음 반환타입은 void
	// 메소드명 test
	// test를 호출하면서 인자값을 전달함, 인자값을 받으려면 매개변수를 만들어야함 --> 매개변수 만드려면? 인자값의 자료형과 식별자를 써야함 --> 자료형은 뭐임? 어떻게 생긴 친구를 넘김? 무슨 모양의 값을 넘김? MethodController처럼 생긴 애를 넘김
	// mc의 타입이 MethodController --> 자료형은 MethodController --> 식별자는? mc로 함
	public void test(MethodController mc) {
		mc.method1();
	} // 호출해보기
	
	// 메소드를 그냥 선언하지 않고 static을 붙여서 선언
	public static void staticMethod() {
		System.out.println("안녕 나는 스태틱 메소드임");
	} // 스태틱은 공유의 목적 --> 메모리의 스태틱 영역에 올라감 --> 사용할 때? 일반적인 메소드 호출구문과 다른점 : 생성없이~
	
	public void haha(int num) {
		
	}
	
}
