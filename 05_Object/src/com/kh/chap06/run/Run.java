package com.kh.chap06.run;

import java.util.Arrays;

import com.kh.chap06.controller.Human;
import com.kh.chap06.controller.MethodController;
import com.kh.chap06.controller.OverloadingController;

public class Run {
	
	public static void main(String[] args) {
		
		// 어제 배운거 생각해보기
		// 프로그램에서 현실 세계에 있는 사람을 만든다 --> 코드로 어떻게 만듦?
		Human human = new Human();
		// 이걸 어떻게 표현할까? --> 오른쪽이 실질적으로 객체생성 --> heap 메모리에 올라가는 시기는? new 만났을 때 메모리에적재가 되면서
		// new 연산자와 함께 Human 클래스의 기본생성자를 호출 --> Human 타입의 객체를 생성함 --> Human 타입의 human 공간에 주소를 대입
		
		// 오늘 중점적으로 할 이야기는 method
		// 헬로월드할때부터 썼음. 그때는 메소드를 어떻게 썼더라? 하나의 기능단위!
		// 
		// 메소드 얘기를 안하면 코드를 짤수가없음, 메소드 얘기를 안하면 메인 메소드 안에서 전부 코드를 적어야함 --> 메인 안에 모든 메소드를 넣으면 자바의 개발 방식과는 동떨어짐
		// 객체지향에서는 중요한게 기능을 수행하는 주체
		// 객체지향프로그래밍에서의 메소드는 메소드를 가지고 있는, 실행하는 주체가 필요
		
		/*
		Human 이승철 = new Human(); // 인사하는 기능은 사람 객체가 있어야 수행할수있음
		이승철.hi();
		Human 홍길동 = new Human(); // 사람을 가지고 만든 객체라면 누구든 이 기능을 이용할수있음
		홍길동.hi();
		이승철.nextInt(); // 사람처럼생긴친구가 이런 기능들을 수행 할 수는 없음, Human 클래스에는 이런 메소드가 존재하지 않으므로
		이승철.nextLine();
		홍길동.println();
		*/
		
		/*
		MethodController mc = new MethodController();
		int a = mc.add(1, 2);
		int b = mc.add(2, 3);
		int c = mc.add(5, 6);
		int d = mc.add(a, b);
		int e = mc.add(c, d);
		System.out.println("총합 : " + e);
		*/
		
		// 내가 반복적으로 재사용하고싶은 코드 덩어리를 일단 프로그래밍 언어에서는 함수라고 부름
		// 우리가 지금 이야기하고자 하는 것은 메소드, 일반적인 프로그래밍 언어에서 이야기하는 함수와는 차이가 있음 --> MethodControll 클래스로 다시 감
		
		// 메소드 호출을 위해서 자료형을 쓰고 변수명(별칭짓기)
		// 대입연산자
		// new는 뭔지 몰랐지만 생성한다고 했었음, 알고보니 객체를 생성하는거였음
		// 기본생성자를 써서 생성된 객체의 주소를 변수에 대입
		MethodController mc = new MethodController();
		// int[] dd = new int[3]; // <-- 얘도 결국 같은 형태였음, 자바에서는 배열도 객체(사실 전부 객체)
		// int[] <-- 자료형, dd <-- 변수명, new <-- 객체 생성, int[3] <-- 크기를 12칸(4바이트 3개), 객체의 주소값을 대입(=)
		// 변수이름 참조연산자 메소드이름 으로 메소드 호출
		// mc.method1();
		// mc.method2(); // 호출했을때 출력문은 출력되는데 가져오는 반환값(문자열값)을 출력하고싶으면? 메소드를 호출했을때 반환받은 결과값을?
		
		/*
		 * 그림그리기
		 * 
		 * MethodController mc = new MethodController();
		 * stack에 mc라는 이름의 공간이 생김
		 * new 할때 heap 영역에 공간이 생김(필드가 있었다면 이때 생김, 지금은 필드가 없음)
		 * 기본생성자 호출됨, 주소값을 mc 공간에 대입, mc는 heap의 공간을 가리키고있음
		 * 
		 * method1을 부름 --> stack에 올라갔다가 끝나면 사라짐
		 * method2를 부름 --> 출력문 출력함. returnValue가 있었음(부른 곳으로 돌아와서 갖고있음) --> 끝나면 메소드가 메모리에서 사라짐 --> returnValue도 같이 사라짐
		 * 
		 * 기본자료형도 마찬가지임(아래는 이해를 돕기 위해 한발자국 더 설명)
		 * method2를 호출했을때 돌아오는 것(return value)은? --> 반환값을 String을 들고감, 얘는 참조자료형, 참조자료형이니까 String을 가리키고 있는 주소값이 돌아올것임(String은 사실 저기 어딘가에 생겨났음)
		 * 주소값이 왔는데, 메소드가 사라지면 주소값도 사라져버림 --> 가리키는 것이 없으므로 ㅂㅂ --> 사라지기 전에 누군가가 가리키고 있어야 함 --> 누군가가 가리키게 하는 방법은? 저장, 변수를 만들어서 변수에 저장할것임 --> 타입은 메소드가 돌려주는 모양새가 String이니까 String 타입으로 받아줘야함
		 * 
		 */
		
		// String returnValue = mc.method2();
		// System.out.println(returnValue);
		// 두고두고 쓸 거 아닌데? (변수의 목적에는 재활용도 있음) 한번 출력만 해주고 끝날건데? 그러면 값 자체로 사용할수도 있음
		// System.out.println(mc.method2()); // 이건 우리가 헷갈릴수도 있겠따!! 여기 설명 ㄱㄱ
		
		/*
		 * 그림그리기(stack만)
		 * 출력 메소드를 호출함 --> println 메소드가 메모리에 올라감 --> 출력문에서 자기 일을 하다보니(값 필요함 상태임), 안에 전달된 인자가 메소드2를 호출함 --> println 스택의 위에 method2가 또 올라가서 쌓임
		 * method2는 출력문 출력 --> 위에있으니 method2가 먼저 돈다 --> method2 내부의 출력문을 출력하고나서 return값("returnValue")을 돌려줌 --> return값("returnValue")이 println의 인자로 들어감
		 * method2는 종료되고 스택에서 사라짐 --> println이 "returnValue" 출력함 --> return은 위에 있던 애가 자기 방 뺄 때 밑에 내려주는거 --> 여러개 쌓이면 위에거 없어지면 리턴값 아래로 내려주고, 내려준 메소드 없어지면 또 밑으로 리턴값 내려주고... --> 이거 구현해보러 method3만들었음
		 * 
		 */
		
		// System.out.println("method3 호출 결과 : " + mc.method3()); // 출력 메소드의 인자로 method3을 호출
		// 이거 실행하면 --> 매개변수는 존재하지 않지만 반환값은 존재합니다.
		// method3 호출 결과 : returnValue <-- 라고 출력됨
		/*
		 * 여기 그림그려보기
		 * println 메소드를 호출함, 출력하는 용도의 메소드, println 매개변수에 인자값으로 출력할 값을 받음, 그래야 매개변수로 받은 것을 출력
		 * print문에 "method3 호출 결과 : " + mc.method3() 라고 보냄 --> 만약에 println()이 우리가 만든 것 처럼 생겼다면? --> MC클래스에서 만들고옴
		 * 
		 */
		
		// mc.println("method3 호출 결과 : " + mc.method3()); // 우리가 만든 메소드를 호출한다고 생각
		// 콘솔에 --> 매개변수는 졵재하지 않지만 반환값은 존재합니다.
		// method3 호출 결과 : returnValue <-- 라고 출력됨
		// 우리가 만든 println 메소드를 호출할 때, 매개변수에 인자값이 대입되어야함, 그래야 변수로 받은 것을 메소드 안에서 출력해줄것임
		// String parameter = "method3 호출 결과 : " + mc.method3(); // 이거랑 같은 말임, 메소드의 매개변수(공간)에 println을 호출할 때 전달하는 값을 대입하겠다는 뜻
		// println 메소드는 메모리에 올라감과 동시에 초기화가 끝나야함(어제 얘기했음, 공간이 생기고 value가 들어와야함, 안그러면 블록 내부로 들어갈 수 없음) --> 그러므로 parameter 라는 변수에 "method3 호출 결과 : " + mc.method3(); 가 대입이 되어야함! 메소드 호출과 동시에!!
		// 변수의 공간에 대입되려면? 대입연산자 오른쪽이 끝나야(대입될 값이 완성되어야) 가능함
		// println이 올라가면서 대입연산자의 오른쪽이 수행이 되어야하므로 method3이 println 메소드 위에 올라감 --> method3은 아무것도 안하지만 반환(method2의 값)하는 메소드(자바에서는 값밖에 왔다갔다못함, 메소드 호출했을때 메소드가 돌려줄수있는것은 값밖에 없음!), 값이 생겨야 return할수있음
		// 근데 값이 들어가야 할 부분에 method2를 호출하는 로직이 들어옴 --> method2의 호출부분이 값이 될때까지 method3은 못돌아감 --> 메소드 3이 끝나지 않은 상태(메모리에 적재되어있음)에서 메소드 2가 또 올라감(메모리에 메소드가 안끝나고 쌓이는 중)
		// 메소드 2가 먼저 돌아야 함, 내부의 출력문 출력 --> 출력하고 나서 returnValue(value 값)를 돌려줄게 하면서 메소드블록이 끝남 --> 메소드 2는 사라져야함 --> 메소드 2을 부른 곳(메소드 3)에 returnValue가 return 값이 되어 돌아감 --> 비로소 return이 값이되어서 부른 곳으로 돌아갈수있게됨 --> 메소드 3을 부른곳(println이 불렀음)으로 돌아가면서 메소드3은 날아가고 returnValue는 println의 소괄호 안으로 들어감
		// mc.method3() 이부분에 returnValue가 들어감 --> returnValue가 앞의 "method3 호출 결과 : " 문자열과 더해져서 println의 인자로 전달됨 --> 비로소 대입연산자의 우항이 끝남 --> parameter(매개변수) 자리에 들어감 --> 출력되고 println도 메모리에서 사라짐, 프로그램 끝남
		
		// mc.mehtod4(2); // method4(); 라고 호출해봄 --> method4의 생김새는? 메소드시그니처가 어떻게 생김? 중요한건 매개변수, 매개변수에 정수형 변수가 하나 있음, 이 메소드는 메소드를 호출(사용)하기 위해서 반드시 정수값을 하나 전달해줘야함(그래야 쓸 수 있음), int num은 지역변수이고, 초기화되지않으면 쓸 수 없음
		// 메소드시그니처(메소드만의 고유한 식별할수있는 값)를 메소드사용법이라고 표현하는 사람도 있음
		
		// int result = mc.method5(5); // 반드시 정수값을 하나 넘겨줘야하는 메소드, 그러고나면 반환값도 돌아오는 메소드
		// System.out.println(result); // 반환값을 가지고 또다른 작업
		
		// mc.a();
		
		// MethodController mc = mc;
		// ☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★
		// mc.test(mc); // test라는 메소드를 만들어서 인자값으로 mc라는 변수값을 전달해봄
		// 실행하면 매개변수와 반환값이 둘 다 존재하지 않습니다. <-- 이게 출력됨
		// 이걸 실행하면 마주하게되는 상황을 네글자로? --> 얕은 복사(서로 다른 변수가 같은 주소값을 가리킴)
		// MethodController mc = new MethodController(); 에서 --> stack영역에 MethodController 타입의 값을 담을 수 있는 변수를 만들어서 mc라는 이름을 붙임
		// heap에는 MethodController 객체를 만들어서 필드는 없고 메소드들만 여러개 있음 --> 이아이의 주소값을 mc에 담아둠
		// mc.test(mc); 에서 --> mc 주소값을 찾아가서 test라는 메소드를 호출함 --> test는 stack에 올라감, 호출하면서 인자값을 전달했으므로 MethodController의 매개변수에 들어가야함(MethodController mc = mc; 이걸 하겠다는 뜻)
		// 마침 매개변수명이 mc지만 위에서 만든 mc(heap에 생긴 객체의 주소값이 담김)와는 블럭이 다르니까 상관없음(지금은 test 블럭 안에 mc 매개변수자리가 생김)
		// test 메소드 영역 안에 매개변수 mc영역이 생겼음 --> 매개변수는 MethodController mc 이렇게 생겼고, 여기(매개변수 mc, test 메소드 내부에 생긴 mc)에 mc를 대입한건데, 여기(매개변수 mc, test 메소드 내부에 생긴 mc)에는 무슨값이 대입? --> 매개변수로 전달되는 인자값 mc가 의미하는 것은 heap에 생긴 MethodController 객체의 주소값
		// 마침 매개변수 타입(형태, 자료형)도 MethodController의 타입을 받을 수 있음 --> 똑같이 heap에 생긴 객체의 주소값이 들어감
		// test 메소드 내부의 mc.method1(); 에 의해서 메소드 1이 호출됨 --> 여기에서 mc는? test 메소드 블록 안에서의 mc는 누구를 가리키느냐? 주소값이 똑같은 게 들어갔으니까 결국 얘도 heap에 있는 객체를 가리킴 --> 결국 다른 객체, 다른 stack 스코프에서 가리키고 있는 대상이 같음, 같은 대상이 가지고 있는 기능을 호출함 --> 얕은 복사와 같은 효과(상태, 개념) --> 같은 주소를 가리킴, 배열 생각(배열도 객체)
		// 변수에 들어가있는 값은 같음, 참조자료형은 주소값밖에 못들어감, mc.test(mc);에서 넘긴 mc는 주소값이 넘어감
		// 주소값은 참조하기 위한 용도로 가져다가 쓰는것
		
		// 복습하자~~~
		
		// 객체를 생성하지 않고 메서드를 호출 할 수 이씀
		Math.random();
		// Arrays.toString(new int[2]);
		
		int[] arr = {2, 3}; // 우항이 null이면 null, {}(빈배열)이면 [] 출력됨
		// System.out.println(Arrays.toString(arr));
		// 얘는 어떻게 출력 결과가 [2, 3] 이렇게 나오지?
		// 건방진메소드는 스태틱 메소드, 객체 생성없이 바로 참조해서 호출가능, 인자값으로 arr를 넘김, toString에는 인자로 항상 배열의 주소값이 들어감
		// public static 반환타입 toString(매개변수는배열) <-- 이렇게 생겼겠네? 까보니 반환타입이 문자형임(String), 배열을 주면 String으로 바꿔주는 친구 --> 매개변수는 int형 배열을 받음 --> 실질적으로 들어가는 것은 int형 배열이 생겨난 heap 영역의 주소값
		// 이 메소드 안에서 일어나는 일을 읽어주심
		
		// 전세계 모든 자바개발자가 사용하는 toString 메소드, 잘만든듯~
		// 이 메소드를 구현하는데 필요한 요소가 변수, 조건문, 반복문 뿐임(뭐 세상 모든 프로그램도 그렇고, 여기서 변수가 제일 중요함)
		// Arrays는 자바를 만든 사람들이 만들어둔 클래스라 너무 좋은 예제당~
		
		// 우리가 만든 static 메소드도 따로 객체생성이 필요없이 그냥 부를 수 있음
		// 따로 static 영역에 올라가기 때문에
		// MethodController.staticMethod();
		
		// 가장 처음 만든 FirstClass에 가보면 자기 이름 출력 기능을 하나 만들었음, 그때 static을 붙였음
		// 왜 static을 붙였을까? 그시점에서는 설명을 못하고 일단 static 붙여서 만들어야했음
		// 메인메소드는 JVM이 호출함. 어떻게? Run.main();
		// 처음에 public void hi() {} 메소드를 클래스 안-메인 바깥에 만들어놓고 메인 메소드 안에서 호출해보면? 안됨, 왜안됨? 될 수가 없음 --> 메인 메소드 블록 바깥, 아래쪽에 옮겨도 안됨
		// 메소드를 호출하기 위한 전제조건은? 어떤 상태여야 하는가? 메소드만 부르면 안됨 --> 메소드가 있는 곳으로 가야함, 메모리에 올라와있어야 그 메모리를 찾아가서 메소드를 부름
		// hi라는 메소드는 누구꺼? Run꺼 --> Run이 가진 hi 메소드를 부르기 위한 전제조건 --> Run이 메모리에 올라간 상태여야함 --> Run이 올라가있어야 Run에 있는 hi를 부를 것 --> 객체생성안하고 객체의 기능 못씀!!(객체지향 여태까지 배운걸 날려버리는 이야기~)
		// 첫날부터 객체 만들어서 계속 썼음 --> 객체를 안만들고 쓰려면 static에 올리는 것 뿐 --> public static void hi() {} 로 선언
		// static main에서 부르는데, heap에 있는 애를 부를수가 없음(Run이 생겨나지도 않은 상태) --> main에서 Run이 생성되지 않고 Run 이 가진 hi 메소드를 부를 수 있는 방법은 hi도 static으로 만드는 방법뿐(객체생성을 안했으니까!)
		// 그래서 첫날 만든 static 메소드도 어쩔수없어서 그렇게 만들었음 --> static 너무 하기 싫으니까 그래서 다음부터 클래스를 나눠서 만들었음
		
		// 여태 배운것으로는 말이 안되는 내용이 하나 있음
		// mc.haha(3.14); // 매개변수를 int로 설정했기 때문에 정수가 아닌것은 전달할수없다
		// 매개변수와 인자값의 자료형을 맞춰야함
		/*
		System.out.println(1);
		System.out.println(1.1);
		System.out.println('a');
		System.out.println("어라?");
		System.out.println(mc);
		System.out.println();
		*/
		// ? 얜 뭐임? 인자값의 자료형이 전부 다르거나 아예 전달하지 않아도 문제가 없음
		// 얘는 여러개 타입의 인자를 전부 받을 수 있는 이유는? method overloading이 구현되어있기 때문, 매개변수로 모든것을 받는 경우를 각각 전부 구현해뒀음
		// 사용자가 메소드를 호출할 때 어떠한 인자를 넣더라도 전부 사용 가능, 모든 것을 받을 수 있도록 구현됨(똑같은 이름으로) --> 우리가 어떤 형태의 인자값을 넣더라도 그것에 맞는 메소드가 호출되어 동작함 --> 사용자 편의성을 높일 수 있는 기술
		// 우리는 관심없었음, 정수넣고 실수넣고,, 한번도 생각하고 쓴 적은 없지만(모르고 썼음) 사실은 오버로딩이 구현되어있었기때문에 편하게 썼다
		
		OverloadingController oc = new OverloadingController();
		
		// 정적 바인딩(Static Binding) <-- 얘는 메모리 얘기 아님! 고정된걸로 짝지어준다는 뜻, 메소드 오버로딩이 정적 바인딩의 가장 대표적인 예(static 메소드랑 private 메소드에도 정적 바인딩이 반영됨)
		// 저장했으니 컴파일이 끝난 시점에 어떤 메소드가 호출될지 결정되어 있는 상태임
		// 컴파일러가 알아서 코드를 분석하여 메소드 호출 연결 --> 쌍이라서 묶는다고 표현함 --> "Binding", 완전히 고정된 코드를 가지고 분석해서 하는 것이므로 static(정적) binding
		// 면접 질문(자바의 메소드 오버로딩이 뭔가요?)에 대한 답변 --> 하나의 클래스 안에 동일한 이름의 여러개의 메소드를 정의할 수 있는 기술로 메소드의 매개변수 자료형 개수, 순서를 다르게하여 구현할 수 있습니다. 실제로 메소드 오버로딩이 코드상으로 실행될때는 정적 바인딩을 통해 호출하는 메소드와 선언되어 있는 메소드를 바인딩(바인드)해서 오버로딩을 구현합니다.
		// 오버로딩과 오버라이딩의 차이에 대해서 설명해주세요 <-- 이걸로 감, 면접관이 원하는 답변은 정적 바인딩과 동적 바인딩이 뭔지 물어보는것
		// 바인드, 바인딩은 호출하는거랑 실행될거를 묶어주는 과정
		oc.test(); // com.kh.chap06.controller.OverloadingController.test() <-- 이게 호출됨
		oc.test(2); // com.kh.chap06.controller.OverloadingController.test(int num) <-- 이게 호출됨
		oc.test("3");
		oc.test(1, 2);
		oc.test(2, "sdf");
		oc.test("vvv", 3);
		
	}
	
}
