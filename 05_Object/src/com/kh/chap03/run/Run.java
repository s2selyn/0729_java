package com.kh.chap03.run;

import java.util.Scanner;

import com.kh.chap03.model.vo.Coffee;

public class Run {

	public static void main(String[] args) {

		// Coffee라는 클래스(설계도)를 가지고 객체 생성
		// 코드로는 객체 생성만 나타낸다면 --> new Coffee(); 객체 생성하는 구문이고 주소값임, 물리적으로 건드릴 수 없음
		// new Coffee(); // <-- 객체(Object) 생성, instance화 했다고 표현하기도 함, 메모리에 올렸다
		// 오브젝트랑 인스턴스는 결론만 놓고 보면 똑같은 말인데 관점이 다름, 관점에 따라 다르게 부르는 사람들이 있다
		// 오브젝트라고 표현하는 사람들은 개념, 이론파, 만들어진 것을 데이터와 해당 데이터를 처리하는 메소드를 묶은것을 의미함
		// 인스턴스라고 표현하는 사람들은 실체, 클래스를 이용해서 만들었다는 점(클래스와의 관계)을 감조하고 싶음, 실제 메모리에 올라간 객체 덩어리를 인스턴스라고 함, 기술파
		// 주소값만 가지고는 일회용 --> 주소값을 두고두고 쓰고싶으므로 주소값을 변수공간에 대입 --> 누군가는 객체를 가리키고 있어야 하므로
		// Coffee 타입의 참조자료형 coffee 변수공간을 선언해서 생성된 Coffee 객체의 주소값을 대입
		Coffee coffee = new Coffee();
		// 1. 참조자료형(reference type)
		// 자바는 기본자료형 8개 빼고는 나머지가 전부 몽땅 참조자료형
		// 클래스를 만든다는 행위(의 뜻) == 사용자 정의 자료형을 (새롭게 하나)만들겠다.
		// 자바는 클래스 기반의 언어이기 때문에 모든 것이 Class, 모든 클래스는 Type으로 활용될 수 있음
		// Coffee 모양의 자료형, 개발자가 생각하는 현실세계의 커피 데이터가 들어갈 수 있는 자료형
		// 현실 세계의 커피는 하나의 값만 가지고 있지는 않음 --> 소프트웨어로 해결하려고 들고왔을 때 하나로만 해결되지 않음(커피명만 가지고는 내가 구현하고자 하는 커피를 전부 표현할수없음) --> 여러개의 데이터를 넣음 --> 내가 생각하는 커피의 모양! 으로 자료형을 만든 것(Coffee Type)
		// 2. 여러 개의 자료형에 여러 개의 값을 보관 + 기능
		// 그동안 썼던 참조자료형들 예시로 들어주심(System, Scanner, String)
		// 필드부, 생성자부, 메소드부로 구성되어 있음
		// String은 중요한 친구라 얘만을 위한 챕터도 있음
		// 모든 클래스들은 자신이 책임질 필드들, 메소드들이 있음(값과 기능이라고 표현)
		// 3. 주소값을 저장
		// 사람마다 모양새가 다르므로 필요한 공간이 다를것임 --> 생성했을 때 heap에 생성되고 변수에는 다 담을 수 없음
		// 따라서 주소값에 접근해서 작업하는 수밖에 없음
		
		// 커피를 생성했으니 커피의 info를 해보자
		System.out.println(coffee.info());
		
		// 그림그리면서 생각해보기
		/*
		 * Coffee coffee = new Coffee();에서
		 * 1. stack 영역에 coffee라는 이름의 공간이 생김
		 * 2. heap 영역에 이름, 콩, 크기, 가격, getter(), setter(), info()를 포함한(필드에 기본값도 들어있는) 덩어리가 생성됨
		 * 3. 주소값을 저장, 2에서 생성된 덩어리의 주소값을 1의 공간에 대입(주소값을 0xbcbe라고 해보자), coffee는 0xbcbe를 가리키고 있음
		 * 
		 * 출력문을 만나면 기본값이 들어있는 상태이므로 상품명 : null, 원두 : null, 사이즈 : null, 가격 : 0 으로 출력됨
		 * 기본값이 들어있음
		 * => 정수 : 0, 실수 : 0.0, 참조형 : null, 문자 : '', boolean : false
		 * 
		 */
		
		// 앞에 캡슐화할때는 게터세터로 직접 리터럴값을 대입해서 사용함
		// 보편적으로 우리가 만들게될 프로그램은 우리가 직접 값을 넣는것보다는 사용자의 입력값이 들어가는 경우가 많음
		// 이번에는 사용자에게 값을 입력받아서 입력받은 값을 필드에 대입해보자
		// 스캐너가 필요함, 스캐너를 사용하기 위해서는 import 한 다음에 스캐너 타입의 변수를 선언
		Scanner sc = new Scanner(System.in); // 스캐너 타입으로 변수를 선언하는 작업, Scanner도 클래스니까 하나의 타입임
		// Scanner 타입의 변수를 선언해야지~ stack 영역에 scanner라는 이름의 변수 공간이 쌓임(coffee공간 위에 얹음)
		// 참조자료형의 크기는 전부 4바이트(주소를 담으므로)로 stack에 생긴다
		// System.in은 괄호안에 들어가니 아마도 값일거고, Scanner의 매개변수에 들어갈 것이다!
		// heap에 Scanner의 공간도 생김(next(), nextInt(), nextLine()이 들어있음), 주호도 생김 0xffff라고 하자 --> stack의 주소값 변수가 heap에 생긴 공간을 가리키고 있음
		
		// 입력도구를 선언했으니까 하나하나 받는거죠
		System.out.print("커피명이 뭔가요 > ");
		// 사용자가 입력한거 받을라믄? --> 코드로 어떻게 써야하나? 어떻게 해야 정수값을 받아와서 쓸 수 있나?
		// nextInt() 메소드 호출해야 함, 그냥 호출은 안됨, 일단 0xffff에 가야함, 0xffff(주소값)은 스캐너타입 변수에 담아뒀으므로 sc로 가서 참조해서 메소드를 부른다
		// sc.nextLine(); // 이상태는 겟뭐시기 호출한거랑 똑같음, 값을 받아와서 필드에 담아야 함, 그러려면? 값을 변수에 저장해두어야함
		String name = sc.nextLine(); // 여기서 선언한 변수는 name이라는 이름을 달아놓고, stack scanner 변수 공간 위에 쌓임
		// name 변수 공간에 받아온 커피명이 담겨있음(사실은 참조자료형이니까 이게 실제로 커피명이 들어있는 것은 아님 --> 얘는 heap으로는 감당이 안됨, 하나 더 늘어나야 함)
		// 커피명을 heap 영역에 있는 커피 객체의 name 필드에 대입하고싶음
		// 일단 커피 객체의 주소를 찾아가야 함 --> 주소를 찾아가는 방법은 coffee를 참조해야 함, coffee가 주소를 들고있음
		coffee.setName(name);// name에 값을 대입하는 책임을 커피 클래스에 넘겼음, 커피 클래스가 자신의 필드에 값을 대입하는 책임을 가지고 있음, 이 값을 세팅할수있는 세터를 만들었으므로 세터를 호출해서 name값을 대입할 수 있음
		// 세터 메소드를 호출했으니 stack의 영역 안에 있는 name이 차지하고 있는 영역 위에 setName 영역이 생기고, 변수선언을 하고 있으므로 메소드가 호출되는 동시에 변수공간이 생성, 변수공간에 커피명을 받아옴(매개변수에 커피명을 갖고있음)
		// 세터 메소드 안을 보니까 this로 가래, 여기에 가서 name으로 가서 매개변수로 받아온 커피명을 대입하라고 되어있음 --> name 필드의 값이 커피명으로 바뀜(세팅됨!)
		// 메소드 블럭이 끝나면 나를 부른 곳으로 돌아감 --> 역할을 다했으니 stack에 있던 메소드의 메모리 영역이 사라짐
		// 여기까지 하면 객체의 name 필드에 사용자가 입력한 커피명이 들어가있는 상태가 됨
		
		// setter 했으니 getter 해보자
		// name을 get 할 것이므로 일단은 heap 영역에 생긴 커피 객체의 name 필드까지 가야 get 해올수있음
		// 주소를 보고 찾아갈것임, 주소는 coffee 변수에 대입해뒀음 coffee와 참조연산자., getName을 부름
		// coffee.getName(); // 호출하면 메모리 영역(stack)에 올라감, 커피명을 반환하래, 커피명을 들고 호출했던 곳으로 돌아감, 할일이 끝나면 getter의 영역은 메모리영역에서 사라짐
		// 이렇게 부르기만 하면 의미가 없음
		// 나는 필드값인 커피명을 사용하고싶음, stack에서 계속 쓰고싶은것이므로 공간을 하나 더 만들어서 받아줌
		// String coffeeName = coffee.getName(); // 순서생각 1좌항 2우항 3대입
		// getter가 메모리에 올라가기 이전에 coffeeName 변수가 먼저 선언됨, 그 위에 메소드가 올라갈것임, 메소드가 사라지기 전에 대입이 일어날것임
		// 그러고나면 메소드가 끝나고 날아가도 coffeeName에 담아뒀으니 계속 쓸 수 있음
		
		System.out.print("원두는 어떤 원두인가요 > ");
		String bean = sc.nextLine();
		coffee.setBean(bean); // coffee 객체에 setBean 불러서 bean 넣어줌
		System.out.print("사이즈는 어떤 사이즈인가요 > ");
		String size = sc.nextLine(); // 사이즈 입력받아서
		coffee.setSize(size); // 세터 호출해서 사이즈 넣어주기
		System.out.print("가격은 얼마인가요 > ");
		int price = sc.nextInt();
		coffee.setPrice(price); // price 넣어주기
		
		String info = coffee.info(); // 필드값을 전부 대입했다면 info() 메소드 호출 결과를 출력문을 이용해서 출력해보기
		System.out.println("==========");
		System.out.println(info);
		// 숙제 미리 해보기!
		
	}

}
