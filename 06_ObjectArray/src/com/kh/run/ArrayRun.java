package com.kh.run;

import java.util.Scanner;

import com.kh.model.vo.Restaurant;

public class ArrayRun {

	public static void main(String[] args) {
		
		// 배열의 특징 ==> 자료구조에 대해서 물어보는거니까
		//
		// 논리적인 구조와 물리적인 구조가 동일하다. <-- 이것부터 나와야함
		// 같은 자료형끼리만 담을 수 있다 => 동종 모음(homogeneous vowels)
		// 하나의 배열에 여러 값을 담을 수 있음
		// 메모리상에 공간
		// 참조자료형
		// 인덱스개념이 존재함
		// 명확한 크기를 명시해야함 => 크기를 바꾸는 것은 불가능함
		
		// 논리적인 구조(인덱스 개념을 0, 1, 2 이렇게함)와 물리적인 구조(메모리상에도 물리적으로 다닥다닥 붙어있음)의 의미(순서대로, 순차적으로 나열되어 있는 구조)
		// 배열은 변수의 나열이다 라고 표현하는 책도 있음
		
		// 앞에서 방금전에 했던 문제를 해결하기 위해서 배열을 써보자
		// 배열은 어떻게 썼더라? 정수형 배열을 선언하려면?
		// int[] nums = {1, 2, 3, 4}; <-- 일반적인 배열의 사용방법
		int[] nums = new int[3]; // 처음에는 이렇게 배웠음
		// 배열을 배울때는 객체를 얘기못했음, 처음에는 몰라서 그냥 이렇게 쓰는거에요~ 하고 넘어갔음 --> 이제 이 구문의 명확한 의미를 파악할 수 있다!
		// int형 배열 nums 하면 --> nums 변수의 공간이 스택에 올라감
		// new int[3]을 하면? new 만나는 순간 heap에 무지성으로 가서 객체를 올림(자바에서 배열은 객체로 구분(판단)됨), 얘는 생성자 호출이 아님 --> 크기가 정해져있음 int 하나에 4바이트이므로 총 12바이트 공간이 생겨남
		// 대입연산자는 heap메모리에 생긴 공간의 주소값을 nums 공간에 대입
		// 배열 --> 객체 --> 배열로 진행중
		// 배열시간의 주인공은 기본자료형에 대한 배열들, 기본자료형은 공간에 값, 실제 value값이 들어감(정수형이라면 0, 1, 2 등)
		
		// 오늘은 기본자료형 배열이 아니고 객체배열 --> 이미 우리는 많이 사용해왔음
		// String[] strs = new String[5]; // 얘가 객체배열
		// String은 참조자료형
		
		// 자바에서 기본자료형을 제외한 나머지는 싸그리몽땅다
		// 전부 참조자료형
		// 참조자료형 공간에 대입될 수 있는 값은 오로지 주.소.값
		// 오늘 주인공 주소값!
		
		// 객체배열의 선언 및 할당!(방법)
		// [ 표현법 ]
		// 참조자료형[] 배열식별자 = new 참조자료형[배열크기];
		// 다 똑같은데 클래스이름 자리에 참조자료형이 들어감
		
		// 전시간에 했던 실행클래스를 생각해보자. 레스토랑 객체 세개를 다루고싶음, 세개의 변수를 만들어서 사용했음
		// 레스토랑 객체 세개라는것은 얘네의 자료형이 모두 동일한 레스토랑형 객체라는 뜻 --> 자료형이 같으니까 하나의 배열에 담을 수 있따!
		// 레스토랑형 배열 선언
		Restaurant[] restaurants = new Restaurant[3];
		// 객체배열선언이므로 대괄호 안에 배열의 크기를 넣어줌, 세칸짜리 필요하므로 3
		// 아까전에 변수명부터 별로였는데 지금은 이것만봐도 레스토랑들!을 알수있음
		
		// 아까랑 똑같은 작업 해보자
		// 세개의 레스토랑 정보를 입력받고 그것을 출력하려고 함
		Scanner sc = new Scanner(System.in);
		
		// 이렇게 하면 온전한 반복문 하나를 알차게 쓸 수 있음
		for(int i = 0; i < restaurants.length; i++) {
			
			System.out.print("상호명을 입력하세요 > ");
			String storeName = sc.nextLine();
			
			System.out.print("주소지를 입력하세요 > ");
			String address = sc.nextLine();
			
			System.out.print("대표메뉴를 입력하세요 > ");
			String mainMenu = sc.nextLine();
			
			// 이제 식당에 대한 정보를 변수가 아니라 배열에 넣고 보관하기로 했으므로...?
			// 일단 때려놓고 설명하기로했찌!
			restaurants[i] = new Restaurant(storeName, address, mainMenu); // 배열의 요소에 대입함
			// 여기까지 해놓고 코드 잘 동작하는지 확인
			
		}
		
		// 들어갔는지 출력해서 확인해봐야함, 첫번째 가게 확인한다고 가정해보자
		// 출력해야지 하면? 출력문 --> 인자로? restaurants[0]?
		// System.out.println(restaurants[0]); // 엥? com.kh.model.vo.Restaurant@1324409e 나옴
		/*
		 * 그림그리기!
		 * 
		 * Restaurant[] restaurants = new Restaurant[3];부터시작
		 * 1. 좌항에서 일어나는 일 --> stack 영역에 restaurants 라는 이름을 가진 공간을 할당받음 --> 1번 끝
		 * 2. 우항에서 일어나는 일(객체생성) --> new 하니까 heap 영역에 공간이 12바이트만큼 생김(주소가 3개 들어가야함) --> 세개니까 인덱스가 세개(0, 1, 2) --> 2번 끝
		 * 3. heap에 생긴 배열의 주소값을 stack에 생겼던 restaurants 변수에 대입
		 * 
		 * Scanner sc = new Scanner(System.in);를 만남
		 * 1. 좌항에서 일어나는 일 --> 식별자 sc라는 이름으로 stack에 공간 생김(restaurnats공간 위에 쌓임) --> 1번 끝
		 * 2. 우항에서 일어나는 일 --> new를 만나서 heap 영역에 공간이 생김 --> Scanner(System.in);은 스캐너 클래스의 생성자호출해서 스캐너모양의 객체를 만들어준것 --> 안에 메소드들 들어감(nextLine, nextInt등) --> 2번 끝
		 * 3. heap에 생긴 스캐너 객체의 주소값을 변수 sc에 대입
		 * 
		 * for(int i = 0; i < restaurants.length; i++) 를 만남
		 * for를 만났으니 stack에 for 블럭이 생성되어 올라감 --> 소괄호 안으로 들어가면 초기식을 만남 --> 초기식의 변수 선언 --> for블럭 안에 i라는 식별자로 4바이트짜리 공간이 생김
		 * i라는 공간에 0을 대입
		 * 조건식으로 감 --> 0이 restaurnats의 길이보다 작니? --> 참, if 블럭(스코프 안으로 들어감) --> 상호명 입력요구문 출력
		 * 
		 * String storeName = sc.nextLine();에서 변수 선언, for문 블럭 안의 i 변수공간 위에 sN 공간 생김 --> sc.nextLine()으로 sc(스캐너의 주소값)을 참조해서 메소드 호출 --> String 타입의 value값이 돌아옴(반환)
		 * String도 하나의 객체이므로 사용자가 입력한 String 타입의 value값이 heap 영역에 올라감, 식당1이라고 입력했다고 가정하면, 얘도 주소값이 생길것임 --> 주소값을 sN 변수의 공간에 대입함
		 * 
		 * 그 다음도 마찬가지임, address 공간을 stack에 할당(sN위에얹음) --> heap에 주소1의 공간이 생기고 주소1의 주소값이 전달되어 address로 대입됨
		 * 메뉴도 마찬가지~ mM 공간이 address 공간 위에 생겨남 --> heap에 String 친구 생겨남, 메뉴1 밸류가 대입되어있음, m1의 주소값이 mM에 대입됨
		 * 사용자가 입력한 값들은 객체의 형태로 힙어딘가에 대입되어 존재하고? 주소값이 변수에 대입되어있음
		 * 
		 * restaurants[i] = new Restaurant(storeName, address, mainMenu);을 만남
		 * 1. 왼쪽부터 --> restaurants와 [i]를 나눠봐야함 --> restaurants는 위에서 선언했던 배열의 주소값을 의미함 --> [i]는 지금 0이 들어있으므로 주소의 0번째에 가라는 뜻
		 * 2. 오른쪽 --> new --> heap에 객체를 생성함, 생성되자마자 필드가 초기화되어야하므로 필드에 값이 들어가있음, 필드이름이 붙어있겠지
		 * --> 생성자 호출하면서 value값 세개를 전달함 --> 얘네를 객체의 필드에 대입한다는 뜻
		 * 3. restaurants 객체의 주소값을 배열의 0번 인덱스에 대입함
		 * 
		 * for문의 조건식 끝났음 --> 증감식으로 감 --> 증감식으로 가면서 i위에 쌓였던것들은 없어지고 i에는 1이 대입됨
		 * 
		 * 실제로 우리가 필요한 것은? 메뉴, 주소, 식당이름 --> for문 블록이 끝나면 stack에 있는것들이 날아가버림 --> 그래도 이 변수들이 살아있을 수 있는 이유는?(사라지지 않기 위한 전제조건 : 누군가 가리키고 있어야함) --> 레스토랑 객체의 필드들이 가리키고 있음
		 * --> 레스토랑 객체도 객체임, 지역변수임, 사라지지 않으려면 누군가 가리켜야함 --> 배열의 0번 인덱스가 기리키고 있음 --> 배열도 자바에서는 객체, 얘도 사라지지 않으려면 누군가 가리키고 있어야함 --> for문 바깥의 메인메소드블록에서의 변수(restaurants, 메인메소드의 지역변수)가 가리키고 있음
		 * --> 얘는 메인메소드의 스코프가 끝날때까지는 살아있음 --> 메인메소드가 끝나면? 일어나는 일은 프로그램 종료 --> 프로그램 종료면 살아있을 필요없음, 날아가도 상관없음
		 * 
		 * 이런식으로 반복문이 반복하면서 식당 객체들이 3개 생길것임 --> 각 객체는 각각의 필드를 가지고 있을 것 --> 필드는 또 String의 주소값을 가지고 있을것이고 --> 식당 객체의 주소값은 객체배열의 인덱스에 들어가있음
		 * 
		 * for문이 다 끝난 시점에서 System.out.println(restaurants[0]);를 만남
		 * 
		 * 우리가 하고싶은일은?
		 * 
		 * restaurants[0]은? restaurants 객체의 주소값밖에 없음, 우리가 보고싶었던것은 주소값이아님
		 * 
		 */
		// 주소값을 확인하고 싶었던 것은 아님
		
		// 0번 인덱스에 들어있는 첫번째 식당 객체의 메뉴명을 출력하고싶다고 가정하자
		// 일단 restaurants에 가야 할 것 같다, 이러면 식당 객체의 주소값을 담은 stack의 변수로감
		// System.out.println(restaurants);
		// 배열의 주소값이 출력됨
		
		// System.out.println(restaurants[0]);
		// 배열에 가서 배열의 0번인덱스까지 간것, 이것도 식당 객체(r0 객체)의 주소값이 출력됨
		
		// System.out.println(restaurants[0].getMainMenu());
		// 이제 0번 인덱스를 가지고 첫번째 객체의 주소값까지 알아냄, 이것을 참조해야함, 참조하려면 참조연산자 사용, 거기가서 하고싶은건? 메인메뉴의 필드값을 가져가고싶은것이므로 getter메소드
		
		/*
		// 첫번째 식당의 정보를 출력하고 싶다, 모든 필드를 출력하고싶다(모든 필드값을 보고싶다) --> 출력해야하므로 출력문 --> 어디까지 가야함? restaurants라는 배열의 0번 인덱스에 있는 주소를 참조해서 이 객체가 가지고 있는 정보를 문자열로 반환해주는 메소드를 호출
		System.out.println(restaurants[0].information());
		
		// 나머지 식당의 정보를 출력하고싶다면 인덱스만 바꿔주면됨
		System.out.println(restaurants[1].information());
		System.out.println(restaurants[2].information());
		*/
		
		// 사실 전의 클래스와는 똑같지만 값을 다루는 방법을 바꿈
		// 배열에 담아놓고 배열의 인덱스를 활용해서 어쩌구저쩌구 하고있으므로 출력문을 변수를 활용해서 중복제거 할 수 있음
		
		for(int i = 0; i < restaurants.length; i++) {
			System.out.println(restaurants[i].information());
		}
		
		// 배열써서 코드를 이렇게 바꿨더니 뭐가 좋은가요? 중복도 제거되고 확장성이 좋아짐
		// 반복도 배열 길이만큼돌고 인덱스로 제어함 --> 나중에 식당의 개수를 줄이거나 늘리고 싶으면 크기 선언부분(Restaurant[] restaurants = new Restaurant[3];)만 바꾸면됨 --> 아까는 식당의 개수가 변할때마다 수정할 부분이 매우많음
		// 변수명을 명확한 이름을 통해 한눈에 봐도 알아보기 쉽게 만들 수 있음
		// 써야하는 코드는 그대로임, 문법적으로 이걸 짧게 줄여서 작성할수는 있는데, 그게중요한게 아니고~ 조금더 유지보수를 용이하게 하다보니 중복을 제거할수밖에 없게되고, 중복을 제거했더니 코드가 좋아지는것
		// 짧게 쓴다고 좋은게 아니라 좋게좋게 바꾸다보면 짧아진다
		// 처음부터 짧게 써야지 하고 접근하면 안됨
		// 돌아가는거 확인한다음에 수정
		// 처음 작성할때는 있는그대로 쭉 쓰고나서 보완하고 개선해서 점점나아지도록 하는것이 중요
		
		// 이렇게 바꿈으로써 아까 했던 2절도 바꿀 수 있음! 아까는 2절에서 중복 제거하기가 가장 힘든 부분이? 각각의 value값을 변수로 따로 나눠서 관리하는 부분
		// --> 이제 주소값들이 들어있는 것을 변수로 관리하지 않고 배열의 인덱스로 관리하고있음 --> 하나에 몰아넣었음 --> 현시점에 우리가 배열을 사용해서 얻을 수 있는 가장 큰 장점 --> 반복문을 사용할 수 있음
		
		// 아까는 if문 세개써서 했음, 지금은 배열로 관리하고 있기 때문에
		// 이제는 똑같이 입력받은 내용을 가지고 검색하더라도 앞에서부터 차근차근 storeName을 받아서 존재하는 친구만 띄워줄 수 있음
		System.out.println("상호명을 입력해주세요 > ");
		String searched = sc.nextLine();
		
		for(int i = 0; i < restaurants.length; i++) {
			
			if(searched.equals(restaurants[i].getStoreName())) {
				System.out.println("대표 메뉴 : " + restaurants[i].getMainMenu());
			}
			
		}
		
	}
	
}
