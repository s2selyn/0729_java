package com.kh.chap01_file.run;

import java.io.File;
import java.io.IOException;

public class FileRun {

	public static void main(String[] args) {
		
		// 자바로 파일 만들기!
		// 정말 간단하게 소스코드를 이용해서 파일을 만들어보자
		
		// I/O --> 입력 및 출력
		// 메모장 파일이 있는데, 여기에 가나다라마바사라고 적었다고 생각해보자. 적힌걸 프로그램에서 읽어와서 콘솔창에 출력했다면 입력일까 출력일까? --> 이거 입력임!
		// 스캐너를 써서 가나다라마바사라고 적어서 메모장에 가나다라마바사가 나오게했다 --> 이건 출력!
		// 입출력은 기준점이 있어야함, 기준점을 생각해야함, 기준점은 항상 우리가 작업하고 있는 프로그램이 기준!
		// 외부에 있는 데이터값을 프로그램내부로 가져오면? 입력, 무조건! 밖에 있는게 내 프로그램 안으로 들어온다? 그럼 이걸 가지고 내가 파일을 뽑아내고 뭘 하건 무조건 입력!
		// 안에 있는 데이터를 바깥에 내보낸다? 프로그램 바깥으로 나가는거니까 무조건 출력!
		// 내가 작업하고 있는 소스코드, 프로그램을 기준으로 밖에있는것을 안으로 가지고 왔느냐, 안에 있던것을 밖으로 뺐느냐 이게 입출력을 나누는 기준
		// 지금은 파일을 만들건데, 요기에서 바깥에다가 데이터를 내보내는거란말이야~ 그럼 출력하는것!
		
		// 자바는 클래스 기반 언어라서 파일을 뭐시기 할때도 Flie이라는 이름의 클래스로
		// File 클래스를 가지고 작업
		// java.io 패키지에 존재
		
		// 파일클래스를 이용해서 객체 생성
		File file1 = new File("text.txt"); // import 해야함! 그래도 빨간줄이 생긴것은? 기본생성자가 없음, The constructor File() is undefined
		// 파일을 실제로 만들때를 생각해야함, 파일을 만들때는 뭐가 꼭 있어야함? 파일명! 없으면 못만든다. 운영체제상에서 파일 만들때를 생각해보면됨. 이름이 없이는 안만들어짐. 이름이 없는 파일이라는것은 존재할 수 없음
		// 파일 만들 때 최소한 파일명은 있어야함!
		
		try {
			
			// 실제로 "text.txt" 이름을 가진 파일을 만들어보자
			// 파일 만들기
			// 파일 객체를 참조해서 메소드 호출
			file1.createNewFile(); // 이름만 봐도 뭐할지 알것같다. 우리도 메소드 이름 이렇게 지어야함
			// createNewFile() : 파일 생성 메소드
			// 빨간줄생김! --> Unhandled exception type IOException
			// 프로그램 밖으로 가는거잖아? 근데 왜 예외처리 안해놓음? Output하는거니까 output 할때 예외가 발생할 수 있는데!
			// 이거 그럼 무슨 예외지? 이거 꼭해라! 하고 있는거 보니까 CheckedException, 이거를 예외처리 해주기 전까지는 절대로 이 코드를 돌릴수없음, 꼭 하라고 빨간줄로 알려줌
			// CE니까 예외처리 해야함! 예외처리 어떻게함? --> try-catch! 구문 써! --> 이거 하는법은? try 해서 예외가 발생할수도 있는 친구를 try블록 안에다가 넣어줌
			// 그다음에는 catch하고 소괄호 안에는 try블록 안에서 일어날수도 있는 예외를! --> 핸들링 하니까 빨간줄 없어짐!
			
			// 폴더 만들기
			// 메소드 호출해서 만드는건데 애매하긴해... 우리는 folder라고 하는데, folder는 빌게이츠씨가 만든거
			// 보통은 살면서 제일 처음 접하는 운영체제는 아마 윈도우, 익숙하다. 처음나왔을때만해도 와 혁신! 난리난리~
			// 도스, 리눅스, 유닉스, 맥 등등 사용 --> 유닉스에서 맥도 만들어지고, 그이후에 리눅스, 그 이후에 윈도우가 나옴
			// 처음부터 아무것도 없는 노베이스에서 만들긴 어렵지. 기존에 컴퓨터에서 사용되던 개념을 이름을 조금씩 바꾼것
			// 예전 윈도우에서 아이디 비밀번호 입력하는건 로그인이라고 하기싫으니 로그온으로 바꾸고, 리눅스에서는 디렉토리라고 했는데 하기싫으니 폴더로 바꾸고, 파일시스템도 드라이버가 싫어서 드라이브로 바꾸고..
			// 정식 명칭은 폴더가 아니라 디렉토리, 운영체제에 뭔가 파일을 관리하기 위한 논리적 개념은 디렉토리!
			// directory
			// 고쳐서 쓰는게 나쁜건 아님, B언어 다음 C언어(B진화시켜야지 해서 나옴), Java도 C언어 베꼈고(참고해서 만들었음), C++도 나왔고(C에서 진화해야지, C에 후위연산해서 1증가 ㅎ)
			// C++도 자바에서 많은 부분을 차용해서 지금은 C언어랑은 달라짐, 진화한것을 한번더 진화해서 C#도 나옴(후위연산 두번ㅋㅋ) --> C#을 참고해서 또 JavaScript가 나옴. C 패밀리언어들이 됨(C, C++, C#, Java, JavaScript)
			// B C가 있으니까 D언어도 있대(얘는 인기없음), B는 시대의 흐름에 사라짐, 자바스크립트는 요새 외국(영어권)에서 핫하고. 한국은 Java로 먹고살아야함. C는 절대 굶어죽을일없고. 게임은 C랑 C#쓰고, C++은 별로 인기없고
			// makeDirectory를 줄여서 mkDir()
			File folder = new File("folder");
			folder.mkdir(); // 이거 실행하고 새로고침하면 프로젝트 익스플로러에서 볼 수 있음
			
			// 만들때부터 이렇게 만들수도 있음
			// 경로지정까지
			File file2 = new File("folder/test.txt");
			file2.createNewFile(); // 실행후 새로고침 ㄱㄱ 폴더밑에 파일생김
			
			// 파일클래스에서 제공하는 메소드
			System.out.println("파일맞니 ? " + file2.isFile()); // getter임, boolean타입 필드 가져오는것, 파일 객체의 필드 가져오는것이므로 getter 쓰는 것
			
			// 파일명은 얻고싶다. 파일명은 파일객체의 필드로 들어감, 필드값을 얻으려면? get! getter중에 뭐가 가지고 있을까? 눈치코치로! getName()!
			System.out.println("파일명 : " + file2.getName());
			System.out.println("상위 폴더 : " + file2.getParent());
			System.out.println("절대 경로 : " + file2.getAbsolutePath());
			// 파일은 데이터가 없으면 크기가 없음, 데이터를 안넣으면 크기가 0임, 없는거나 다름없음, 사실 파일이라고 하기도 애매함
			System.out.println("파일 크기 : " + file2.length());
			// 이런 것들이 있으니 알아만두기~
			
		} catch(IOException e) {
			e.printStackTrace();
		} // 이러고 실행하고 나면 실제 워크스페이스 가면 생성되어 있음! 프로젝트 익스플로러에도 보임!
		
		/*
		 * 그냥 파일한번 만들어본거고 사실 주인공은 파일이 아님, 정확히 파일에다 뭐 하긴 할건데 이 프로젝트의 주인공은 파일이라기보다는 저 파일에 IO하는거
		 * => IO(Input & Output), 입/출력
		 * 
		 * 프로그램 상의 데이터를 외부매체(모니터, 스피커, DB, 프로세스, 콘솔, "파일")로 출력하거나
		 * 입력장치(마우스, 키보드, 마이크, "파일")로 입력받는 과정
		 * 
		 * 엄청 많은데 오늘 주인공은 파일
		 * 
		 * 자바에서 IO를 진행하고 싶으면
		 * 우선적으로 반드시 프로그램과 외부매체간의 "통로(연결다리)"를 만들어줘야함
		 * => 스트림(Stream)
		 * 이 통로를 스트림이라고 함
		 * 스트림이 이번 프로젝트의 주인공이지!
		 * 
		 * 스트림의 특징
		 * 
		 * - (기본적으로) 단방향 : 입력이면 입력 / 출력이면 출력
		 * 						입력용과 출력용 스트림이 각각 따로 존재함
		 * 프로그램이 있고 외부파일로 내보낼거면 출력용 스트림을 만들어야함, 얘는 출력밖에 못함
		 * 외부파일에서 내걸로 입력을 받고싶으면 입력용 스트림을 만들어야함, 얘는 입력밖에 못받음
		 * 일방통행도로~
		 * 
		 *  - 선입선출(First In First Out) ==> 시간지연 문제가 발생할 수 있음
		 * 문제가 있는데 스트림이 있으면 1차선임.. 1차선 특! 앞에서 막혀있으면 못감, 하염없이 기다려야함
		 * 먼저 앞이 나가야 뒤가 나갈 수 있음
		 * 
		 * 스트림을 구분해줘야함, 가장 큰 구분법? 사이즈!
		 * 
		 * 스트림의 구분
		 * 
		 * - 스트림의 사이즈
		 * 
		 * 바이트스트림 : 1Byte짜리가 이동할 수 있는 통로(한글은 2Byte, 1Byte에 들어가면 아작남, 일본어 중국어도..)
		 * 				=> 입력(XXXInputStream) / 출력(XXXOutputStream)
		 * 클래스명이 저렇게 생김
		 * 
		 * 문자스트림 : 2Byte짜리가 이동할 수 있는 통로(한글, 일본어, 한자 이런거 쓰려면 이거 써야함)
		 * 				=> 입력(XXXReader) / 출력(XXXWriter)
		 * 
		 * 클래스명만 봐도 바이트인지 문자인지 구분할 수 있다
		 * 
		 * - 외부매체와의 직접적인 연결 여부
		 * 
		 * 기반 스트림 : 외부매체(내가 입출력하는 매체)와 직접적으로 연결되는 스트림
		 * 
		 * 보조 스트림 : 기반스트림만으로 부족한 성능을 향상시켜주는 용도로 만들어진 스트림(기반 스트림이 아닌 친구들)
		 * 				=> 종류가 엄청 많은데 기본적으로 단독 사용 불가(반드시 기반스트림이 존재해야만 사용이 가능함)
		 * 				=> 속도 향상, 자료형에 맞춰서 변환, 객체단위로 입출력, 바이트 <==> 문자, 등
		 * 
		 * 보조스트림 엄청 많은거 다 알아야하는건 아니고 스트림은 개념만 알면 됨
		 * 
		 */
		
	}

}
