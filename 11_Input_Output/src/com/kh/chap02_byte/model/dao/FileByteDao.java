package com.kh.chap02_byte.model.dao;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

import com.kh.chap02_byte.model.Abc;

	// DAO(Data Access Object)
	// 데이터를 액세스할때 쓰는 객체
	// 데이터가 보관되어있는 공간에 직접 접근해서
	// (외부 매체와) 입력/출력하는 메소드들을 만들어줌
	// 이 클래스는 외부 매체와 입출력하는 메소드를 이 DAO 클래스 안에 넣는것, DAO 클래스는 dao 패키지 안에 넣는다
	// 오늘은 우리의 외부매체가 File인것!
public class FileByteDao {
	
	// 반납 약속 얘기하고 이제와서 하는 얘기가 있음
	// Scanner sc = new Scanner(System.in);
	// sc.close();
	// 스캐너는 입력받을때 씀, 프로그램 밖에 외부에서 만들어진 값을 프로그램 내부로 입력받을때 사용, 얘도 스트림이 연결되는것
	// 얘도 사용이 다 끝나면 원래 반납해줘야함! 약속! 다썼어? 반납!
	// 자바는 기본적으로 다 Closeable을 가져오고 있어서 close가 다 있음, Stream은 다 Closeable을 구현함 근데 throws IOException이 되어있음! --> 잘 기억하기!
	// 어쨌든 스캐너 반납도 항상 했어야했는데 모르면 못함, 근데 이제 알았죠? 해야함
	// 스캐너도 다썼으면 반납해야함!
	
	// 프로그램에서 파일에 데이터를 출력(Byte Stream사용) 해보자
	public void outputToFile() {
		
		// 파일에다가 데이터를 기록할던데 프로그램에서 밖으로 나가는거니까 출력임!
		// 출력 : 프로그램 내의 데이터를 밖으로 내보내겠다.
		// 내 프로그램에서 외부로 나가야지 출력되는것, 파일에 뭐가 생겼다고 거기 입력이 되는게 아님, 여기서 밖으로 나가면 출력!
		// 프로그램 --> 외부(파일)
		
		// 기본적으로 내꺼에서 밖으로 나가는 바이트스트림은 전부다 클래스명이 OutPutStream으로 끝남, 파일로 내보내고싶은것이므로 앞에 File을 붙임
		// FileOutPutStream --> 이번에 우리는 이것을 이용해서 밖으로 나가는 것!
		// FileOutputStream : "파일"로 데이터를 출력할 때, 파일과 연결하는 1Byte단위의 스트림
		
		// 1. FileOutputStream 객체 생성
		// 파일과 연결하는 스트림을 생성하는 과정(이 객체 생성 과정 자체가!)
		FileOutputStream fos = null; // 선언을 메소드 블록에서 해야함, 이렇게 선언하고 try 안에서 대입
		try {
			
			fos = new FileOutputStream("a_byte.txt"/*, true*/); // 빨간줄 뭐임~ The constructor FileOutputStream() is undefined --> 기본생성자는 선언되지않음
			// 항상 보는 빨간줄이 나옴. 그러면 원인이 똑같겠지, 얘는 기본생성자가 없는것, 파일과 내프로그램이랑 연결하는 통로를 만드는것. 통로를 만드는데 무슨 파일이랑 연결할건데? 가 당연히 있어야함
			// 생성자 인자로 어떤 파일과 연결할건지 전달해줘야함!
			// 그래도 빨간줄! 예외 핸들링 해달래. Unhandled exception type FileNotFoundException --> 파일이랑 통로를 연결해야하는데, 예외가 생길 수 있음
			// 생성자 호출 시 인자값으로 파일명을 전달하는데 파일명이 존재하지 않을 경우
			// 해당 파일을 생성하면서 통로를 연결
			// 연결하는 시점에 파일이 지워져있을 수도 있음(원래 있었는데) --> 그럼 예외발생할수있으니 예외처리해줘야함 --> checkedexeption이므로 try-catch 작성
			// 예외가 발생할수도 있는 구문을 try 블록 안에 넣음
			// 파일 없어도 "a_byte.txt" 이름으로 파일을 만들어버림, 만들면서 호출함, 파일 만들면서 연결해버림!
			
			
			// 이제 출력해보자. fos가 파일에 연결된 통로임!
			// 2. 연결통로를 가지고 데이터를 출력 : write() 호출 --> 얘도 오버라이딩이 잘되어있음, byte형 배열도 갈 수 있고, int로도 갈 수 있고(오프셋이랑 length 정해서 배열 특정 부분만 갈수도 있지만 저렇게는 잘 안함)
			fos.write(97); // 이러고 가려고 했는데 또 빨간줄생김 --> 통로를 만들고 출력하려는 시점에 파일의 이름이 바뀌거나 지워질 수 있음, IOE가 발생할 수 있음, Unhandled exception type IOException
			// 그러면 어떻게해줘? CE니까 이에대한 예외처리를 추가적으로 진행해야함 --> catch(IOException e) 추가작성 --> 그리고 실행하면 무소식! 파일 열어보면 a가 생겨있음!
			fos.write(98);
			fos.write(99);
			
			// 오버로딩 된것도 써보자!
			byte[] arr = {101, 102, 103}; // 누가 출력할 때 이렇게함,, 말이 안되긴함ㅋ
			fos.write(arr);
			// 이 파일이랑 연결해서 출력하고 있는것! 이 데이터를 바깥으로 뺐으니까 출력임! 프로그램안의 데이터를 밖으로 뺐으니까~
			
			// 실행할때마다 이만큼의 데이터가 출력되는건데 이건 덮어쓰기임, 기존에 존재하는것에 뒤에 이어서 덧붙여서 출력하고싶다면?
			// stream 연결할때 인자값을 파일명만 보내는게 아니고, 쉼표찍고 true라고 써보자 --> 덮어쓰기가 아니고 실행할때마다 이어쓰기로 추가됨 --> 해보고 주석처리함
			// 매개변수 생성자 호출 시
			// 두 번째 인자로 true값을 전달한다면 => 해당 파일 내용에 이어서 작성
			// 안쓰면 => 덮어쓰기
			
			// 정수로 뽑긴 했는데 정수가 아니어도 됨, 갈때 int로 type캐스팅해서 가는거니까. char로 써도 char랑 int는 상호변환이 가능하니까!
			fos.write('A');
			fos.write('B');
			
			// 내 이름 석자 남기기 기념비적인 일을 해봐야지
			fos.write('이');
			fos.write('승');
			fos.write('철');
			// --> 이러면 와장창! 남길 수가 없다. 지금은 1Byte짜리만 넘어가잖앙~
			// 1Byte의 범위 : -128 ~ 127
			// 자바는 unsigned 자료형도 없음
			// 한글은 2Byte기 때문에 깨짐
			// 바이트스트림으로는 한글 / 일어 / 한자(한문) 해결이 안됨
			// 문자스트림을 사용해야 해결이 가능(chap03가서하자!)
			
			// 3. 스트림 사용이 끝났다면 반드시 꼭 무조건 절대로 너무너무 해야하는 작업이 있음(약속!)
			// 코드상에서 사용이 전부 종료되었다면 자원반납을 해주어야함 <-- 약속★★
			// 너무 정말정말정말정말정말정말중요중요중요중요중요정말중요한 약속
			// 코드상으로 얘가 끝나면 heap에 올라가는거니까 객체가 사라져야함
			// 근데 Stream은 GC가 안가져감! 수거하지 않음! 외부로 빠지는거라서! GC가 아 이거 외부랑 되있는건데? 하고 수거를 안해감 --> 메모리상에 계속 남아있음, 컴퓨터 껐다켜야 없어짐
			// 반납 꼭 해줘야함! 반납 안해주면 메모리에 쌓여서 터짐!
			
			// 자원반납 하는 방법(자바상에서 95%가 같은 방법을 쓰면 됨)
			// .close() 메소드를 호출
			// fos.close(); // 나 이거 반납할래, 하면 끝!
			// 이 약속 꼭 지켜야함 안그러면 얘는 안데려감, 컬렉터가 수집을 안함~ 꼭 스스로 반납해야함
			// 문제가 있다! 지금 close()로 여기서 자원 반납하는건데, "a_byte.txt"에서 파일이 만들어지고, 2. 연결통로를 가지고 데이터를 출력 여기서도 예외가 발생할 수 있음! 내보내다가 여기서 파일이 갑자기 지워지면 어떡해, 예외가 발생한단말이야
			// 만약에 fos.write('B'); 여기서 예외가 발생하면 어디로 가나요? 쩜프함! IO를 catch하는 곳으로, 그러면? 약속을 지킬 수 없음!(자원반납불가) --> 여기 있으면 안됨! 약속은 무조건 지켜야 하고 여기서는 약속을 못지킬수있음. 어디로 가야해?
			// catch 밖에 있어야함! catch 아래로 ㄱㄱ
			
			// 여기서 작업 처리하는거 다 하고 return; 하면 또 close 못하게됨... 'fos' is not closed at this location
			// 하다보면 이런 코드가 생김, return이 여기저기 생길 수 있음
			return;
			
		} catch(FileNotFoundException e) {
			e.printStackTrace();
			
			// 예외가 일어났을 때 리턴하는 경우가 있음, 여기서 리턴이 되면 아래에서 클로즈를 할 수 없게됨
		} catch(IOException e) { // 모르면 못하는건데 배웠음! 얘를 예외처리 이후에 하는 이유가 있겠지, 커리큘럼 순서가...예외처리를 배웠으니까 여기서 해주자!
			
			e.printStackTrace();
			
			// catch문을 지금을 예외 일어나는것만 띄우게 했는데, catch 안에다 예외처리 로직을 예쁘게 쓰는 경우가 있음, 마무리가 어떻게 되냐면 메소드니까 return 하는 경우가 있음
			// 리턴까진 좋은데, 여기서 만약에 리턴하면? fos.close() 약속을 지킬 수 없어짐! 여기가 이나더라도 try 블록 안에서 return하는 경우도 있음
			return;
			// 어디에서 리턴하든지 fos.close()는 최우선사항인데!
			
			/*
			try {
				if(fos != null) {
					fos.close();
				}
			} catch(IOException e) {
				e.printStackTrace();
			}
			*/
			// 이 try-catch 작업을 어디에서 리턴하든지 상관없이 무조건 지킬 수 있는 방법은? --> 마지막 캐치블록 다음에 finally라고 쓰러감
			
		} finally { // 어디에서 return하던지 무조건!!! finally블럭 구문을 수행, 어 리턴이다! 그래도 일단 finally감
			// return이 없는 코드면 사실상 finally가 필요없음. 기본적으로 catch라든지 try 블록 안에 return하는 구문이 없으면 그냥 catch 블록 아래에 close적으면됨, 근데 대부분의 경우 중간에 return 구문이 있을것임
			// return을 어디서 하든 close는 무조건 해야함 --> 이럴때 finally 블록을 만들어서 약속 지켜주기!
		
			try {
				
				if(fos != null) { // close는 fos가 null이 아닐때만 해야함! --> if로 감싸기, 원래 이렇게 하면 됨 이게 기본 베이스고 문법 하나 더 배우자 --> IOException catch 블록 안으로 ㄱㄱ
					fos.close(); // 근본으로 따지면 얘는 밖에 있어야 함! 근데 밖으로 나가니까 뭐가문제야? try 밖으로 나가니까 fos는 try꺼라서 try끝나면 밖에서 쓸 수 없음!
					// fos가 try안에서 선언되면 밖에서 닫을 수 없음 --> fos 선언이 try 것이 아니라 메소드의 것이 되어야함 --> 선언을 try 위로 옮겨줌
					// 그래도 빨간줄인 이유? 아까 Closeable 까봤을때 IOException throws 있었음! 이걸 사용하는 쪽에서 예외처리 해줘야함 --> IOE에 대한 예외처리를 try-catch로

				}
				
			} catch(IOException e) { // 이것까지도 했는데 끝이아님
				// fos가 생성되는 시점에서 예외가 발생할 수 있음(FileNotFoundException), 그럼 객체 생성이 못 됐으니까 얘는 어떤 상태? fos는 null이 됨, null 인 상태로 close() 하려면? null에다가 참조해서 close() 호출하면 NullPointerExeption 발생
				// --> 이건 UE임, 내가 알아서 처리해야함 --> close는 fos가 null이 아닐때만 해야함! --> if로 감싸기
				
				e.printStackTrace();
				
			}
			
		} // finally 블록 안에있는것은 어디서 리턴하든 돌아가기 전에 무조건 수행함! 리턴 하기전에 일단 무조건 finally 돌림
		
	}
	
	// 우리가 만든 프로그램으로 외부매체(파일)에서 데이터를 가지고 올것임, a_byte 파일에 있는 내용을 우리걸로 끌고오겠음!
	// 프로그램 <== 외부매체(파일)
	// 입력 : 파일로부터 데이터를 가지고 오겠다.
	// FileInputStream, 파일로부터 입력받을때는 파일 입력이라 이걸 씀
	// 파일로부터 데이터를 가져와서 입력 받을건데, 1Byte단위로 입력받겠다.
	public void inputFromFile() {
		
		// 아까랑 똑같음, 근데 깨달음을 얻었다! 한번에 한줄로 선언하면 나중에 약속을 지키지 못하겠구나~
		// 선언은 선언대로 따로 하고, 생성해서 대입하는 과정은 try 블록 안에다가 따로 해 주어야겠구나!
		
		FileInputStream fis = null;
		
		try {
			
			// 1. 객체 생성 => 스트림연결하기
			fis = new FileInputStream("a_byte.txt"); // 약속을 지키기 위해서는 코드를 이렇게 작성해야겠다.
			// 얘는 파일을 못찾을 수 있음, FileNotFoundException 발생할 수 있음 --> catch
			
			// 스트림 연결했으니까 이친구로 입력을 받아올 수 있다. 입력을 받아와야겠다!
			// 출력할땐 write 했으니 입력할때는? read
			// 2. 스트림으로 입력받기
			// read()호출
			// 1Byte단위로 읽어옴, 읽어오려고 했더니 바로 빨간줄 --> 이거 읽어오면서 예외 발생할 수 있잖아! 예외처리 해줘야지! catch추가
			/*
			System.out.println((char)fis.read()); // 정수로 반환됨, 문자로 바꾸고싶으면 (char)로 형변환
			System.out.println(fis.read()); // 98
			System.out.println(fis.read()); // 99
			System.out.println(fis.read()); // 101
			System.out.println(fis.read()); // 102
			System.out.println(fis.read()); // 103
			System.out.println(fis.read()); // 65
			System.out.println(fis.read()); // 66
			System.out.println(fis.read()); // 116, 아까 한글 output할때 깨졌던거
			System.out.println(fis.read()); // 185
			System.out.println(fis.read()); // 160
			// 우리가 파일 데이터를 읽어올 때 이렇게 하염없이 읽어올 수는 없음, 데이터가 얼마나 있을 줄 알고...?
			// 읽어오는건 읽어오는데 어떻게? 파일의 데이터 만큼 반복문을 써서 읽어와야겠지!
			// 반복문을 써서 읽어오려면 뭘 알아야함? 파일을 다 읽어왔는데, 더이상 읽어올 값이 없으면? 뭐가 나오지? 이걸 알아야함
			// 파일의 마지막 데이터를 입력받고 나서 read()를 호출 시 -1을 반환
			System.out.println(fis.read()); // -1
			// 이걸 호출했을 때 -1이 아니면 반복을 시킬것임. -1이 아니면 반복을 해서 데이터값을 계속 읽어오다가, 얘를 호출했을 때 -1이 나오면 더이상 데이터가 없는거니까 거기에서 반복을 멈추면 되겠다
			* 
			*/
			
			// 이걸 반복문을 이용해서 한번 출력해보자.
			// 힌트! 보통 이런 상황에서는 어떻게 하냐면, 지금 반복을 몇번 돌려야 할 지 모름 --> while을 쓰는 것이 좋다.
			/*
			while(fis.read() != -1) {
				System.out.println(fis.read());
			}
			*/
			
			/*
			while(true) {
				
				if(fis.read() != -1) {
					System.out.println(fis.read());
				} else {
					break;
				}
				
			}
			*/
			// 둘중 어느걸 선택하든 결과는 퐁당퐁당
			// while문을 만남 계속돌것임, if문을 만남 --> 조건식으로 감, 조건식에서 메소드를 호출함, 처음 나올 98이 빠짐, -1과 98은 다른값
			// 조건식이 참이므로 if블록 안으로 들어옴, 99가 빠져나와서 출력됨
			// 또 돌러 감, 메소드 호출하면 101이 나옴, -1이랑 다르니까 들어감, 102 출력.. 이런식으로 계속함
			// 반복 한번 수행하는 동안 메소드를 두번 호출하니까 앞에거는 조건검사하느라 빠지고 뒤에것을 출력함 --> 퐁당퐁당으로 나옴!!
			
			// 우리가 하려는건 한번의 메소드 호출 결과를 가지고 조건검사도 하고 출력도 하고싶음, 하나의 값을 두번 쓰고싶음, 재활용을 하고싶음 --> 변수로 선언!, 값의 재활용은 변수!
			/*
			while(true) {
				
				int value = fis.read();
				
				if(value != -1) {
					System.out.println(value);
				} else {
					break;
				}
				
			}
			*/
			// 개발자로서 생각해야하는것! 첫번째, 메소드 호출시 반환값이 있다면 이걸 메소드라고 생각하면 안되고 그부분을 항상 값이라고 생각해야함! 메소드를 호출한게 아니라 무언가 값을 활용하는것, 대입연산자 오른쪽은 항상 값일 수 밖에 없음!
			// if문안에 메소드를 썼다면 나는 여기에서 무슨 값을 한 번 쓴것임, 출력문에서 또 쓰면 값을 또 쓰는 것 --> 아까 StringTokenizer 생각! 한번 부를때마다 하나씩 빠져나갔음, 다 빠지고 나면 할게없음
			// 메소드 호출시 반환값이 있다면 항상 그부분을 값이라고 생각해야함. 하나의 값을 여러번 사용해야한다면 그 즉시 변수를 떠올려야함!
			
			// 근데 보통 이런 상황에서는 템플릿 코드가 있음, 자바 개발자들이 사용하는 템플릿!
			// 인풋 받아야하네? 받아야하는데 있는지 없는지 체크를 해서 반복을 돌려야하네? 한다면?
			// 변수를 먼저 선언(조건식으로도 쓰고, 출력도 해줄 변수)
			int value = 0;
			
			// while문 ()안에서 처리
			while((value = fis.read()) != -1) {
				// value에 메소드 호출 결과를 대입, 대입한 값을 비교까지 함, 괄호를 통해 우선순위 지정해서 먼저 value 변수에 메소드 호출값을 대입하고, 그러면 값만 남음 --> 이 값을 내가 비교할 비교대상과 비교
				
				System.out.println((char)value); // 결과가 참이라면 value를 출력하면 됨
				
			}
			// 이게 자바개발자들의 이런 상황 템플릿, 근데 템플릿이 없어도 위에서처럼 할수 있음, 템플릿은 if문 안쓰고싶어서 쓰는거니까
			// 이런것들은 발상을 해내기 쉽지않음, 왜냐면 조건식 안에 변수에 값을 대입할 수 있어? 이 사실을 모르면 이 코드는 쓸 수 없음. 이건 방법을 아예 모르는것. 방법을 몰라서 못쓰는건 어쩔수없음. 수업시간에 배우면 되는것. 자바개발자들은 요렇게 씁니다~ 하고 방법이야 배우면 되는 것
			// 근데 fis.read()이런것들은 생각을 해볼 필요가 있음. 메소드 호출시 반환값이 있다? 그럼 이건 값이다. 하나의 값을 여러번 사용해야 한다? 변수를 쓰자 등등
			
			// 3. 마지막으로 꼭 해야할 일 --> 자원 반납!
			
			// 방어적 프로그래밍 단적인 예시
			// 문자열 비교
			Abc abc = new Abc();
			// 이 클래스 안에 있는 필드의 name이 다른 문자열과 같은지 비교하고 싶음 --> equals를 쓰고싶음 --> getter를 써서 받아와서 써야함
			
			System.out.println(abc.equals("이승철")); // 이렇게 쓰면 만약에 필드에 값이 대입되어있지 않다면? --> 기본값 null이 들어있을것이므로 null point exception --> 공격적인 방식
			System.out.println("이승철".equals(abc)); // --> 순서만 바꿔서 예외발생을 막을 수 있음, "이승철"은 이미 문자열이기 때문에 null일 수 없음, null point exception이 발생할리가 없음!
			// 순서를 바꾸는것만으로 방어적! 이런것을 항상 생각해야함, 특히 널 관련된것은 더
			
		} catch(FileNotFoundException e) {
			e.printStackTrace();
		} catch(IOException e) {
			e.printStackTrace();
		} finally {
			
			try {
				if(fis != null) { // 방어적, 코드를 짤때는 항상 방어적으로 짜야함. 방어적 프로그래밍 --> 아 그럴수있겠다 아 이걸 대비해야한다 아 이걸 막아야한다
					
					fis.close(); // 반납을 하다가 IOE가 발생할 수 있기 때문에 예외처리를 또 해주어야함 --> checked exception에 대한 이야기고
					// fis.close() 중에서, 참조변수가, inputstream이 파일을 못찾아서 생겨나지 못했다면? 여기에 널값이 대입되어있을테니까?
					// 그럼 null 가지고 뭐 하면? 이건 null point exception이 발생하니까 이거는 언체크드 익셉션이므로 개발자가 생각해서 ! 아 이거 널일수도 있겠다~ 예외를 처리해주어야한다
					
				}
			} catch(IOException e) {
				e.printStackTrace();
			}
			
		}
		
	}
	
}
