package com.kh.exception.run;

import com.kh.exception.controller.CheckedException;
import com.kh.exception.controller.UncheckedException;

public class Run {

	public static void main(String[] args) {
		
		/*
		 * 에러(Error)
		 * 버그는 옛날에 컴퓨터 불빛에 벌레 달라붙어서 문제생기던거 표현한데서 유래됨
		 * 
		 * - 시스템 에러(가장 심각) : 컴퓨터의 오작동으로 인해 발생하는 에러(재부팅 등으로 해결우리 선에서 해결하기는 어렵고 개발자 손을 떠난 문제)
		 * 						=> (심각) 소스코드로 해결이 안됨(엔지니어의 영역) --> 보통 물리적인 문제(정전, 지진 등 어쩔 수 없음)
		 * 
		 * - 컴파일 에러 : 프로그램 실행 전 소스코드상의 문법적인 문제로 발생하는 에러
		 * 						=> 소스코드를 수정해서 해결이 가능(빨간줄로 알려줌, 제일 쉬움, 문법이 익숙하지 않아서 발생)
		 * End of Line error같은거
		 * 
		 * - 런타임 에러 : 프로그램 실행 중 발생하는 에러 문법적으로는 문제가 없는데 발생
		 * 				=> 사용자의 잘못일 가능성이 높긴하지만..?(개발자의 의도대로 사용자가 입력하지 않을 경우 등)
		 * 				=> 이런 것 까지 개발자가 예측했어야함. 개발자가 예측 가능한 경우 처리하지 않았을 때! QA를 빡빡하게 했다면 조기발견했을수도
		 * 여기가 우리에게 첫 고비! 문법 잘못썼으면 빨간줄 나옴 그건 익숙하지 않으니까 쓰면 그만임
		 * 런타임 에러는 골아픔, 빨간줄이 없음, 막상 돌려보면, 실행하면 와장창! 잘 모르니까 어려움
		 * 예를 들면 정수 달라고 했는데 사용자가 텍스트를 입력할수도 있음 --> 그러면 실행됐을때 문제가됨
		 * 문제를 겪은 다음에 해결법을 배우고 스스로 해결해야 쌓이는 능력, 시간이 걸림(문제를 겪기 전까지는 해결이 어려움)
		 * 그래서 내가 만든건 남이 테스트해주는게 좋음
		 * 
		 * - 논리적 에러 : (로지컬 에러) 소스코드 상 문제도 없고, 실행했을 때도 문제가 발생하지 않음
		 * 				=> 의도와는 다르게 동작(기획 / 설계를 잘 못 했을 때)
		 * + 하고싶었는데 - 된다든지, 잘못된걸 찾는것보다 시원하게 날리고 새로만드는게 낫다네요 ㅎㅎ
		 * 
		 * 에러들은 이렇게 종류가 많음
		 * 예외 : 시스템 에러를 제외한 나머지 컴파일, 런타임, 논리적 에러와 같이 비교적 덜 심각한 애들
		 * 		 그 중에서도 주로 런타임 에러를 의미함
		 * 
		 */
		
		// 예외를 처리하는 방법에 대해 이야기하자! --> UncheckedException ㄱㄱ
		
		UncheckedException e = new UncheckedException();
		// e.method1();
		
		// e.homeWork();
		
		// e.method2();
		
		// e.method3();
		
		CheckedException ce = new CheckedException();
		
		try {
			
			ce.method1(); // 아까랑 똑같이 되어있음. 나 쓸거면 IOE에 대한 예외처리 니가 진행해줘야한다~
			// 이 예외가 일어난 구문을 나를 부르는 쪽에서 처리하도록 하는 문법이 던지기!
			// 결국에는 얘를 하려면 어딘가에서는 try-catch를 해야돼
			
		} catch(Exception e1) {
			
			// 모든 예외클래스 대장은 Exception 클래스, 어딘가에선 예외처리를 해야해~ --> checked exception
			e1.printStackTrace();
			
		}
		
	}

}
