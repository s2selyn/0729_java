package com.kh.exception.controller;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class CheckedException {
	
	// 이건 컴파일러가 체크해주는거! UncheckedException은 체크 안해주는거였음
	
	/*
	 * CheckedException
	 * 
	 * 문법적으로 반드시 예외처리를 해야하는 예외들
	 * => 주로 외부 매체와의 입/출력 시 확인 가능
	 * 
	 */
	
	public void method1() throws IOException {
		
		// 사용자에게 문자열을 하나 입력받아서
		// 입력받은 문자열의 길이를 출력
		
		// 아마도 내일 오후쯤 쓸것같은 친구 맛보기
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		// 문자열을 입력받을것임! BufferdReader의 readLine()이라는 메소드를 호출해서!
		// String str = br.readLine(); // Unhandled exception type IOException --> 이 예외가 발생할 수 있는데 핸들링이 안됐대요
		// 핸들이 뭔가요? 운전할때~ 뭔가 조작할때 쓰는거! 예외에 대한 조작 처리가 안됐다는 뜻!
		// 내가 봤을때 이 코드는 IOException(Input/Output Exception)이 발생할 수 있어! 외부에서 데이터값을 받는건데 그럼 input exception이 발생할수있는건데, 너 왜 예외처리 안하니? 예외처리 안한 이유가 뭐니? 라고 알려줌!
		// 예외처리하기전까지는 돌릴 수 없는 코드임! --> 그럼 예외처리 어떻게 함?
		
		String str = ""; // try 안에 들어가면 지역변수가 되므로 밖에서 선언해줘야함
		/*
		// 방법 1. try ~ catch문을 작성한다.
		try {
		
		// 아~ 그래? 이거 IOE가 발생할 수 있어? 얘가 예외가 발생할 수 있는 코드야? 하면! try 하고
			str = br.readLine(); // 물론 이렇게 try 구문 안에 들어가면 str이 지역변수가 되기 때문에 문자열 선언은 밖에서 해줘야겠네~
			// try ~ catch로 잡아서 처리하면 빨간줄 없어짐! --> IOE에 대한 핸들링을 진행해줬으므로!
			
		} catch(IOException e) {
			e.printStackTrace();
		} // catch해서 예외처리 해주면 끝!
		
		System.out.println(str.length());
		*/
		
		// 시원하게 컴파일러가 알려줌! 이 코드는 예외가 발생할법한 코드야! 넌 반드시 이 코드를 예외처리를 해야돼!
		// 보통 외부 매체랑 입출력할때는 IOE 무조건 일어날수도 있음, 그러니까 항상 이렇게 checked로 알려줌
		
		// 그렇게 따지면 이상한 게 있음. 우리 스캐너 많이 썼잖아. 스캐너도 외부의 입력을 받는것임. 근데 그때마다 예외처리한적 없음.
		// Scanner sc = new Scanner(System.in);
		// sc.nextInt();
		// 얘 쓸땐 이런거 없었음. 왜그래? 왜그런데? 왜 이거 할때 왜 이런거 없는데? 왜그런데? 하고 이친구는 왜 저런거 안알려줬나 하고 까보면 스캐너 안에 try-catch로 안에서 다 처리 해놨음
		// 원래는 예외가 발생해야지 맞는거. 원래는 예외가 발생해야하는건데 이 스캐너 클래스 안에서 try-catch로 잡아서 처리해놨기때문에 이걸 밖에서 쓰는 우리는 알지 못하고 사용함
		// 안에서 try-catch 열심히 다 해줌^^! 밖에서 쓰는쪽은 당연히 예외가 발생하는지 모르고 그냥 쓰는거죠.
		// 스캐너도 잘만든클래스~ 막상 메소드 안에 변수선언 조건문 반복문 이것뿐이다~ 세상 모든 코드는 이게 다고 거기에 예외처리를 예쁘고 알차게 넣어준것! 이 이상의 무언가는 잘 없음
		
		// 두번째! 도대체 이친구는 나한테 왜 어떻게 이렇게 예외처리를 해야된다는 사실을 알려주는것일까?
		
		// 방법 2. throws(던지기!) : 코드 작성부 말고 실제 메소드를 호출하는 부분으로 예외처리를 위임해버리는 방법
		str = br.readLine(); // 원래대로라면 이메소드를 호출해서 str에 값을 대입하려면 IOE가 발생할수도 있음, IOE에 대한 핸들링을 해줘야함
		// 실질적으로 얘가 바로 도는게 아니고 얘도 분명히 누군가 다른 메소드가 요친구를 호출해서 돌릴거란말이지, 얘를 돌렸을 때 예외가 일어날 수 있는 원인이 여러가지일수있음
		// 여러가지 원인이 있을 수 있는데, 이걸 내가 처리안할테니까 나를 갖다 쓰는 쪽에서 처리해라! 나는 이거 내가 처리 안할거야. 안할거니까 나 불러서 쓰는 친구 있지? 니가 이거 처리해 IO --> 해가지고 말그대로 던지기를 해버리는것!
		System.out.println(str.length());
		
		// 던져야겠다! --> 나 IOE에 대한 예외처리는 던지기를 할래 --> 메소드 선언부 뒤에 throws IOException 붙여버림, 아 나 던져야겠다 --> 이렇게 하면 더이상 이 클래스 내부에서는 예외처리해라~ 이런 라인이 나오지않음
		// 근데 클래스 내부가 아니라 갑자기 실행클래스가 아픔 --> 메소드를 호출하는 부분에서 아픔! 가보자!
		
	}
	
} // 예외 발생시키기는 나중에
	// 나중에 예외처리하는 예외처리기를 따로 만들것임. Exception handler라고 해서 예외처리만을 담당하는 클래스를 만들것(예외처리용 클래스) --> 이거 하면서 예외 발생시키는법 배울것
	// 예외처리는 경험과 시간이 필요함, 당장 외워서 처리할 수 있는 것은 아님, 코드를 작성하다가 실수하고 예외가 일어날 때 하나씩 추가하면됨
