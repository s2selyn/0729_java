package com.kh.exception.controller;

import java.util.InputMismatchException;
import java.util.Scanner;

public class UncheckedException {
	
	/*
	 * 체크를 안해주는 예외들(문법이 잘못된건 체크해줌)
	 * 
	 * 프로그램 실행 시 발생하는 예외들(이것들은 대부분 컴파일러가 체크 안해줌)
	 * RuntimeException
	 * 
	 * 가장 많이 만나게 될 예외(우리들의 적)
	 * - NullPointerException : 주소값 객체를 참조했더니 null값이 들어있을 경우 발생하는 예외
	 * 보통 NPE라고 함
	 * 
	 * - ArrayIndexOutOfBoundsException : 배열의 부적절한 인덱스로 접근했을 때 발생하는 예외
	 * 인덱스에 잘못된 방법으로 접근, 인덱스가 4번까지뿐인데 5번에 접근한다든지, 뜬금없이 100번에 간다든지, 범위를 넘어간다든지...
	 * 
	 * - ClassCastException : 허용할 수 없는 형변환을 진행할 경우 발생하는 예외
	 * 상속구조가 아닌데 억지로 나 클래스캐스팅해서 바꿔야지~ 형변환 하려는 경우 --> 바뀔 수 없음 자료형이 없으니까
	 * 
	 * - ArithmeticException : 나누기 연산을 0으로 나누면 발생하는 예외
	 * 
	 * - NegativeArraySizeException : 배열을 할당할 때 크기를 음수로 지정하면 발생하는 예외
	 * ...밑도끝도없이너무많음
	 * 
	 * 수업시간에는 의도적으로 보여주지 않음, 이걸 해결하는 방법은 여기서 배울거고, 굳이 안되는 코드는 보여줄 필요가 없어서 안했음
	 * 실수할만한 부분들만 발생할수있다~ 정도만 알려주고 굳이 안되는 코드는 안함, 되는 코드만 함, 그래서 못봤음
	 * 
	 * RuntimeException과 관련된 예외들은 공통점이 있음
	 * 개발자가 예측이 가능함(전부 염두할 수 있음)
	 * 
	 */
	
	// ArithmeticException, 수업하면서 가장 처음 만났던 예외
	public void method1() {
		
		// 사용자에게 두 개의 정수값을 입력받아서 나눗셈을 한 뒤 결과를 출력
		// 두 개의 정수값을 입력받아야겠다 --> Scanner가 있어야겠다
		Scanner sc = new Scanner(System.in);
		
		// 값을 두개를 받아야겠지
		System.out.print("첫 번째 정수를 입력해주세요 > ");
		int num1 = sc.nextInt();
		
		System.out.print("두 번째 정수를 입력해주세요(제발 0은 입력하지말아주세요) > ");
		int num2 = sc.nextInt(); // 여기에 0이 들어가면 안되는 상황을 경험으로 알고있음 --> 어떻게 하지? if!
		
		/*첫 번째 정수를 입력해주세요 > 5
		두 번째 정수를 입력해주세요 > 0
		Exception in thread "main" java.lang.ArithmeticException: / by zero
		at com.kh.exception.controller.UncheckedException.method1(UncheckedException.java:48)
		at com.kh.exception.run.Run.main(Run.java:40)
		 */
		// 이 문제는 개발자의 잘못이다, num2에 0이 들어갈 수 있다는 사실을 사전에 예측(염두)할 수 있기 때문
		// 이건 내가 한번이라도 경험해봤던 문제여야 생각가능!
		
		// 예외처리를 배우긴 할건데 그걸 하지않더라도 해결해줄수 있음 --> 0이 입력되었다면? 조건으로 연산이 일어나도록
		// 방법 1. 예외발생 자체를 원천 차단해버림(막을 수 있으면 이렇게 막는게 좋음 예외처리가 능사는 아님)
		// 문제를 일으키는 원인을 없애버림
		// 만약에 한글을 입력해버린다면? 원천차단을 못하는 경우! 오히려 이런 경우가 더 많을 수 있음
		/*
		if(num2 != 0) {
			System.out.println("연산 결과 : " + (num1 / num2));
		} else {
			System.out.println("너 혼꾸녕 나고싶어?");
		}
		*/
		
		// 방법 2. 예외처리를 진행
		// 전제조건이 있음, 소프트웨어에서 일어나는 모든 예외를 막을수는 없음(완벽한 소프트웨어는 없다!)
		// 개발자가 미처 예측하지 못한 경우, 기상천외한 방법으로 돌아가는 경우, 컴퓨터는 거짓말을 안하지만 말도안되는 상황으로 거짓말을 할수도 있음(자기장이 방해해서 전기신호가 어쩌고저쩌고 라든가)
		// 예외가 일어나면 프로그램은 실행을 멈춤
		// 예외를 막을 수는 없지만 그렇다고 프로그램이 종료되면 안되고 사용자가 예외 일어났는지 아닌지 모르고 계속 쓸 수 있도록 개발자가 해줘야함
		// 그럼 예외가 일어났을때 이것을 어떻게 코드상으로 처리해줄까? 이게 예외처리!
		
		// 예외처리 : 
		// 예외 상황을 감지(이거부터 시작임)하고 예외상황 발생 시
		// 프로그램이 비정상적인 종료가 되는것을 방지하고 적절한 대응 조치를 취하는 것
		
		try {
			
			System.out.println(num1 / num2); // 여기에서 문제가 발생! 예외가 발생할 수 있는 구문 --> try 블록 안에 집어넣음
			
			System.out.println("올바른 정수 입력!");
			// 예외가 발생하면 예외가 발생하는 즉시 catch가 데려가서 이 출력문은 출력되지 않는다 --> 쩜프!
			// 그러므로 try 블록 안에서 예외가 발생할 수 있는 코드 아래에는 중요한 코드 두면 안됨!
			
		} catch(ArithmeticException e) { // 보통은 매개변수명을 Exception 앞글자를 따서 e만으로 씀
			// catch 뒤에 소괄호 쓰고, 그안에 try블록 안에서 발생할 수 있는 예외 클래스명(예외처리클래스타입)과 변수명을 적음(매개변수 적는것임)
			// 캐치할때 예외가 발생했을때 객체가 들어올 매개변수가 들어옴
			// 예외가 일어나지 않으면 캐치는 있으나마나~
			
			System.out.println("두 번째 정수에 0을 입력하시면 나눌 수가 없습니다."); // catch블록 안에는 예외(ArithmeticException)가 발생했을 때어떤 코드를 수행할것인지 작성
			
		}
		
		System.out.println("프로그램 종료");
		
		// 프로그램은 실행했고 동작하는중임!
		// 0으로 나누다가 문제가 생긴 것! 하하호호출력은 수행이 안됐음, 문제가 생긴 시점에서 프로그램이 종료되어버림
		// 이러면 덜만든프로그램이됨, 문제가 일어나더라도 사용자는 모르고 계속 프로그램을 사용할 수 있어야함 --> 이게 예외처리!
		// 컴파일러 입장에서는 num2에 0이 들어올지 알 수가 없음 --> 이건 실행해봐야, 0이 들어와야지만 아는부분! --> 그래서 컴파일러가 체크를 안하고, 컴파일러가 빨간줄로 알려줄수가없음, 컴파일러 입장에서는 뭐가 들어올지 모름 --> 그러면 개발자가 처리해줘야함
		
		// try catch로 수정하고나서 일어나는 일들 설명(어떻게 동작했나요?)
		// 나눌수없당~ 출력, 프로그램 종료도 출력 --> 원래는 나누기 하는 순간 프로그램이 끝남, 메모리에서 나감 --> 문제가 생긴 순간 못나눈다고 출력됨
		// try에서 예외감지, 예외가 안 일어났다면 try 블록이 끝나고 catch블록 아래로 내려감
		// 예외감지했더니 예외가 발생하면? 원래는 프로그램 종료, try catch로 이 비정상적인 종료를 막을 수 있음!
		// 프로그램의 비정상적인 종료를 막을 수 있음 --> 대응도 해줘야함
		// 결국 0을 입력해서 문제가 생기긴 생겼으니까, 예외를 발생시킨 원인이 있을것이고, 거기에 추가적인 대응을 해줘야함, 그것을 catch 불록에 작성
		// 예외를 막은 것은 아님, 예외는 발생함!(예외는 막을 수 없음)
		// 예외상황을 감지하고(try블록을 통해서), 예외가 일어났을때 비정상적인 종료가 일어나는 것을 막고, 추가로 예외상황에 대해 대응하는 것까지 일련의 과정 전체를 예외처리라고 함!
		
		// 예외가 발생하지 않으면 try 내부를 전부 수행하고 catch 아래로 빠짐 --> 예외가 일어나지 않으면 캐치는 있으나마나~
		// 예외가 일어났을때가 문제임 --> try에서 내려가다가 예외가 발생함, 발생즉시 캐치로 이동(쩜프) --> 아래에 올바른 정수 입력이라는 출력문이 있어도 수행이 안됨
		
		// 예외처리로 오류를 예방할수는 없음, 났을때 감지하고 대응하는 메커니즘이 예외처리 --> 발생했을때 어떻게 할것인가! 예외가 일어나야 처리함
		// 오류를 애초에 막는건 조건문으로 하는거(원천차단)
		
		// 예외처리를 위한 문법
		/*
		 * try ~ catch문
		 * 
		 * [ 표현법 ]
		 * 
		 * try {
		 * 
		 * 		(num1 / num2) // 이렇게 예외가 발생할수도 있는 구문 작성(예외가 발생 안하는 구문은 안넣음, 가능성이 아주 조금이라도 있다면 try 블록에 넣음)
		 * 
		 * } catch(발생할예외클래스명 변수명) { // 예외가 발생한다면 어떻게 할 지 여기에 적어줌 => 매개변수
		 * 
		 * 		catch 뒤에 소괄호를 붙여줘야함! 매개변수
		 * 		자바는 클래스기반 언어이기때문에 예외도 전부 예외 처리를 위한 클래스로 구현되어있음
		 * 		객체가 생성되면서 매개변수가 들어옴
		 * 
		 * 		여기에 해당 예외가 발생했을 때 실행할 구문 작성
		 * 
		 * }
		 * 
		 */
		
	}
	
	// 숙제 떠올려보기
	public void homeWork() {
		
		Scanner sc = new Scanner(System.in);
		
		while(true) {
			
			System.out.println("메뉴를 선택해주세요");
			System.out.println("1. 추가하기");
			System.out.println("2. 검색하기");
			
			int menuNo = 0; // 선언만 했다면? try 블록 안에서 대입이 안될수도있음! 쓰고싶으면 초기화 해야함! 0으로 초기화
			try {
				
				menuNo = sc.nextInt(); // 여기에서 일어날 수 있는 예외를
				// try 블록 안에 이 문장을 넣는 순간 밖에서는 사용할 수 없는 상태가 되므로 밖에서 사용할 수 있도록 try 위에 변수를 선언만 해주고 여기서 대입해줌
				
			} catch(InputMismatchException e) { // 예외를 잡아주자!
				
				System.out.println("숫자만 넣어이눔아~~!!");
				// 예외가 발생했을때 수행할 작업 작성
				// 우리는 지금 출력문만 썼지만 예외처리시 해야할 작업이 무조건 출력문인것은 아님
				// 여기서 반복문 처음으로 다시 돌리고 싶다면 컨티뉴, 예외가 발생하면 while문 바깥으로 내보내고 싶다면 브레이크.. continue; break; 등을 쓸 수 있음 --> 개발자가 어떤 생각을 가지고 있느냐에 따라 작성해야 하는 코드가 달라짐
				// 예외처리 시 catch문에 적어야하는 내용이 출력문은 아님 --> 예외가 발생했을때의 내가 생각하는 적절한 조치를 수행하는것, 그게 출력문인것은 아님
				
			}
			// 이 시점에 잘못 입력되면 예외가 일어날 수 있음, 예외가 일어나는 순간 반복도 수행되지 않고 출력문도 수행되지 않고 프로그램이 종료되어버림
			// 예외처리를 배우고 있으니, 정수를 입력받는 메소드에서 정수값이 아닌 것을 사용자가 입력하면 이곳에서 예외가 발생할 수 있구나! 를 알았음
			// 예외가 일어나면 프로그램이 비정상적 종료가 되는데, 비정상적 종료되지 않도록 하고싶다 --> try-catch 해주자
			// try 블록 안에는 예외가 발생할 수 있을수도 있는 코드를 넣음
			// catch 블록의 소괄호 안에는 일날수도 있는 예외클래스명 먼저 작성하고 한칸띄우고 변수식별자 보편적으로 e로 적음
			
			sc.nextLine();
			
			System.out.println(menuNo + "번 메뉴를 선택하셨습니다.");
			// 예외가 생겨도 catch를 수행하고 이걸 수행할 수 있게됨, 0으로 초기화했으므로 0번으로 출력되는게 마음에 안들어 --> 예외가 발생한다고 해서 종료되지 않음, catch 끝나고 그다음을 수행하고 다시 반복문을 수행하러 올라감
			
		}
		
	}
	
	// 아직 우리는 예외클래스를 잘 모르니까 예외가 일어나면 이런게 있구나 하고 try-catch 쓰면 됨
	
	// 이런 상황이 발생할수도 있다
	public void method2() {
		
		// System.out.println("하이");
		
		// 스캐너 객체를 생성하고 사용자에게 정수값을 입력받아보자
		Scanner sc = new Scanner(System.in);
		
		System.out.print("정수를 입력해주세요(0은 제외) > ");
		
		// 서로 다른 예외가 발생할 수 있음
		// 앞에서 배운대로라면 예외가 발생할 수 있는 코드 두곳을 각각 try-catch로 예외처리
		/*
		try {
			int num = sc.nextInt();
		} catch(InputMismatchException e) {
		}
		
		try {
			System.out.println("100을 입력값으로 나눈 결과 : " + (100 / num));
		} catch(ArithmeticException e) {
		}
		*/
				
		// --> 이걸 한번에 처리할 수 있는 방법이 있음 --> try 블록 안에 같이 넣음
		try {
			
			// 스캐너 이용해서 정수를 입력받고
			int num = sc.nextInt(); // 예외가 발생할 수 있음 --> InputMismatchException
		
			// 출력문을 이용해서 이런 값을 출력해보자
			System.out.println("100을 입력값으로 나눈 결과 : " + (100 / num)); // 예외가 발생할 수 있음 --> ArithmeticException
			
		} catch(InputMismatchException e) { // 1. 먼저 입력받은 값이 정수인지 판단
			System.out.println("숫자로 된 정수값이 아닙니다.");
		} catch(ArithmeticException e) { // 2. 정수가 맞다면 0인지 판별
			System.out.println("0은 안돼요!!");
		}
		System.out.println("프로그램 종료"); // 프로그램 종료되는지 확인하기 위해서 작성
		
	}
	
	public void method3() {
		// 배열
		
		// 사용자에게 정수값을 입력받아서
		// 입력받은 만큼의 크기를 가진 배열을 생성 및 할당하고
		// 100번째 인덱스 값을 출력
		
		Scanner sc = new Scanner(System.in);
		System.out.print("정수를 입력해주세요 > ");
		
		// InputMismatchException : 스캐너 메소드의 자료형과 일치하지않음
		// NegativeArraySizeException : 배열의 크기를 음수로 지정하면 파업
		// ArrayIndexOutOfBoundsException : 배열의 크기보다 큰 인덱스에 접근하면 파업
		
		// 문제3총사, 파업시리즈
		/*
		int size = sc.nextInt(); // 사용자가 정수를 입력하지 않는다면? --> 파업
		int[] arr = new int[size]; // 배열을 선언하고 할당하는데, 크기에 음수가 들어가면? --> 파업
		System.out.println(arr[100]); // 배열 인덱스에 접근하는데, 인덱스가 존재하지 않으면? --> 파업
		*/
		// 모르면 어쩔 수 없는데 얘네 파업시리즈인것을 알았다 --> 예외처리해야함!
		
		try {
			
			int size = sc.nextInt();
			int[] arr = new int[size];
			System.out.println(arr[100]);
			// 얘네들 공통점이 있음 --> 특정 클래스의 후손클래스(예외처리를하는 모든클래스는 올라가다보면 Exception 클래스가 대장!)
			// UncheckedException은 모두 RuntimeException을 상속받는 후손클래스이다			
			// 그러므로 다형성을 이용해서 조상타입을 사용할 수 있다!
			
		} catch(InputMismatchException e) {
			e.printStackTrace(); // 얘는 꼭 개발단계에서만
			System.out.println("정수넣어랏!");
		} /*catch(NegativeArraySizeException e) {
			System.out.println("음수넣지맛!");
		} catch(ArrayIndexOutOfBoundsException e) {
			System.out.println("101보다 큰수!!!");
		}
		*/
		
		// 이 클래스들에게 공통적으로 상속해주는 런타임예외 클래스로 잡아줄수있음, 이렇게 하면 내가 모르는 예외도 잡을 수 있음, 예외 처리할 방법이 헷갈릴수도 있겠지
		catch(RuntimeException e) {
			System.out.println("아마도... 음수를 입력했거나..? 100보다 크지 않아서...?");
		} /*catch(InputMismatchException e) {
			System.out.println("정수넣어랏!"); // <-- 이런 식으로 잡으면 안됨! 런타임이 인풋미스매치의 조상임, 인풋미스매치 발생해도 런타임이 잡아서 처리할 수 있음
			// 이미 나설 이유가 없음, 위쪽에서 처리해버렸음
		}
		*/
		// catch문을 쓸때도 자식 예외클래스를 위쪽에 배치하고, 넓은 범위를 포괄할 수 있는 조상클래스가 아래쪽에 있어야함
		
		// 개발단계에서는 예외처리도 중요하지만 어디에서 예외가 일어나는지 알아야함
		// 매개변수로 넘어온 e를 보면 printStackTrace(); 라는 메소드가 있음 --> 얘를 꼭 적어줌, 콘솔에 빨간색 적어주는 역할, 스택을 추적해서 콘솔에 띄워줌, 이게 있어야 몇행에서 문제가 있는지 알수있음
		// 개발단계에서는 이걸 같이 보여주고, 개발이 끝난 다음에 운영단계에서는 존재하면 안됨!
		// 차이점: 원래는 printStackTrace 띄우고 프로그램 종료되는데, catch에 들어갔을때는 콘솔에 printStackTrace가 알려주고, catch 밑에도 계속 수행됨
		
	}
	
}
